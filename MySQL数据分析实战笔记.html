<!DOCTYPE html>
<html>
<head>
<title>MySQL数据分析实战笔记_（第一、二、三部分）</title>
<script src="https://hm.baidu.com/hm.js?44b6fcd69c6e2f3250c2ade16f5b4622"></script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?44b6fcd69c6e2f3250c2ade16f5b4622";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
    margin: 0;
    padding: 0;
    border: 0;
}

/* BODY
=============================================================================*/

body {
    font-family: Helvetica, arial, freesans, clean, sans-serif;
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    background-color: #fff;
    padding: 20px;
    max-width: 960px;
    margin: 0 auto;
}

body>*:first-child {
    margin-top: 0 !important;
}

body>*:last-child {
    margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
    margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
    margin: 20px 0 10px;
    padding: 0;
    font-weight: bold;
    -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
    font-size: inherit;
}

h1 {
    font-size: 28px;
    color: #000;
}

h2 {
    font-size: 24px;
    border-bottom: 1px solid #ccc;
    color: #000;
}

h3 {
    font-size: 18px;
}

h4 {
    font-size: 16px;
}

h5 {
    font-size: 14px;
}

h6 {
    color: #777;
    font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
    margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
    color: #4183C4;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
    padding-left: 30px;
}

ul li > :first-child,
ol li > :first-child,
ul li ul:first-of-type,
ol li ol:first-of-type,
ul li ol:first-of-type,
ol li ul:first-of-type {
    margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
    margin-bottom: 0;
}

dl {
    padding: 0;
}

dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px;
}

dl dt:first-child {
    padding: 0;
}

dl dt>:first-child {
    margin-top: 0px;
}

dl dt>:last-child {
    margin-bottom: 0px;
}

dl dd {
    margin: 0 0 15px;
    padding: 0 15px;
}

dl dd>:first-child {
    margin-top: 0px;
}

dl dd>:last-child {
    margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
    font-size: 12px;
    font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
    margin: 0 0px;
    padding: 2px 4px;
    color: #c7254e;
    font-size: 90%;
    white-space: nowrap;
    border: 1px solid #eaeaea;
    background-color: #f8f8f8;
    border-radius: 3px;
}

pre>code {
    margin: 0;
    padding: 0;
    white-space: pre;
    border: none;
    background: transparent;
}

pre {
    background-color: #f8f8f8;
    border: 1px solid #ccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px;
}

pre code, pre tt {
    background-color: transparent;
    border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
    border-left: 4px solid #DDD;
    padding: 0 15px;
    color: #777;
}

blockquote>:first-child {
    margin-top: 0px;
}

blockquote>:last-child {
    margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
    clear: both;
    margin: 15px 0;
    height: 0px;
    overflow: hidden;
    border: none;
    background: transparent;
    border-bottom: 4px solid #ddd;
    padding: 0;
}

/* TABLES
=============================================================================*/

table {
    width:100%;
    max-width: 100%;
    color: #5c5d5e;
    border-collapse: collapse;
    border-spacing: 0;
}

table th {
    font-weight: bold;
    background-color: #faf9f9;
    border-bottom: 2px solid #eef0f2;
}

table th, table td {
    border: 1px solid #eef0f2;
    padding: 6px 13px;
}

table tr {
    border-top: 1px solid #eef0f2;
    background-color: #fff;
}

table td {
    border-color: #eef0f2;
    border-bottom: 1px solid #efeff1;
}

table tr:nth-child(2n) {
    background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
    max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<!-- 声明文档使用的字符编码 -->
    <meta charset='utf-8'>
    <!-- 优先使用 IE 最新版本和 Chrome -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <!-- 页面描述 -->
    <meta name="description" content="不超过150个字符"/>
    <!-- 页面关键词 -->
    <meta name="keywords" content=""/>
    <!-- 网页作者 -->
    <meta name="author" content="name, email@gmail.com"/>
    <!-- 搜索引擎抓取 -->
    <meta name="robots" content="index,follow"/>
    <!-- 为移动设备添加 viewport -->
    <meta name="viewport" content="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no">
    <!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz -->

    <!-- iOS 设备 begin -->
    <meta name="apple-mobile-web-app-title" content="标题">
    <!-- 添加到主屏后的标题（iOS 6 新增） -->
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 -->

    <meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">
    <!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
    <!-- 设置苹果工具栏颜色 -->
    <meta name="format-detection" content="telphone=no, email=no"/>
    <!-- 忽略页面中的数字识别为电话，忽略email识别 -->
    <!-- 启用360浏览器的极速模式(webkit) -->
    <meta name="renderer" content="webkit">
    <!-- 避免IE使用兼容模式 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
    <meta name="HandheldFriendly" content="true">
    <!-- 微软的老式浏览器 -->
    <meta name="MobileOptimized" content="320">
    <!-- uc强制竖屏 -->
    <meta name="screen-orientation" content="portrait">
    <!-- QQ强制竖屏 -->
    <meta name="x5-orientation" content="portrait">
    <!-- UC强制全屏 -->
    <meta name="full-screen" content="yes">
    <!-- QQ强制全屏 -->
    <meta name="x5-fullscreen" content="true">
    <!-- UC应用模式 -->
    <meta name="browsermode" content="application">
    <!-- QQ应用模式 -->
    <meta name="x5-page-mode" content="app">
    <!-- windows phone 点击无高光 -->
    <meta name="msapplication-tap-highlight" content="no">
    <!-- iOS 图标 begin -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-57x57-precomposed.png"/>
    <!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"/>
    <!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"/>
    <!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->
    <!-- iOS 图标 end -->

    <!-- iOS 启动画面 begin -->
    <link rel="apple-touch-startup-image" sizes="768x1004" href="/splash-screen-768x1004.png"/>
    <!-- iPad 竖屏 768 x 1004（标准分辨率） -->
    <link rel="apple-touch-startup-image" sizes="1536x2008" href="/splash-screen-1536x2008.png"/>
    <!-- iPad 竖屏 1536x2008（Retina） -->
    <link rel="apple-touch-startup-image" sizes="1024x748" href="/Default-Portrait-1024x748.png"/>
    <!-- iPad 横屏 1024x748（标准分辨率） -->
    <link rel="apple-touch-startup-image" sizes="2048x1496" href="/splash-screen-2048x1496.png"/>
    <!-- iPad 横屏 2048x1496（Retina） -->

    <link rel="apple-touch-startup-image" href="/splash-screen-320x480.png"/>
    <!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) -->
    <link rel="apple-touch-startup-image" sizes="640x960" href="/splash-screen-640x960.png"/>
    <!-- iPhone/iPod Touch 竖屏 640x960 (Retina) -->
    <link rel="apple-touch-startup-image" sizes="640x1136" href="/splash-screen-640x1136.png"/>
    <!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) -->
    <!-- iOS 启动画面 end -->

    <!-- iOS 设备 end -->
    <meta name="msapplication-TileColor" content="#000"/>
    <!-- Windows 8 磁贴颜色 -->
    <meta name="msapplication-TileImage" content="icon.png"/>
    <!-- Windows 8 磁贴图标 -->

    <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"/>
    <!-- 添加 RSS 订阅 -->
    <link rel="shortcut icon" type="image/ico" href="/favicon.ico"/>
    <!-- 添加 favicon icon -->
    
<meta name='viewport' content='width=device-width initial-scale=1'>
<meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache">
<meta http-equiv="Cache" content="no-cache">
<!-- 去缓存 -->

<script src="https://unpkg.com/umoji@2.0.0/dist/umoji.umd.js"></script>
<!-- 表情包 -->

<link href="http://cdn.bootcss.com/highlight.js/8.0/styles/vs.min.css" rel="stylesheet">
<script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  
<script >hljs.initHighlightingOnLoad();</script> 

<link href="https://cdn.bootcss.com/jquery.tocify/1.9.0/stylesheets/jquery.tocify.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/1.8.2/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/jqueryui/1.10.1/jquery-ui.min.js"></script>
<script src="https://cdn.bootcss.com/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js"></script>

<style>
.tocCal{
	position: fixed;
	width: 400px;
	max-width: 450px;
	margin: 0px 0px 20px 0px;	
	top: 36px;	
	right:30px;	
	font-size: 13px;
	max-height:90%;		
	background-color: #0088CC;	
	border: 1px solid #ccc;
	webkit-border-radius: 6px;
	moz-border-radius: 6px;
	border-radius: 6px;
	color: white;
}

.toc {
	position: fixed;
	width: 400px;
	max-width: 450px;
	margin: 0px 0px 20px 0px;
	top: 60px;
	right:30px;	
	/*background: #f1f1f1;*/	
	background-color: #ffffff;
	
	font-size: 13px;
	max-height:86%;		
	
	border: 1px solid #ccc;
	webkit-border-radius: 6px;
	moz-border-radius: 6px;
	border-radius: 6px;
}

.nav-list > .active > a, .nav-list > .active > a:hover {
    color: #ffffff;
    text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.2);
    background-color: #0088cc;
}
</style>

<script type="text/javascript">
// ==UserScript==
// @name 窄边滚动条 (Narrow Scrollbar)
// @description 原始配色8px滚动条(仅适用于WebKit内核浏览器)
// @namespace https://github.com/ue1/userscripts
// @version 1.0.1
// @run-at document-start
// @include http*
// @compatible chrome
// @grant none
// ==/UserScript==
var _tag = "head|body|html".split("|");
for (var i = 0; i < _tag.length; i++) {
    var _head = document.getElementsByTagName(_tag[i])[0];
    if (!_head) continue;
    var _style = document.createElement('style');
    _style.setAttribute("type", "text/css");
    _style.innerHTML = "::-webkit-scrollbar{width:8px;height:8px;}::-webkit-scrollbar-thumb:hover{background-color:#a8a8a8;}::-webkit-scrollbar-thumb{background-color:#c0c0c0;}::-webkit-scrollbar-track-piece{background-color:#f1f1f1;}::-webkit-scrollbar-thumb:active{background-color:#787878;}";
    _head.appendChild(_style);
    break;
}
</script>

<script type="text/javascript">
    function wrapOldContentByDiv() {
        var oldContentDiv = document.createElement("div");
        oldContentDiv.style.cssText = "float:right; width:72%; padding-left: 3%; padding-right:3%;border: 2px solid #CACACA;";
        oldContentDiv.innerHTML = document.body.innerHTML;
        document.body.style["max-width"] = "100%";
        document.body.style["margin"] = "20px";
        document.body.style["padding"] = "0";
        document.body.innerHTML = '';
        document.body.appendChild(oldContentDiv);
    };

    function addDirectorySwitch(directoryDiv) {
        var directorySwitchP = document.createElement("p");
        directorySwitchP.style.cssText = "text-align: left; margin: 0;";
        directoryDiv.appendChild(directorySwitchP);

        var ele_span = document.createElement("span");
        ele_span.style.cssText = "font-weight: 1000;";
        var ele_text = document.createTextNode("目录");
        ele_span.appendChild(ele_text);

        var ele_a = document.createElement("a");
        ele_a.appendChild(document.createTextNode("[-]"));
        ele_a.setAttribute("href", "#");
        ele_a.setAttribute("onclick", "javascript:return switchAllDirectory(this);");
        ele_a.setAttribute("title", "Click to Open TOC");

        ele_span.appendChild(ele_a);
        directorySwitchP.appendChild(ele_span);
    }

    function createTree(parentNode, tags, index, maxLevel) {
        if (index >= tags.length) {
            return -1;
        }

        var lastLevel = -1;
        for (var i = index; i < tags.length; i++) {
            var header = tags[i];
            var level = parseInt(header.tagName.substr(1), 10);

            var childNode = {'tag': header, 'childNodes': [], 'level': level};
            if (level > parentNode.level) {
                if (lastLevel > 0 && level > lastLevel) {
                    // 子子类
                    index = createTree(parentNode.childNodes[parentNode.childNodes.length - 1], tags, i);
                    if (index < 0) {
                        return -1;
                    } else {
                        i = index - 1;
                    }
                } else {
                    parentNode.childNodes.push(childNode);
                    lastLevel = level;
                }
            } else if (level <= maxLevel && parentNode.level > maxLevel) {
                parentNode.childNodes.push(childNode);
                lastLevel = level;
            } else {
                return i;
            }
        }
    }

    function createAElement(tag, index) {
        var a = document.createElement("a");
        a.style.cssText = "";
        a.setAttribute("href", "#" + tag.textContent);
        a.innerHTML = index.toString() + tag.textContent;
        return a;
    }

    function createOlElement() {
        var ol_el = document.createElement("ol");
        ol_el.style["line-height"] = "180%";
        ol_el.style["list-style-type"] = "none";
        ol_el.style["margin-left"] = "0";
        return ol_el
    }

    function createEmptyLiElement() {
        var emptyLiEle = document.createElement("li");
        return emptyLiEle
    }

    function getIndex(parentDirectory, directoryLevel, index) {
        if (directoryLevel === 0) {
            return parentDirectory + (index + 1).toString() + "."
        } else {
            return parentDirectory + (index + 1).toString() + ".";
        }
    }

    function createLeafElement(node, curDirectory) {
        var liEle = createEmptyLiElement();
        var aEle = createAElement(node.tag, curDirectory);
        liEle.appendChild(aEle);
        return liEle
    }

    function getArrowDownStyle() {
        return " width: 0;" +
            "    height: 0;" +
            "    position: relative;" +
            "    margin-right: 8px;" +
            "    top: 3px;" +
            "    display: inline-block;" +
            "    border: 6px outset;" +
            "    border-color: black transparent transparent transparent;"
    }

    function getArrowRightStyle() {
        return " width: 0;" +
            "    height: 0;" +
            "    left: 5px;" +
            "    position: relative;" +
            "    margin-right: 8px;" +
            "    display: inline-block;" +
            "    border: 6px solid;" +
            "    border-color: transparent transparent transparent black;"
    }

    /*
    <ol>
        <li><a>根节点1</a></li>
        <li><a>根节点2</a></li>
        <li>
            <div>
                <a><span>[-]</span>根节点3</a>
                <ol>
                    <li><a>子节点1</a></li>
                    <li><a>子节点2</a></li>
                    <li><a>子节点3</a></li>
                </ol>
            </div>
        </li>
        <li><a>根节点4</a></li>
     </ol>
    * */
    // node, 1.2.3 4 0
    function renderTree(node, parentDirectory, directoryLevel, index) {
        var childNodes = node.childNodes;
        var tagContent = node.tag.textContent;

        node.tag.setAttribute("id", tagContent);

        var curDirectory = getIndex(parentDirectory, directoryLevel, index);
        var directoryName = curDirectory + "&nbsp;" + tagContent;

        // 叶子节点
        if (childNodes.length === 0) {
            return "<li style='padding-left: 24px;'><a href='#" + tagContent + "'>" + directoryName + "</a></li>"
    //                return createLeafElement(node, curDirectory)
        }

        // 非叶子节点
        var childContent = "";
        for (var j = 0; j < node.childNodes.length; j++) {
            childContent += renderTree(node.childNodes[j], curDirectory, directoryLevel + 1, j);
        }

        return "<li>" +
            "   <div>" +
            "      <div>" +
            "         <div id='" + directoryName + "' class='open' style='" + getArrowDownStyle() + "' onclick='return switchDirectory(this);'></div>" +
            "         <a href='#" + tagContent + "' ondblclick='return switchByDbClick(this);'>" + directoryName + "</a>" +
            "      </div>" +
            "      <ol id='ol-" + directoryName + "' style='line-height: 180%;list-style-type: none; padding-left: 20px;'>" + childContent + "</ol>" +
            "   </div>" +
            "</li>";

        /*var liEle = createEmptyLiElement();
        var aEle = createAElement(node.tag, curDirectory);

        var parentElement = document.createElement("div");
        parentElement.appendChild(aEle);

        var olElement = createOlElement();

        var tempNode;
        for (var j = 0; j < node.childNodes.length; j++) {
            tempNode = node.childNodes[j];
            var element = renderTree(tempNode, curDirectory, directoryLevel + 1, j);
            olElement.appendChild(element);
        }
        parentElement.appendChild(olElement);

        liEle.appendChild(parentElement);
        return liEle;*/
    }

    function switchByDbClick(aEle) {
        switchDirectory(aEle.parentElement().firstChild)
    }

    // 开关目录
    function switchDirectory(ele) {
        var divEle = ele.parentNode.parentNode;
        var olEle = divEle.lastElementChild;
        if (ele.className === "open") {
            // 关闭
            olEle.style.cssText = "display:none;line-height: 180%;list-style-type: none; padding-left: 20px";
            ele.setAttribute("class", "close");
            ele.style.cssText = getArrowRightStyle();
        } else if (ele.className === "close") {
            // 打开
            olEle.style.cssText = "line-height: 180%;list-style-type: none; padding-left: 20px";
            ele.setAttribute("class", "open");
            ele.style.cssText = getArrowDownStyle();
        }
    }

    function switchAllDirectory(e) {
        var rootOlElement = document.getElementById("outline_ol");
        var ols = rootOlElement.getElementsByTagName("ol");
        var isOpen = false;

        if (e.innerHTML === '[+]') {
            e.setAttribute('title', 'collapse');
            e.innerHTML = '[-]';
            isOpen = true;
        } else {
            e.setAttribute('title', 'expand');
            e.innerHTML = '[+]';
        }


        for (var i = 0; i < ols.length; i++) {
            var olEle = ols[i];
            if (isOpen) {
                olEle.style.display = "block";
                olEle.parentNode.firstElementChild.firstElementChild.style.cssText = getArrowDownStyle();
            } else {
                olEle.style.display = "none";
                olEle.parentNode.firstElementChild.firstElementChild.style.cssText = getArrowRightStyle();
            }
        }

        e.blur();
        return false;
    }

    document.addEventListener("DOMContentLoaded", function () {
        // 1, 将body内容提取到div标签中
        wrapOldContentByDiv();

        // 2, 创建左边目录列表Div
        var directoryDiv = document.createElement("div");
        directoryDiv.setAttribute("id", "outline-list");
        directoryDiv.style.cssText = "width:20%;height:100%; float:left;font-size:16px,z-index:1;position: fixed;overflow: hidden;";

        // 3, 目录展开折叠开关
        addDirectorySwitch(directoryDiv);

        // 4, 创建目录列表
        var directoryOl = document.createElement("ol");
        directoryOl.style.cssText = "padding-left:14px;line-height:180%;list-style-type:none;height: 85%;padding-bottom: 30px; overflow: auto;";
        directoryOl.setAttribute("id", "outline_ol");
        directoryDiv.appendChild(directoryOl);
        var div1 = document.createElement("div");
        div1.style.cssText = "clear:both";

        // 插入目录
        document.body.insertBefore(directoryDiv, document.body.childNodes[0]);

        // 5, 获取所有的H标签
        var hTags = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
        if (hTags.length < 2)
            return;

        var rootNode = {'tag': directoryOl, 'childNodes': [], 'level': 0};
        var maxLevel = parseInt(hTags[0].tagName.substr(1), 10);
        // 6, 创建树形结构
        createTree(rootNode, hTags, 0, maxLevel);

        // 7, 绘制树结构
        var htmlContent = "";
        for (var j = 0; j < rootNode.childNodes.length; j++) {
    //                var element = renderTree(rootNode.childNodes[j], '', 1, j);
    //                directoryOl.appendChild(element);

            htmlContent += renderTree(rootNode.childNodes[j], '', 1, j);
        }
        directoryOl.innerHTML = htmlContent;
    });
</script>

<script>
var wx ,wy;	
$(document).mousemove(function(e){ 
	wx  = e.clientX;
	wy = e.clientY; 
});

$(window).scroll(function() {	

	var _height=$("#toc").height()/3;
	
	var _hh=$("#toc").scrollTop() + $("#toc").find(".active").offset().top - $("#toc").offset().top;		
	
	var d_left = document.getElementById("toc").offsetLeft;
    var d_top = document.getElementById("toc").offsetTop;
    var d_width = document.getElementById("toc").clientWidth;
    var d_height = document.getElementById("toc").clientHeight;

    if(wx < d_left || wy<d_top || wx > (d_left + d_width) || wy > (d_top + d_height)){
		$("#toc").scrollTop(_hh-_height);			
	}
	
});
</script>


<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


/* 全局属性 */
#write {
  max-width: 860px;
  font-size: 16px;
  color: black;
  padding: 0 10px;
  line-height: 1.6;
  word-spacing: 0px;
  letter-spacing: 0px;
  word-break: break-word;
  word-wrap: break-word;
  text-align: left;
  font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;
}

/*段落*/
#write p {
  font-size: 16px;
  padding-top: 8px;
  padding-bottom: 8px;
  margin: 0;
  line-height: 26px;
  color: black;
}


/*标题*/
#write h1,
#write h2,
#write h3,
#write h4,
#write h5,
#write h6 {
  margin-top: 30px;
  margin-bottom: 15px;
  padding: 0px;
  font-weight: bold;
  color: black;
}
#write h1 {
  font-size: 1.5rem;
}
#write h2 {
  font-size: 1.3rem;
  border-bottom: 2px solid rgb(239, 112, 96);
}
#write h2 span {
 display: inline-block;
 font-weight: bold;
 background: rgb(239, 112, 96);
 color: #ffffff;
 padding: 3px 10px 1px;
 border-top-right-radius: 3px;
 border-top-left-radius: 3px;
 margin-right: 3px;
}
#write h2:after {
 display: inline-block;
 content: "";
 vertical-align: bottom;
 border-bottom: 36px solid #efebe9;
 border-right: 20px solid transparent;
}
#write h3 {
  font-size: 1.2rem;
}
#write h4 {
  font-size: 1.1rem;
}
#write h5 {
  font-size: 1rem;
}
#write h6 {
  font-size: 1rem;
}

/*列表*/
#write ul,
#write ol {
  margin-top: 8px;
  margin-bottom: 8px;
  padding-left: 25px;
  color: black;
}
#write ul {
  list-style-type: disc;
}
#write ul ul {
  list-style-type: square;
}
#write ol {
  list-style-type: decimal;
}
#write li section {
  margin-top: 5px;
  margin-bottom: 5px;
  line-height: 26px;
  text-align: left;
  color: rgb(1,1,1); /* 只要是纯黑色微信编辑器就会把color这个属性吞掉。。。*/
  font-weight: 500;
}

/*引用*/
#write blockquote {
  display: block;
  font-size: 0.9em;
  overflow: auto;
  overflow-scrolling: touch;
  border-left: 3px solid rgb(239, 112, 96);
  color: #6a737d;
  padding: 10px 10px 10px 20px;
  margin-bottom: 20px;
  margin-top: 20px;
  background: #fff9f9;
}
#write blockquote p {
  margin: 0px;
  color: black;
  line-height: 26px;
}

/*链接*/
#write a {
  text-decoration: none;
  word-wrap: break-word;
  font-weight: bold;
  border-bottom: 1px solid #1e6bb8;
  color: rgb(239, 112, 96);
  border-bottom: 1px solid rgb(239, 112, 96);
}

/*行内代码*/
#write p code,
#write li code {
  font-size: 14px;
  word-wrap: break-word;
  padding: 2px 4px;
  border-radius: 4px;
  margin: 0 2px;
  color:  rgb(239, 112, 96);;
  background-color: rgba(27,31,35,.05);
  font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;
  word-break: break-all;
}

/*图片*/
#write img {
  display: block;
  margin: 0 auto;
  max-width: 100%;
}

/*表格*/
#write table {
  display: table;
  text-align: left;
}
#write tbody {
  border: 0;
}
#write table tr {
  border: 0;
  border-top: 1px solid #ccc;
  background-color: white;
}
#write table tr:nth-child(2n) {
  background-color: #F8F8F8;
}
#write table tr th,
#write table tr td {
  font-size: 16px;
  border: 1px solid #ccc;
  padding: 5px 10px;
  text-align: left;
}
#write table tr th {
  font-weight: bold;
  background-color: #f0f0f0;
}

/* 行内代码 */
#write span code, #write li code {
 color: rgb(239, 112, 96);
}

/* 脚注上标 */
#write .md-footnote {
 font-weight: bold;
 color: rgb(239, 112, 96);
}
#write .md-footnote > .md-text:before {
 content: '['
}
#write .md-footnote > .md-text:after {
 content: ']'
}

/* 脚注 */
#write .md-def-name {
  padding-right: 1.8ch;
}
#write .md-def-name:before {
  content: '[';
  color: #000;
}
#write .md-def-name:after {
  color: #000;
}

/* 代码块主题 */
.md-fences:before {
  content: ' ';
  display: block;
  width: 100%;
  background-size: 40px;
  background-repeat: no-repeat;
  background-color: #282c34;
  margin-bottom: -7px;
  border-radius: 5px;
  background-position: 10px 10px;
}
.cm-s-inner.CodeMirror {
  padding-top: .5rem;
  padding-bottom: .5rem;
  background-color: #292d3e;
  color: #a6accd;
  font-family: Consolas;
  border-radius: 4px;
}
.CodeMirror-lines {
  padding-left: 4px;
}
.cm-s-inner .cm-keyword {
  color: #c792ea;
}
.cm-s-inner .cm-operator {
  color: #89ddff;
}
.cm-s-inner .cm-variable-2 {
  color: #eeffff;
}
.cm-s-inner .cm-variable-3,
.cm-s-inner .cm-type {
  color: #f07178;
}
.cm-s-inner .cm-builtin {
  color: #ffcb6b;
}
.cm-s-inner .cm-atom {
  color: #f78c6c;
}
.cm-s-inner .cm-number {
  color: #ff5370;
}
.cm-s-inner .cm-def {
  color: #82aaff;
}
.cm-s-inner .cm-string {
  color: #c3e88d;
}
.cm-s-inner .cm-string-2 {
  color: #f07178;
}
.cm-s-inner .cm-comment {
  color: #676e95;
}
.cm-s-inner .cm-variable {
  color: #f07178;
}
.cm-s-inner .cm-tag {
  color: #ff5370;
}
.cm-s-inner .cm-meta {
  color: #ffcb6b;
}
.cm-s-inner .cm-attribute {
  color: #c792ea;
}
.cm-s-inner .cm-property {
  color: #c792ea;
}
.cm-s-inner .cm-qualifier {
  color: #decb6b;
}
.cm-s-inner .cm-variable-3,
.cm-s-inner .cm-type {
  color: #decb6b;
}
.cm-s-inner .cm-error {
  color: rgba(255, 255, 255, 1);
  background-color: #ff5370;
}
.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}
.CodeMirror div.CodeMirror-cursor {
  border-left: 1px solid rgb(239, 112, 96);
  z-index: 3;
}

</style>

<script>
(function(){window.onload = function(){
    console.log('DOM already loaded.');
    if(window.top == window.self){ 
        var aNode = document.createElement('a');
        aNode.href = 'javascript:;';
        aNode.id = 'click-to-top';
        aNode.title = 'Click it to go to the top';
        var availHeight = window.screen.availHeight; // 获取可用高度
        var css = '#click-to-top{ display:none; position: fixed; right: 5%; bottom: 20%; opacity: 0.2; z-index: 9999; } #click-to-top:hover{ position: fixed; right: 5%; bottom: 20%; opacity: 1; z-index: 9999; }';
        //滚出一屏以后才显示返回顶部按钮
        window.onscroll = function(){
            var curPos = (document.documentElement.scrollTop == 0) ? document.body.scrollTop : document.documentElement.scrollTop; //document.documentElement.scrollTop; //preparation for hack (document.documentElement.scrollTop == 0) ? document.body.scrollTop : document.documentElement.scrollTop; 
            if(curPos > availHeight){
                aNode.style.display = 'block';
            }else {
                aNode.style.display = 'none';
            }
        };
        //图片相关
        var img = document.createElement('img');
        img.src = 'https://ooo.0o0.ooo/2017/05/23/59245c636b321.png';
        img.style = 'width: 30px; height: 30px;';
        //样式相关
        var style = document.createElement('style');
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }
        document.getElementsByTagName('head')[0].appendChild(style);
        aNode.append(img);
        aNode.addEventListener('click', function(){
            document.body.scrollIntoView();
            /*var timer = setInterval(function(){
            document.documentElement.scrollTop -= 500;
                if(document.documentElement.scrollTop < 100){
                    clearInterval(timer);
                }
            }, 50);
        }, true);*/
        });
        var eBody = document.querySelector('body');
        eBody.append(aNode);
    }
};})();
</script>

<script>
	!function(e, t, a) {
		function r() {
			for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
			requestAnimationFrame(r)
		}
		function n() {
			var t = "function" == typeof e.onclick && e.onclick;
			e.onclick = function(e) {
				t && t(),
					o(e)
			}
		}
		function o(e) {
			var a = t.createElement("div");
			a.className = "heart",
				s.push({
					el: a,
					x: e.clientX - 5,
					y: e.clientY - 5,
					scale: 1,
					alpha: 1,
					color: c()
				}),
				t.body.appendChild(a)
		}
		function i(e) {
			var a = t.createElement("style");
			a.type = "text/css";
			try {
				a.appendChild(t.createTextNode(e))
			} catch(t) {
				a.styleSheet.cssText = e
			}
			t.getElementsByTagName("head")[0].appendChild(a)
		}
		function c() {
			return "rgb(" + ~~ (255 * Math.random()) + "," + ~~ (255 * Math.random()) + "," + ~~ (255 * Math.random()) + ")"
		}
		var s = [];
		e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||
			function(e) {
				setTimeout(e, 1e3 / 60)
			},
			i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),
			n(),
			r()
	} (window, document);
</script>
</head>
<body>
<p><a href="https://resume.zhaoshengblog.cn/">返回上一页</a></p>
<h1 id="mysql-_-">MySQL数据分析实战笔记_（第一、二、三部分）</h1>
<h1 id="mysql-">MySQL数据分析课程笔记（应癫老师）</h1>
<p>数据分析师进行数据分析工作的前提条件：要有数据，往往从数据载体中获取，比如Excel但是对于Excel这种数据载体，无法存储海量数据，有它的极限</p>
<p>数据分析场景中经常接触另外的数据载体，数据库，它支持海量数据的存储（本身的数据组织形式+往往数据库软件支持分布式部署），并且提供高效的查询速度</p>
<p><strong>数据库：</strong>DataBase，简称DB，对于我们而言，所看到的数据库就是一个软件，它可以<strong>存储+管理</strong>数据，MySQL只是数据库中的一种，因为互联网领域MySQL应用非常广泛，数据分析领域经常涉及到MySQL</p>
<h1 id="-">主要内容介绍</h1>
<p>第一部分：MySQL基础</p>
<ul>
<li>数据库的基本概念（什么是数据库？为什么要用数据库等等）</li><li>MySQL介绍（发展历程以及其它）</li><li>MySQL的安装配置</li><li>SQL语言/语句操作MySQL完成数据的存储+管理操作（增删改<strong>查</strong>）</li></ul>
<p>第二部分：MySQL核心查询</p>
<ul>
<li>围绕MySQL查询进一步学习更多内容</li></ul>
<p>第三部分：MySQL高级应用</p>
<ul>
<li>窗口函数索引机制</li><li>MySQL视图</li></ul>
<p>第四部分：MySQL项目实战</p>
<ul>
<li>基于MySQL数据库（数据载体）结合企业项目实例进行数据分析行为</li></ul>
<hr>
<h1 id="-mysql-">第一部分 MySQL基础</h1>
<h2 id="-1-">第1节 数据库的基本概念</h2>
<h3 id="1-1-">1.1  什么是数据库</h3>
<p>数据库（DataBase） 是按照数据结构来组织、存储和管理数据的仓库数据库是一个数据的集合。<br>其本质是一个文件系统，以文件的方式,将数据保存在电脑上</p>
<p>数据库是数据的集合，本质还是文件，这种文件只不过是按照独有的方式进行数据组织的</p>
<p>我们不能直接操作这些文件啊！因为直接操作文件会更加麻烦，那使用数据库的意义就不大了，所以呢数据库厂商在数据库（文件）之上进行了封装，封装出了一个系统（软件），该软件可以给我们提供便捷的操作内部数据库（文件）的方式，这种软件叫做 DBMS MySQL就是一种DBMS，我们平常所说的xx数据库，其实就是 XXX DBMS</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425460387-ca2a813d-b291-4c15-9528-8eb9941a9d95.jpeg#height=227&amp;width=442" alt=""></p>
<hr>
<h3 id="1-2-">1.2  为什么要使用数据库</h3>
<p>数据存储方式的比较</p>
<ul>
<li><p>内存</p>
<ul>
<li>优点：速度快</li><li>缺点：容量有限，不能够永久保存,数据是临时状态的</li></ul>
</li><li><p>文件（Excel）</p>
<ul>
<li>优点：数据是可以永久保存的</li><li>缺点：少量数据直接打开获取数据，大量数据使用程序IO流操作文件, 不方便；同一时间多人操作某一个文件也可能出现问题</li></ul>
</li><li><p>数据库</p>
<ul>
<li>优点<ul>
<li>海量数据存储，提供不错的查询效率</li><li>数据可以永久保存</li><li>方便存储和管理数据</li><li>使用统一的方式操作数据库</li></ul>
</li><li>缺点<ul>
<li>占用资源(重型武器)</li><li>有些数据库需要付费</li></ul>
</li></ul>
</li></ul>
<hr>
<h3 id="1-3-">1.3  数据库与数据库管理系统</h3>
<ul>
<li>数据库（DB）：指的是按照一定结构组织的数据集合，由存储数据的文件组成。</li><li>数据库管理系统（DBMS）：是一款管理软件。</li><li>它用于对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过 DBMS访问数据库中的数据，数据库管理员也通过 DBMS 进行数据库的维护工作。DBMS 允许多个应用程序或多个用户使用不同的方法，在同一时刻或不同时刻去建立、修改和询问数据库。<ul>
<li>公司的 Oracle 和 MySQL</li><li>公司的 DB2</li><li>公司的 Access 和 SQL Server</li></ul>
</li></ul>
<h4 id="-dbms-">注意：我们通常所说的数据库其实是DBMS，后面不再强调</h4>
<hr>
<h3 id="-1-4-"><strong>1.4  数据库分类</strong></h3>
<ul>
<li>关系型数据库（RDB: Relationship DataBase）</li><li>关系型数据库可以使用SQL语言/SQL语句来操作</li><li>关系型数据库是创建在关系模型基础上的数据库</li><li>关系模型？？？<ul>
<li>典型代表有：<strong>MySQL、Oracle</strong>、Microsoft SQL Server、Access、PostgreSQL、DB2等。</li></ul>
</li></ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/377461/1598425462859-934c3936-d437-4ed7-8dba-ebb6e37cabb1.png" alt=""></p>
<ul>
<li>非关系型数据库（NoSQL）</li><li>常规情况我们是不能使用SQL进行操作的，它不是关系模型</li><li>非关系型数据库也被称为 NoSQL 数据库，NoSQL 并不是某个具体数据库，它泛指所有非关系型数据库。</li><li>典型代表有：Hbase、MongoDB、Redis（k/v）、CouchDB等</li></ul>
<hr>
<h3 id="1-5-">1.5  数据库排行</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425463079-dec62847-6983-45aa-a8f9-29e391a76c7f.jpeg" alt=""></p>
<p>MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。</p>
<h4 id="oracle-mysql-">Oracle和MySQL是世界市场占比最高的两种数据库</h4>
<ul>
<li>Oracle：有钱的大企业采用，互联网企业之外使用第一。 </li><li>MySQL：互联网高速发展，互联网企业使用第一。<ul>
<li>IOE:  IBM 小型机 ，Oracle数据库，EMC易安信存储，去IOE</li></ul>
</li></ul>
<hr>
<h3 id="1-6-">1.6  关系型数据库主要对象</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425463266-9532ec60-38b7-4993-b54d-35ce33d4caf8.jpeg" alt=""></p>
<ul>
<li>对象示例：以Excel为例对比，sheet就是Excel中的对象</li><li>关系型数据库的使用架构（MySQL为例）</li><li><p>使用SQL操作数据库，其实就是操作数据库中的对象，从无到有的流程该怎样？此处我们可以对比Excel</p>
<ul>
<li>Excel：创建一个<strong>Excel 文档 </strong>→创建一个<strong>sheet</strong>→在sheet中进行数据操作</li><li>MySQL数据库：创建一个<strong>数据库 </strong>→创建一个数据<strong>表</strong>→在表中记录数据</li></ul>
</li></ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425463727-6ab72fe1-ede4-4362-9caf-3418eac2d3e5.jpeg" alt=""></p>
<h4 id="-">表</h4>
<p>表是包含数据库中所有数据的数据库对象，由行和列组成（二维表格模型，就类似于Sheet），用于组织和存储数据。</p>
<h4 id="-">字段</h4>
<p>表中<strong>每一列称为一个字段</strong>，字段有自己的属性，如字段类型、字段大小等。其中，字段类型是字段最重要的属性，它决定了字段能够存储哪种数据。</p>
<p>和Excel不同，这里针对列（字段要求比较严格），该列存储什么类型数据，长度多少都应该提前（建表的时候）进行定义</p>
<h4 id="-">索引</h4>
<p>索引是一个<strong>单独的、物理的数据库结构</strong>。它是依赖于表建立，在数据库中使用索引，无须对整个表进行扫描，就可以找到需要的数据。</p>
<h4 id="-">视图</h4>
<p>视图是从一张或多张表中导出的表（也称虚拟表），是用户查看数据表中数据的一种方式。</p>
<hr>
<h2 id="-2-mysql-">第2节 MySQL数据库</h2>
<h3 id="2-1-mysql-">2.1  MySQL起源与发展</h3>
<p>MySQL是一个关系型数据库管理系统（RDBMS），由瑞典MySQLAB公司开发，属于Oracle 旗下产品，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。所使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。</p>
<h4 id="mysql-">Mysql特性</h4>
<ol>
<li><p>MySQL使用C和C++编写，并使用了多种编译器进行测试，保证了源代码的可移植性。</p>
</li><li><p>支持 AIX、HP-UX、Linux、Mac OS、OpenBSD、Solaris、Windows等多种操作系统。</p>
</li><li><p>为多种编程语言提供了 API,包括 C、C++、Python、Java、Perl、PHP、Ruby,.NET等。</p>
</li><li><p>支持多线程，充分利用CPU资源。</p>
</li><li><p>优化的SQL查询算法，有效地提高查询速度。</p>
</li><li><p>既可作为单独的应用程序应用在客户端服务器网络环境中，也可作为一个库而嵌入到其他软件中。</p>
</li><li><p>提供TCP/IP、ODBC和JDBC等多种数据库连接途径。</p>
</li><li><p>提供用于管理、检查、优化数据库操作的管理工具。</p>
</li><li><p>支持大型的数据库，可以处理拥有上千万条记录的大型数据库。</p>
</li><li><p>支持多种存储引擎（类似于发动机）。</p>
</li><li><p>MySQL是开源的，所以你不需要支付额外的费用。</p>
</li><li><p>MySQL使用标准的SQL数据语言形式。</p>
</li><li><p>MySQL对PHP有很好的支持，PHP是比较流行的Web开发语言。<br>…..</p>
</li></ol>
<p><strong>MySQL发展历程如下：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425464434-6b731e9a-ecb4-49e8-8ceb-ccf79af39bdb.jpeg" alt=""></p>
<p><strong>MySQL主流分支如下图所示</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/377461/1598425464710-dd0ddbc5-d5e6-4d00-b22a-751c3ab6de75.png#height=212&amp;width=435" alt=""></p>
<hr>
<h3 id="2-2-mysql-">2.2  Mysql存储引擎</h3>
<p>存储引擎是MySQL数据库的核心、心脏、发动机，它决定了数据如何存储，查询的时候如何搜索数据，索引如何创建等等</p>
<p>MySQL 5.1版本之前默认的存储引擎是MyISAM，之后默认是InnoDB</p>
<h4 id="-">什么是存储引擎</h4>
<p>存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。</p>
<h4 id="-">常用存储引擎</h4>
<ul>
<li><p>InnoDB：</p>
<ul>
<li><strong>1.  事务处理</strong>、<strong>回滚</strong>、<strong>崩溃修复能力</strong>和<strong>多版本并发控制</strong></li><li><strong>2.  自增长AUTO_INCREMENT</strong></li><li><strong>3.  外键（FOREIGN  KEY）</strong><br>InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</li></ul>
</li><li><p>MyISAM：</p>
</li><li><p>MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</p>
</li><li><p>Memory：</p>
<ul>
<li><strong>1.  数据全部放在内存中</strong></li><li><p><strong>2.  哈希索引</strong></p>
<p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p>
</li></ul>
</li></ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425464880-56c5c168-d18e-4976-b948-d26bbe5e0cb9.jpeg#height=158&amp;width=443" alt=""></p>
<hr>
<h3 id="2-3-mysql-">2.3  Mysql数据类型</h3>
<p>MySQL数据库中的每一条数据都有其数据类型，主要分为<strong>数值型</strong>，<strong>字符串型</strong>和<strong>日期时间型</strong>三个大类。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425465069-e6803bcb-f571-437c-9ab8-0e56fc6465a3.jpeg" alt=""></p>
<h4 id="-">数值类型</h4>
<p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 字节</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">(-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">“单精度浮点数值”</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">(1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">“双精度浮点数值”</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<pre><code>&lt;table&gt;
        &lt;tr&gt;
            &lt;th style=&quot;width:10%;&quot;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/th&gt;
            &lt;th style=&quot;width:15%;&quot;&gt;&lt;strong&gt;大小&lt;/strong&gt;&lt;/th&gt;
            &lt;th style=&quot;width:30%;&quot;&gt;&lt;strong&gt;范围（有符号）&lt;/strong&gt;&lt;/th&gt;
            &lt;th style=&quot;width:30%;&quot;&gt;&lt;strong&gt;范围（无符号）&lt;/strong&gt;&lt;/th&gt;
            &lt;th style=&quot;width:15%;&quot;&gt;&lt;strong&gt;用途&lt;/strong&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TINYINT&lt;/td&gt;
            &lt;td&gt;1 字节&lt;/td&gt;
            &lt;td&gt;(-128，127)&lt;/td&gt;
            &lt;td&gt;(0，255)&lt;/td&gt;
            &lt;td&gt;小整数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;SMALLINT&lt;/td&gt;
            &lt;td&gt;2 字节&lt;/td&gt;
            &lt;td&gt;(-32 768，32 767)&lt;/td&gt;
            &lt;td&gt;(0，65 535)&lt;/td&gt;
            &lt;td&gt;大整数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;MEDIUMINT&lt;/td&gt;
            &lt;td&gt;3 字节&lt;/td&gt;
            &lt;td&gt;(-8 388 608，8 388 607)&lt;/td&gt;
            &lt;td&gt;(0，16 777 215)&lt;/td&gt;
            &lt;td&gt;大整数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;INT或INTEGER&lt;/td&gt;
            &lt;td&gt;4 字节&lt;/td&gt;
            &lt;td&gt;(-2 147 483 648，2 147 483 647)&lt;/td&gt;
            &lt;td&gt;(0，4 294 967 295)&lt;/td&gt;
            &lt;td&gt;大整数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;BIGINT&lt;/td&gt;
            &lt;td&gt;8 字节&lt;/td&gt;
            &lt;td&gt;(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)&lt;/td&gt;
            &lt;td&gt;(0，18 446 744 073 709 551 615)&lt;/td&gt;
            &lt;td&gt;极大整数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;FLOAT&lt;/td&gt;
            &lt;td&gt;4 字节&lt;/td&gt;
            &lt;td&gt;(-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)&lt;/td&gt;
            &lt;td&gt;0，(1.175 494 351 E-38，3.402 823 466 E+38)&lt;/td&gt;
            &lt;td&gt;单精度&lt;br&gt;
            浮点数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DOUBLE&lt;/td&gt;
            &lt;td&gt;8 字节&lt;/td&gt;
            &lt;td&gt;(1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
            &lt;td&gt;0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
            &lt;td&gt;双精度&lt;br&gt;
            浮点数值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DECIMAL&lt;/td&gt;
            &lt;td&gt;对DECIMAL(M,D) ，如果M&amp;gt;D，为M+2否则为D+2&lt;/td&gt;
            &lt;td&gt;依赖于M和D的值&lt;/td&gt;
            &lt;td&gt;依赖于M和D的值&lt;/td&gt;
            &lt;td&gt;小数值&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><ul>
<li><p><strong>TINYINT</strong></p>
<p>  一个非常小的整数，可以带符号。如果是有符号，它允许的范围是从-128到127。如果是无符号，允许的范围是从0到255。</p>
</li><li><p><strong>INT</strong></p>
<p>  正常大小的整数，可以带符号。如果是有符号的，它允许的范围是从-2147483648到2147483647。如果是无符号，允许的范围是从0到4294967295。</p>
</li><li><p><strong>BIGINT</strong><br>  一个大的整数，可以带符号。如果有符号，允许范围为-9223372036854775808到9223372036854775807。如果无符号，允许的范围是从0到18446744073709551615。</p>
</li><li><p><strong>FLOAT(M,D)</strong><br>  不能使用无符号的浮点数字。可以定义显示长度(M)和小数位数(D)。这不是必需的，并且默认为10,2。其中2是小数的位数，10是数字(包括小数)的总数。ﬂoat(5,2)  999.919</p>
</li><li><p><strong>DOUBLE(M,D)</strong><br>   不能使用无符号的双精度浮点数。可以定义显示长度(M)和小数位数(D)。 这不是必需的，默认为16,4，其中4是小数的位数。</p>
</li></ul>
<h4 id="-">字符串类型</h4>
<p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。</p>
<p>有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0-65535 字节</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0-65 535字节</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0-65 535字节</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215字节</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215字节</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LOGNGBLOB</td>
<td style="text-align:left">0-4 294 967 295字节</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295字节</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<pre><code>&lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;类型&lt;/th&gt;
            &lt;th&gt;大小&lt;/th&gt;
            &lt;th&gt;用途&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;CHAR&lt;/td&gt;
            &lt;td&gt;0-255字节&lt;/td&gt;
            &lt;td&gt;定长字符串&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;VARCHAR&lt;/td&gt;
            &lt;td&gt;0-65535 字节&lt;/td&gt;
            &lt;td&gt;变长字符串&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TINYBLOB&lt;/td&gt;
            &lt;td&gt;0-255字节&lt;/td&gt;
            &lt;td&gt;不超过 255 个字符的二进制字符串&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TINYTEXT&lt;/td&gt;
            &lt;td&gt;0-255字节&lt;/td&gt;
            &lt;td&gt;短文本字符串&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;BLOB&lt;/td&gt;
            &lt;td&gt;0-65 535字节&lt;/td&gt;
            &lt;td&gt;二进制形式的长文本数据&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TEXT&lt;/td&gt;
            &lt;td&gt;0-65 535字节&lt;/td&gt;
            &lt;td&gt;长文本数据&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;MEDIUMBLOB&lt;/td&gt;
            &lt;td&gt;0-16 777 215字节&lt;/td&gt;
            &lt;td&gt;二进制形式的中等长度文本数据&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;MEDIUMTEXT&lt;/td&gt;
            &lt;td&gt;0-16 777 215字节&lt;/td&gt;
            &lt;td&gt;中等长度文本数据&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LOGNGBLOB&lt;/td&gt;
            &lt;td&gt;0-4 294 967 295字节&lt;/td&gt;
            &lt;td&gt;二进制形式的极大文本数据&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LONGTEXT&lt;/td&gt;
            &lt;td&gt;0-4 294 967 295字节&lt;/td&gt;
            &lt;td&gt;极大文本数据&lt;/td&gt;
        &lt;/tr&gt;
&lt;/table&gt;
</code></pre><ul>
<li><p>短文本：char varchar</p>
<ul>
<li><p><strong>CHAR(M)</strong><br>固定长度的字符串是以长度为1到255之间个字符长度(例如：CHAR(5))，存储右空格填充到指定的长度。 限定长度不是必需的，它会默认为1。  char(5)   abcde  ab   内存空间会浪费，性别：男/女  char(1)</p>
</li><li><p><strong>VARCHAR(M)</strong><br>可变长度的字符串是以长度为1到255之间字符数(高版本的MySQL超过255); 例如： VARCHAR(25). 创建VARCHAR类型字段时，必须定义长度。  5  10 12 节省内存空间 abcde</p>
</li><li><p><strong>BLOB 或 TEXT</strong><br>字段的最大长度是65535个字符。 BLOB是“二进制大对象”，并用来存储大的二进制数据，如图像或其他类型的文件。定义为TEXT文本字段还持有大量的数据; 两者之间的区别是，排序和比较上存储的数据，BLOB大小写敏感，而TEXT字段不区分大小写。不用指定BLOB或TEXT的长度。</p>
</li></ul>
</li></ul>
<h4 id="-">日期和时间类型</h4>
<p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小(字节)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>-838:59:59&#39;/&#39;838:59:59</code></td>
<td style="text-align:left"><code>HH:MM:SS</code></td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left"><code>1000-01-01 00:00:00/9999-12-31 23:59:59</code></td>
<td style="text-align:left"><code>YYYY-MM-DD HH:MM:SS</code></td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">8</td>
<td style="text-align:left"><code>1970-01-01 00:00:00/2037 年某时</code></td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<pre><code>&lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;类型&lt;/th&gt;
            &lt;th&gt;大小&lt;br&gt;
            (字节)&lt;/th&gt;
            &lt;th&gt;范围&lt;/th&gt;
            &lt;th&gt;格式&lt;/th&gt;
            &lt;th&gt;用途&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DATE&lt;/td&gt;
            &lt;td&gt;3&lt;/td&gt;
            &lt;td&gt;1000-01-01/9999-12-31&lt;/td&gt;
            &lt;td&gt;YYYY-MM-DD&lt;/td&gt;
            &lt;td&gt;日期值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TIME&lt;/td&gt;
            &lt;td&gt;3&lt;/td&gt;
            &lt;td&gt;&#39;-838:59:59&#39;/&#39;838:59:59&#39;&lt;/td&gt;
            &lt;td&gt;HH:MM:SS&lt;/td&gt;
            &lt;td&gt;时间值或持续时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;YEAR&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1901/2155&lt;/td&gt;
            &lt;td&gt;YYYY&lt;/td&gt;
            &lt;td&gt;年份值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DATETIME&lt;/td&gt;
            &lt;td&gt;8&lt;/td&gt;
            &lt;td&gt;1000-01-01 00:00:00/9999-12-31 23:59:59&lt;/td&gt;
            &lt;td&gt;YYYY-MM-DD HH:MM:SS&lt;/td&gt;
            &lt;td&gt;混合日期和时间值&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TIMESTAMP&lt;/td&gt;
            &lt;td&gt;8&lt;/td&gt;
            &lt;td&gt;1970-01-01 00:00:00/2037 年某时&lt;/td&gt;
            &lt;td&gt;YYYYMMDD HHMMSS&lt;/td&gt;
            &lt;td&gt;混合日期和时间值，时间戳&lt;/td&gt;
        &lt;/tr&gt;
&lt;/table&gt;
</code></pre><ul>
<li><p><strong>DATE</strong><br>以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间。 例如，1973年12月30日将被存储为1973-12-30。</p>
</li><li><p><strong>DATETIME</strong><br>日期和时间组合以<code>YYYY-MM-DD HH:MM:SS</code>格式，在<code>1000-01-01 00:00:00</code> 到<code>9999-12-31 23:59:59</code>之间。例如，1973年12月30日下午3:30，会被存储为<code>1973-12-30 15:30:00</code>。</p>
</li><li><p><strong>TIMESTAMP</strong><br>1970年1月1日午夜之间的时间戳，到2037的某个时候。这看起来像前面的DATETIME格式，无需只是数字之间的连字符; 1973年12月30日下午3点30分将被存储为19731230153000(YYYYMMDDHHMMSS)。</p>
</li><li><p><strong>TIME</strong><br>存储时间在<code>HH:MM:SS</code>格式。</p>
</li><li><p><strong>YEAR(M) </strong><br>以2位或4位数字格式来存储年份。如果长度指定为2(例如YEAR(2))，年份就可以为1970至2069(70〜69)。如果长度指定为4，年份范围是1901-2155，默认长度为4。</p>
</li></ul>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>MYSQL的数据类型</strong></th>
<th style="text-align:left">/</th>
<th style="text-align:left">/</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>字段类型</strong></td>
<td style="text-align:left"><strong>中文说明</strong></td>
<td style="text-align:left"><strong>字段说明</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>字符串数据类型</strong></td>
<td style="text-align:left">/</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">char (n)</td>
<td style="text-align:left">固定长度</td>
<td style="text-align:left">最多255个字符</td>
</tr>
<tr>
<td style="text-align:left">varchar(n)</td>
<td style="text-align:left">可变长度</td>
<td style="text-align:left">最多65535个字符</td>
</tr>
<tr>
<td style="text-align:left">tinytext</td>
<td style="text-align:left">可变长度</td>
<td style="text-align:left">最多255个字符</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">可变长度</td>
<td style="text-align:left">最多65535个字符</td>
</tr>
<tr>
<td style="text-align:left">mediumtext</td>
<td style="text-align:left">可变长度</td>
<td style="text-align:left">最多2的24次方-1个字符</td>
</tr>
<tr>
<td style="text-align:left">longtext</td>
<td style="text-align:left">可变长度</td>
<td style="text-align:left">最多2的32次方-1个字符</td>
</tr>
<tr>
<td style="text-align:left"><strong>日期类型</strong></td>
<td style="text-align:left">/</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">3字节，日期</td>
<td style="text-align:left">格式：2014-09-18</td>
</tr>
<tr>
<td style="text-align:left">time</td>
<td style="text-align:left">3字节，时间</td>
<td style="text-align:left">格式：<code>08:42:30</code></td>
</tr>
<tr>
<td style="text-align:left">datetime</td>
<td style="text-align:left">8字节，日期时间</td>
<td style="text-align:left">格式：<code>2014-09-18 08:42:30</code></td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">4字节，自动存储记录修改的时间</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">year</td>
<td style="text-align:left">1字节，年份</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left"><strong>整型类型</strong></td>
<td style="text-align:left">/</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">tinyint</td>
<td style="text-align:left">1字节</td>
<td style="text-align:left">范围(-128~127)</td>
</tr>
<tr>
<td style="text-align:left">smallint</td>
<td style="text-align:left">2字节</td>
<td style="text-align:left">范围(-32768~32767)</td>
</tr>
<tr>
<td style="text-align:left">mediuinint</td>
<td style="text-align:left">3字节</td>
<td style="text-align:left">范围(-8388608~8388607)</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">4字节</td>
<td style="text-align:left">范围(-2147483648~2147483647)</td>
</tr>
<tr>
<td style="text-align:left">bigint</td>
<td style="text-align:left">8字节</td>
<td style="text-align:left">范围（+-9.22*10的18次方）</td>
</tr>
<tr>
<td style="text-align:left"><strong>浮点型</strong></td>
<td style="text-align:left">/</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">float(m, d)</td>
<td style="text-align:left">4字节,单精度浮点型</td>
<td style="text-align:left">m总个数，d小数位</td>
</tr>
<tr>
<td style="text-align:left">double(m, d)</td>
<td style="text-align:left">8字节，双精度浮点型</td>
<td style="text-align:left">m总个数，d小数位</td>
</tr>
<tr>
<td style="text-align:left">decimal (m, d)</td>
<td style="text-align:left">decimal是存储为字符串的浮点数</td>
<td style="text-align:left">(空格)</td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425465528-7fca3b6b-6c5e-4228-8488-9f3d51c846cb.jpeg#height=407&amp;width=443" alt=""></p>
<hr>
<h2 id="-3-mysql-">第3节  MySQL安装及配置</h2>
<h3 id="3-1-mysql">3.1  安装MySQL</h3>
<p>详见 MySQL安装文档</p>
<h3 id="3-2-mysql-">3.2  MySQL的启动与关闭</h3>
<h4 id="3-2-1-windows-mysql">3.2.1  以Windows服务启动MySQL</h4>
<p>1)    右键此电脑 —&gt; 管理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425465964-187f16dc-07ee-4d96-9a73-89d994db5faf.jpeg#height=178&amp;width=445" alt=""></p>
<p>2)    选择服务—&gt; 找到MySQL服务</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425466210-40e29cb3-f02e-4dee-b889-d5fa24516335.jpeg" alt=""></p>
<p>3)  右键选择 —&gt; 启动或停止</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425466367-25d1f825-1043-41b5-a1c7-f322ba0930ad.jpeg#height=355&amp;width=393" alt=""></p>
<h3 id="3-3-">3.3  命令行登录数据库</h3>
<p>MySQL是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的root账号，使用安装时设置的密码即可登录。<br>dos命令行进入MySQL安装目录下的bin目录，执行如下命令</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>命令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mysql -u 用户名 -p 密码</td>
<td style="text-align:left">使用指定用户名和密码登录当前计算机中的MySQL数据库</td>
</tr>
<tr>
<td style="text-align:left">mysql -h 主机IP -u 用户名 -p 密码</td>
<td style="text-align:left">-h 指定IP 方式,进行 登录</td>
</tr>
</tbody>
</table>
<p>命令演示:</p>
<pre><code>mysql -uroot -p123456
</code></pre><pre><code>mysql -h127.0.0.1 -uroot -p123456
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/377461/1598425466523-f9771ebd-3741-4a65-9e19-78a511302eb9.png#height=216&amp;width=442" alt=""></p>
<p>退出命令</p>
<pre><code>exit 或者 quit
</code></pre><h3 id="3-4-">3.4  远程查询工具</h3>
<p>SqlYog的使用<br>1)  简介<br>SQLyog是业界著名的Webyog公司出品的一款简洁高效、功能强大的图形化MySQL数据库管理工具。使用 SQLyog 可以快速直观地让您从世界的任何角落通过网络来维护远端的 MySQL 数据库。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425466699-8f9e4c38-a657-437b-a8fc-7de501966929.jpeg" alt=""></p>
<p>2)  具体安装教程 请查看 SQLyog安装教程<br>Navicat的使用</p>
<p>1) 简介<br><strong>”Navicat“</strong>是一套可创建多个连接的数据库管理工具，用以方便管理 MySQL、Oracle、PostgreSQL、SQLite、SQL Server、MariaDB 和/或 MongoDB 等不同类型的数据库，并支持管理某些云数据库，例如阿里云、腾讯云。Navicat 的功能足以符合专业开发人员的所有需求，但是对数据库服务器初学者来说又相当容易学习。Navicat 的用户界面 (GUI) 设计良好，让你以安全且简单的方法创建、组织、访问和共享信息。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425466838-30cadf68-819d-40ff-9875-362999907475.jpeg#height=136&amp;width=136" alt=""></p>
<hr>
<h2 id="-4-sql-">第4节 SQL语句操作详解</h2>
<p>Server端<br>Client端：Navicat<br>接下来，我们就要使用Client端去操作MySQL数据库（数据的存储+管理），说白了就是数据的增删改查（CRUD）<br>C: create 增加<br>R: Retrieve 获取/查询<br>U: update更新<br>D: delete删除<br>我们需要使用Client端写/发送<strong>SQL语句</strong>到Server端<br>SQL语句按照功能，往往分成这么几类：</p>
<p>新建Excel-sheet-填入数据</p>
<p><strong>新建数据库（DataBase）→新建表（Table） →插入数据/更新数据/删除数据</strong></p>
<p>下面的几类SQL语句就是在帮助我们完成上面的流程</p>
<ul>
<li><p>DDL语句（Data Deﬁnition Language 数据定义语言）</p>
<ul>
<li>创建数据库</li><li>创建表</li><li>修改表结构等<br>结构性操作，创建或修改数据库/表结构，不涉及具体存储的数据还</li></ul>
</li><li><p>DML语句（Data Manipulation Language 数据操纵语言）<br>  针对table数据表中数据的增删改，使用DML</p>
</li><li><p>DQL语句（Data Query Language 数据查询语言）<br>  针对table数据表中数据的查询操作，使用DQL</p>
</li><li><p>DCL语句（Data Control Language 数据控制语言）<br>  了解事务的提交/回滚等</p>
</li></ul>
<h3 id="-4-1-sql-"><strong>4.1 SQL通用语法</strong></h3>
<ul>
<li><p>SQL语句可以单行 或者 多行书写，以分号结尾 ; （Sqlyog中可以不用写分号）</p>
</li><li><p>可以使用空格和缩进来增加语句的可读性。</p>
</li><li><p>MySql中使用SQL不区分大小写，一般关键字大写，数据库名 表名列名 小写。</p>
</li></ul>
<h3 id="4-2-">4.2. 注释方式</h3>
<table>
<thead>
<tr>
<th><strong>注释语法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>— 空格</td>
<td>单行注释</td>
</tr>
<tr>
<td><code>/* */</code></td>
<td>多行注释</td>
</tr>
<tr>
<td>#</td>
<td>单行注释</td>
</tr>
</tbody>
</table>
<pre><code># show databases;  单行注释
-- show databases; 单行注释
/*
多行注释
show databases;
*/
</code></pre><h3 id="4-3-ddl-">4.3 <strong>DDL操作数据库</strong></h3>
<h4 id="4-3-1-">4.3.1   创建数据库</h4>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>create database 数据库名；</td>
<td>创建指定名称的数据库。</td>
</tr>
<tr>
<td>create database 数据库名 character set 字符集；</td>
<td>创建指定名称的数据库，并且指定字符集（一般都指定utf8）</td>
</tr>
</tbody>
</table>
<p>代码示例</p>
<pre><code>/*
方式1 直接指定数据库名进行创建
*/
CREATE DATABASE db1;

/*
方式2 指定数据库名称， 指定数据库的字符集一般都指定为 utf8
*/
CREATE DATABASE db1_1 CHARACTER SET utf8;
</code></pre><h4 id="4-3-2-">4.3.2   查看/选择数据库</h4>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>use 数据库</td>
<td>切换数据库</td>
</tr>
<tr>
<td>select database();</td>
<td>查看当前正在使用的数据库</td>
</tr>
<tr>
<td>show databases;</td>
<td>查看Mysql中 都有哪些数据库</td>
</tr>
<tr>
<td>show create database 数据库名；</td>
<td>查看一个数据库的定义信息</td>
</tr>
</tbody>
</table>
<p>代码示例</p>
<pre><code>-- 切换数据库 从db1 切换到 db1_1 
USE db1_1;

-- 查看当前正在使用的数据库
SELECT DATABASE();

-- 查看Mysql中有哪些数据库
SHOW DATABASES;

-- 查看一个数据库的定义信息
SHOW CREATE DATABASE db1_1;
</code></pre><h4 id="4-3-3-">4.3.3   修改数据库</h4>
<p>修改数据库字符集</p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>alter database 数据库名 character set 字符集；</td>
<td>数据库的字符集修改操作</td>
</tr>
</tbody>
</table>
<pre><code>-- 将数据库db1 的字符集 修改为 utf8 
ALTER DATABASE db1 CHARACTER SET utf8;

-- 查看当前数据库的基本信息， 发现编码已更改
SHOW CREATE DATABASE db1;
</code></pre><h4 id="4-3-4-">4.3.4   删除数据库</h4>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>drop database 数据库名</td>
<td>从MySql中永久的删除某个数据库</td>
</tr>
</tbody>
</table>
<p>代码示例</p>
<pre><code>-- 删除某个数据库
DROP DATABASE db1_1;
</code></pre><h3 id="4-4-ddl-">4.4  DDL 操作数据表</h3>
<p>一个数据库中可以n个表，表中又有字段（列），在建表的时候就需要定义好字段（指定字段属性——&gt;字段数据类型+字段长度等）</p>
<h4 id="-">常用的数据类型：</h4>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>整型</td>
</tr>
<tr>
<td>double</td>
<td>浮点型</td>
</tr>
<tr>
<td>varchar</td>
<td>字符串型</td>
</tr>
<tr>
<td>date</td>
<td>日期类型，给是为 yyyy-MM-dd ,只有年月日，没有时分秒</td>
</tr>
</tbody>
</table>
<p>注意：MySql中的 char类型与 varchar类型，区别在于：</p>
<ul>
<li>char类型是固定长度的： 根据定义的字符串长度分配足够的空间。</li><li>varchar类型是可变长度的： 只使用字符串长度所需的空间<br>  比如：保存字符串 “abc”</li></ul>
<pre><code>x  char(10) 占用10个字节
y  varchar(10) 占用3个字节
</code></pre><p>适用场景：</p>
<ul>
<li>char类型适合存储 固定长度的字符串，比如 密码 ，性别一类</li><li>varchar类型适合存储 在一定范围内，有长度变化的字符串</li></ul>
<table>
<thead>
<tr>
<th style="text-align:left">/</th>
<th style="text-align:left">存储空间</th>
<th style="text-align:left">查询效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">耗费空间</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">varchar</td>
<td style="text-align:left">节省空间</td>
<td style="text-align:left">不高</td>
</tr>
</tbody>
</table>
<h4 id="4-4-1-">4.4.1   创建表</h4>
<p>语法格式：</p>
<pre><code>CREATE TABLE 表名(
    字段名称1 字段类型（ 长度），
    字段名称2 字段类型  注意 最后一列不要加逗号
)；
</code></pre><ul>
<li>需求1： 创建商品分类表</li></ul>
<pre><code>表名： category
表中字段：
    分类ID ： cid ,为整型
    分类名称： cname， 为字符串类型， 指定长度20
</code></pre><p>SQL实现</p>
<pre><code>-- 切换到数据库 db1 
USE db1;

-- 创建表
CREATE TABLE category( 
    cid INT,
    cname VARCHAR(20)
); 
```

+ 需求2： 创建测试表

```
表名： test1
表中字段：
    测试ID ： tid ,为整型
    测试时间： tdate , 为年月日的日期类型
</code></pre><p>SQL实现</p>
<pre><code>-- 创建测试表
    CREATE TABLE test1(
    tid INT, tdate DATE
);
</code></pre><ul>
<li>需求3： 快速创建一个表结构相同的表（复制表结构）</li></ul>
<p>语法格式:</p>
<pre><code>create table 新表名 like 旧表名;
</code></pre><p>代码示例</p>
<pre><code>| -- 创建一个表结构与 test1 相同的 test2表 
CREATE TABLE test2 LIKE test1;

-- 查看表结构
DESC test2;
</code></pre><h4 id="4-4-2-">4.4.2   查看表</h4>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>show tables;</td>
<td>查看当前数据库中的所有表名</td>
</tr>
<tr>
<td>desc 表名；</td>
<td>查看数据表的结构</td>
</tr>
</tbody>
</table>
<p>代码示例</p>
<pre><code>-- 查看当前数据库中的所有表名
SHOW TABLES;

-- 显示当前数据表的结构
DESC category;

-- 查看创建表的SQL语句
SHOW CREATE TABLE category;
</code></pre><h4 id="4-4-3-">4.4.3   删除表</h4>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>drop table 表名；</td>
<td>删除表（从数据库中永久删除某一张表）</td>
</tr>
<tr>
<td>drop table if exists 表名；</td>
<td>判断表是否存在， 存在的话就删除,不存在就不执行删除</td>
</tr>
</tbody>
</table>
<p>代码示例</p>
<pre><code>-- 直接删除 test1 表
DROP TABLE test1;

-- 先判断 再删除test2表
DROP TABLE IF EXISTS test2;
</code></pre><h4 id="4-4-4-">4.4.4   修改表</h4>
<p><strong>1.  修改表名</strong><br>语法格式</p>
<pre><code>rename table 旧表名 to 新表名;
</code></pre><p>需求： 将category表 改为 category1</p>
<pre><code>RENAME TABLE category TO category1;
</code></pre><p><strong>2.向表中添加列，关键字</strong> <code>ADD</code></p>
<p>语法格式：</p>
<pre><code>alter table 表名 add 字段名称 字段类型
</code></pre><p>需求： 为分类表添加一个新的字段为 分类描述 cdesc varchar(20)</p>
<pre><code># 为分类表添加一个新的字段为 分类描述 cdesc varchar(20) 
ALTER TABLE category ADD cdesc VARCHAR(20);
</code></pre><p><strong>3.修改表中列的数据类型或长度 ，关键字</strong> <code>MODIFY</code></p>
<p>语法格式：</p>
<pre><code>alter table 表名 modify 字段名称 字段类型
</code></pre><p>需求：对分类表的描述字段进行修改，类型varchar(50)</p>
<pre><code>ALTER TABLE category MODIFY cdesc VARCHAR(50);
</code></pre><p><strong>4.修改列名称 , 关键字</strong> <code>CHANGE</code></p>
<p>语法格式</p>
<pre><code>alter table 表名 change 旧列名 新列名 类型(长度);
</code></pre><p>需求:  对分类表中的 desc字段进行更换, 更换为 description varchar(30)</p>
<pre><code>ALTER TABLE category CHANGE cdesc description VARCHAR(30);
</code></pre><p><strong>5.删除列 ，关键字</strong> <code>DROP</code></p>
<p>语法格式</p>
<pre><code>alter table 表名 drop 列名;
</code></pre><p>需求： 删除分类表中description这列</p>
<pre><code>ALTER TABLE category DROP description;
</code></pre><h3 id="4-5-dml-">4.5  DML 操作表中数据</h3>
<p>SQL中的DML 用于对表中的数据进行增删改操作</p>
<h4 id="4-5-1-">4.5.1   插入数据</h4>
<p>语法格式：</p>
<pre><code>insert into 表名 （ 字段名1， 字段名2...） values(字段值1， 字段值2...);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425467136-461c1d85-338d-4cd6-b651-2c2781e050ab.jpeg" alt=""></p>
<p>1）代码准备，创建一个学生表：</p>
<pre><code>表名：student
表中字段：
    学院ID：sid int
    姓名：sname varchar(20)
    年龄：age int
    性别：sex char(1)
    地址：address varchar(40)

# 创建学生表
CREAT TABLE student(
    sid int,
    sname varchar(20)
    age int
    sex char(1)
    address varchar(40)
);
</code></pre><p>2）向 学生表中添加数据，3种方式</p>
<p>方式1： 插入全部字段， 将所有字段名都写出来</p>
<pre><code>INSERT INTO student (sid,sname,age,sex,address) VALUES(1,&#39;孙悟空&#39;,20,&#39;男&#39;,&#39;花果ft&#39;);
</code></pre><p>方式2： 插入全部字段，不写字段名</p>
<pre><code>INSERT INTO student VALUES(2,&#39;孙悟饭&#39;,10,&#39;男&#39;,&#39;地球&#39;);
</code></pre><p>方式3：插入指定字段的值</p>
<pre><code>INSERT INTO category (cname) VALUES(&#39;白骨精&#39;);
</code></pre><p>注意：<br>1)  值与字段必须要对应，个数相同&amp;数据类型相同<br>2）值的数据大小，必须在字段指定的长度范围内<br>3）varchar char date类型的值必须使用单引号包裹。<br>4）如果要插入空值，可以忽略不写，或者插入null<br>5)  如果插入指定字段的值，必须要上写列名</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425467567-9042d36f-4797-414e-b8a1-cafa4d17e426.jpeg#height=235&amp;width=443" alt=""></p>
<h4 id="4-5-2-">4.5.2   更改数据</h4>
<p>语法格式1：不带条件的修改</p>
<pre><code>update 表名 set 列名 = 值
</code></pre><p>语法格式2：带条件的修改</p>
<pre><code>update 表名 set 列名 = 值 [where 条件表达式： 字段名 = 值 ]
</code></pre><p>1）不带条件修改，将所有的性别改为女（慎用！！）</p>
<pre><code>UPDATE student SET sex = &#39;女&#39;;
</code></pre><p>2）带条件的修改，将sid 为3的学生，性别改为男</p>
<pre><code>UPDATE student SET sex = &#39;男&#39; WHERE sid = 3;
</code></pre><p>3）一次修改多个列， 将sid为 2 的学员，年龄改为 20，地址改为 北京</p>
<pre><code>UPDATE student SET age = 20,address = &#39;北京&#39; WHERE sid = 2;
</code></pre><h4 id="4-5-3-">4.5.3   删除数据</h4>
<p>语法格式1：删除所有数据</p>
<pre><code>delete from 表名
</code></pre><p>语法格式2： 指定条件 删除数据</p>
<pre><code>delete from 表名 [where 字段名 = 值]
</code></pre><p>1）删除 sid 为 1 的数据</p>
<pre><code>DELETE FROM student WHERE sid = 1;
</code></pre><p>2)  删除所有数据</p>
<pre><code>DELETE FROM student;
</code></pre><p>3)  如果要删除表中的所有数据,有两种做法</p>
<ol>
<li>delete from 表名;  不推荐. 有多少条记录 就执行多少次删除操作. 效率低</li><li>truncate table 表名: 推荐.  先删除整张表, 然后再重新创建一张一模一样的表. 效率高<br>当一个表中条数非常多，又要做删除动作的时候，如果用delete会很慢，那我们可以使用<br>truncate</li></ol>
<pre><code>truncate table student;
</code></pre><h3 id="4-6-dql-">4.6  DQL 查询表中数据</h3>
<h4 id="4-6-1-">4.6.1   准备数据</h4>
<pre><code>#创建员工表
表名 emp
表中字段：
    eid 员工id，int
    ename 姓名，varchar
    sex 性别，char
    salary 薪资，double
    hire_date 入职时间，date
    dept_name 部门名称，varchar

#创建员工表
CREATE TABLE emp(
    eid INT,
    ename VARCHAR(20),
    sex CHAR(1),
    salary DOUBLE,
    hire_date DATE,
    dept_name VARCHAR(20)
);

#添加数据
INSERT INTO emp VALUES(1,&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-04&#39;,&#39;教学部&#39;);
INSERT INTO emp VALUES(2,&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,&#39;教学部&#39;);
INSERT INTO emp VALUES(3,&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,&#39;教学部&#39;);
INSERT INTO emp VALUES(4,&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,&#39;市场部&#39;);
INSERT INTO emp VALUES(5,&#39;蜘蛛精&#39;,&#39;女&#39;,5000,&#39;2011-03-14&#39;,&#39;市场部&#39;);
INSERT INTO emp VALUES(6,&#39;玉兔精&#39;,&#39;女&#39;,200,&#39;2000-03-14&#39;,&#39;市场部&#39;);
INSERT INTO emp VALUES(7,&#39;林黛玉&#39;,&#39;女&#39;,10000,&#39;2019-10-07&#39;,&#39;财务部&#39;);
INSERT INTO emp VALUES(8,&#39;黄蓉&#39;,&#39;女&#39;,3500,&#39;2011-09-14&#39;,&#39;财务部&#39;);
INSERT INTO emp VALUES(9,&#39;吴承恩&#39;,&#39;男&#39;,20000,&#39;2000-03-14&#39;,NULL);
INSERT INTO emp VALUES(10,&#39;孙悟饭&#39;,&#39;男&#39;, 10,&#39;2020-03-14&#39;,财务部);
INSERT INTO emp VALUES(11,&#39;兔八哥&#39;,&#39;女&#39;, 300,&#39;2010-03-14&#39;,财务部);
</code></pre><h4 id="4-6-2-">4.6.2 简单查询</h4>
<p><strong>执行顺序</strong></p>
<p>FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425467756-84ed093c-115f-4147-8a5a-4cd914bc59bb.jpeg" alt=""></p>
<p>查询不会对数据库中的数据进行修改.只是一种显示数据的方式 SELECT</p>
<p><strong>语法格式</strong></p>
<pre><code>select 列名 from 表名
</code></pre><p>需求1： 查询emp中的 所有数据</p>
<pre><code>SELECT * FROM emp; -- 使用 * 表示所有列
</code></pre><p>需求2： 查询emp表中的所有记录，仅显示id和name字段</p>
<pre><code>SELECT eid,ename FROM emp;
</code></pre><p>需求3： 将所有的员工信息查询出来，并将列名改为中文</p>
<ul>
<li>别名查询，使用关键字 as</li></ul>
<pre><code># 使用 AS关键字,为列起别名
SELECT
    eid AS &#39;编号&#39;,
    ename AS &#39;姓名&#39; ,
    sex AS &#39;性别&#39;,
    salary AS &#39;薪资&#39;,
    hire_date &#39;入职时间&#39;, -- AS 可以省略
    dept_name &#39;部门名称&#39;
FROM emp;
</code></pre><p>需求4：查询一共有几个部门</p>
<ul>
<li>使用去重关键字 distinct</li></ul>
<pre><code>-- 使用distinct 关键字,去掉重复部门信息
SELECT DISTINCT dept_name FROM emp;
</code></pre><p>需求5: 将所有员工的工资 +1000 元进行显示</p>
<ul>
<li>运算查询 (查询结果参与运算)</li></ul>
<pre><code>SELECT ename , salary + 1000 FROM emp;
</code></pre><h4 id="4-6-3-">4.6.3   条件查询</h4>
<p><strong>如果查询语句中没有设置条件,就会查询所有的行信息,在实际应用中,一定要指定查询条件,对记录进行过滤</strong></p>
<p>语法格式</p>
<pre><code>select 列名 from 表名 where 条件表达式
先取出表中的每条数据,满足条件的数据就返回,不满足的就过滤掉 |
</code></pre><p><strong>运算符</strong></p>
<pre><code>where sname!=&#39;王五&#39; 
where sname&lt;&gt;&#39;王五&#39; 
where age&gt;18
where age&gt;=18 
where age&lt;30 
where age&lt;=30

where age between 18 and 30; 
where  sname in (&#39;王五&#39;,&#39;王六&#39;)
where sname like &#39;%王%&#39; -- sname中有王这个字 
where sname like &#39;王%&#39; -- sname中以王开头
</code></pre><ul>
<li><strong>比较运算符</strong></li></ul>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt; &lt; &lt;= &gt;= = &lt;&gt; !=</td>
<td>大于、小于、小于(大于)等于、等于、不等于</td>
</tr>
<tr>
<td>BETWEEN …AND…</td>
<td>显示在某一区间的值 例如: 2000-10000之间： Between 2000 and 10000</td>
</tr>
<tr>
<td>IN(集合)</td>
<td>集合表示多个值,使用逗号分隔,例如: name in (悟空，八戒) ,in中的每个数据都会作为一次条件,只要满足条件就会显示</td>
</tr>
<tr>
<td>LIKE ‘%张%’</td>
<td>模糊查询</td>
</tr>
<tr>
<td>IS NULL</td>
<td>查询某一列为NULL的值, 注: 不能写 = NULL</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>逻辑运算符</strong></li></ul>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>And &amp;&amp;</td>
<td>多个条件同时成立</td>
</tr>
<tr>
<td>Or</td>
<td>多个条件任一成立</td>
</tr>
<tr>
<td>Not</td>
<td>不成立，取反。</td>
</tr>
</tbody>
</table>
<p>需求1:</p>
<pre><code># 查询员工姓名为黄蓉的员工信息
# 查询薪水价格为5000的员工信息
# 查询薪水价格不是5000的所有员工信息
# 查询薪水价格大于6000元的所有员工信息
# 查询薪水价格在5000到10000之间所有员工信息
# 查询薪水价格是3600或7200或者20000的所有员工信息
</code></pre><p>代码实现</p>
<pre><code># 查询员工姓名为黄蓉的员工信息
SELECT * FROM emp WHERE ename = &#39;黄蓉&#39;;

# 查询薪水价格为5000的员工信息
SELECT * FROM emp WHERE salary = 5000;

# 查询薪水价格不是5000的所有员工信息
SELECT * FROM emp WHERE salary != 5000;
SELECT * FROM emp WHERE salary &lt;&gt; 5000;

# 查询薪水价格大于6000元的所有员工信息
SELECT * FROM emp WHERE salary &gt; 6000;

# 查询薪水价格在5000到10000之间所有员工信息
SELECT * FROM emp WHERE salary BETWEEN 5000 AND 10000;

# 查询薪水价格是3600或7200或者20000的所有员工信息
-- 方式1: or
SELECT * FROM emp WHERE salary = 3600 OR salary = 7200 OR salary = 20000;

-- 方式2: in() 匹配括号中指定的参数
SELECT * FROM emp WHERE salary IN(3600,7200,20000);
</code></pre><p>需求2:</p>
<pre><code># 查询含有&#39;精&#39;字的所有员工信息
# 查询以&#39;孙&#39;开头的所有员工信息
# 查询第二个字为&#39;兔&#39;的所有员工信息
# 查询没有部门的员工信息
# 查询有部门的员工信息
</code></pre><p><strong>模糊查询 通配符</strong></p>
<table>
<thead>
<tr>
<th><strong>通配符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>表示匹配任意多个字符串,</td>
</tr>
<tr>
<td>_</td>
<td>表示匹配 一个字符</td>
</tr>
</tbody>
</table>
<pre><code># 查询含有&#39;精&#39;字的所有员工信息
SELECT   FROM emp WHERE ename LIKE &#39;%精%&#39;;

# 查询以&#39;孙&#39;开头的所有员工信息
SELECT   FROM emp WHERE ename LIKE &#39;孙%&#39;;

# 查询第二个字为&#39;兔&#39;的所有员工信息
SELECT   FROM emp WHERE ename LIKE &#39;_兔%&#39;;

# 查询没有部门的员工信息
SELECT   FROM emp WHERE dept_name IS NULL;
-- SELECT * FROM emp WHERE dept_name = NULL;

# 查询有部门的员工信息
SELECT * FROM emp WHERE dept_name IS NOT NULL;
</code></pre><hr>
<h1 id="-mysql-">第二部分 MySQL核心查询</h1>
<p>排序 分组 聚合 多表查询 合并查询 子查询</p>
<h2 id="-1-">第1节 单表查询</h2>
<h3 id="1-1-">1.1  排序</h3>
<ul>
<li>通过 ORDER BY  子句,可以将查询出的结果进行排序(排序只是显示效果,不会影响真实数据)</li><li><strong>语法结构</strong></li></ul>
<pre><code>SELECT 字段名 FROM 表名 [WHERE 字段 = 值] ORDER BY 字段名 [ASC / DESC]
</code></pre><table>
<thead>
<tr>
<th><strong>ASC 表示升序排序(默认)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DESC 表示降序排序</strong></td>
</tr>
</tbody>
</table>
<h4 id="1-1-1-">1.1.1   单列排序</h4>
<ul>
<li><strong>只按照某一个字段进行排序, 就是单列排序</strong></li></ul>
<p>需求1:<br>使用 salary 字段,对emp 表数据进行排序 (升序/降序)</p>
<pre><code>-- 默认升序排序 ASC
SELECT * FROM emp ORDER BY salary;

-- 降序排序
SELECT * FROM emp ORDER BY salary DESC;
</code></pre><h4 id="1-1-2-">1.1.2   组合排序</h4>
<ul>
<li><strong>同时对多个字段进行排序, 如果第一个字段相同 就按照第二个字段进行排序,以此类推</strong></li></ul>
<p>需求2:<br>在薪水排序的基础上,再使用id进行排序, 如果薪水相同就以id 做降序排序</p>
<pre><code>-- 组合排序
SELECT * FROM emp ORDER BY salary DESC, eid DESC;
</code></pre><h3 id="1-2-">1.2  聚合函数</h3>
<p>干嘛的？求员工最高工资/平均工资/工资总和，都是聚合函数来做的</p>
<p>之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空值。)；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/377461/1598425467932-aaeb6489-ac0d-4957-bd80-c371851e4e0c.png#height=279&amp;width=443" alt=""></p>
<p>函数：方法，它封装了一些逻辑，比如给他一堆数据，特定函数可以返回最大值max()，avg()平均值</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425468131-d9d64560-f35e-47e3-b420-d83d14c6e4de.jpeg" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>聚合，也称为聚合统计或者聚合查询，就需要使用select关键字，有select 就得有from xxx</p>
<p><strong>语法结构</strong></p>
<pre><code>SELECT 聚合函数(字段名) FROM 表名;
</code></pre><p>我们来学习5个聚合函数</p>
<table>
<thead>
<tr>
<th><strong>聚合函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>count(字段)</td>
<td>统计指定列不为NULL的记录行数</td>
</tr>
<tr>
<td>sum(字段)</td>
<td>计算指定列的数值和</td>
</tr>
<tr>
<td>max(字段)</td>
<td>计算指定列的最大值</td>
</tr>
<tr>
<td>min(字段)</td>
<td>计算指定列的最小值</td>
</tr>
<tr>
<td>avg(字段)</td>
<td>计算指定列的平均值</td>
</tr>
</tbody>
</table>
<p>需求1:</p>
<pre><code>#1 查询员工的总数
#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值
#3 查询薪水大于4000员工的个数
#4 查询部门为&#39;教学部&#39;的所有员工的个数
#5 查询部门为&#39;市场部&#39;所有员工的平均薪水
</code></pre><p>SQL实现</p>
<pre><code>#1 查询员工的总数
-- 统计表中的记录条数 使用 count()
SELECT COUNT(eid) FROM emp; -- 使用某一个字段
SELECT COUNT(*) FROM emp; -- 使用
SELECT COUNT(1) FROM emp; -- 使用 1,与   效果一样

-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值
-- 所以使用时注意不要使用带有null的列进行统计
SELECT COUNT(dept_name) FROM emp;
</code></pre><pre><code>#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值
-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值 
SELECT
    SUM(salary) AS &#39;总薪水&#39;,
    MAX(salary) AS &#39;最高薪水&#39;, 
    MIN(salary) AS &#39;最低薪水&#39;,
     AVG(salary) AS &#39;平均薪水&#39;
FROM emp;
</code></pre><pre><code>#3 查询薪水大于4000员工的个数
SELECT COUNT( ) FROM emp WHERE salary &gt; 4000;
</code></pre><pre><code>#4 查询部门为&#39;教学部&#39;的所有员工的个数
SELECT COUNT( ) FROM emp WHERE dept_name = &#39;教学部&#39;;
</code></pre><pre><code>#5 查询部门为&#39;市场部&#39;所有员工的平均薪水
SELECT
    AVG(salary) AS &#39;市场部平均薪资&#39; 
FROM emp
WHERE dept_name = &#39;市场部&#39;;
</code></pre><h3 id="1-3-">1.3  分组</h3>
<p>分组往往和聚合函数一起时候，对数据进行分组，分完组之后在各个组内进行聚合统计分析比如：求各个部门的员工数~</p>
<ul>
<li>分组查询指的是使用 GROUP BY 语句,对查询的信息进行分组,相同数据作为一组</li></ul>
<p>语法格式</p>
<pre><code>SELECT 分组字段/聚合函数 FROM 表名 GROUP BY 分组字段 [HAVING 条件];
</code></pre><p>需求1:  通过性别字段 进行分组</p>
<pre><code>-- 按照性别进行分组操作
SELECT   FROM emp GROUP BY sex; -- 注意 这样写没有意义
</code></pre><p>分析:  GROUP BY 分组过程</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425468346-a4ebda32-291f-4a55-9f09-dc01b2386bdd.jpeg" alt=""></p>
<p>注意:</p>
<pre><code>分组时可以查询要分组的字段, 或者使用聚合函数进行统计操作.
* 查询其他字段没有意义
</code></pre><p>需求: 通过性别字段 进行分组,求各组的平均薪资</p>
<pre><code>SELECT sex, AVG(salary) FROM emp GROUP BY sex;
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425468507-7d09c258-39a0-413f-84b4-1ec396ac0b8a.jpeg#height=87&amp;width=443" alt=""></p>
<p>需求2:</p>
<pre><code>#1.查询每个部门的平均薪资
#2.查询每个部门的平均薪资, 部门名称不能为null
</code></pre><p>SQL实现</p>
<pre><code>#1.查询每个部门的平均薪资 SELECT
dept_name AS &#39;部门名称&#39;,
AVG(salary) AS &#39;平均薪资&#39; 
FROM emp GROUP BY dept_name;

#2.查询每个部门的平均薪资, 部门名称不能为null 
SELECT
    dept_name AS &#39;部门名称&#39;,
    AVG(salary) AS &#39;平均薪资&#39;
FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name;
</code></pre><p>需求3:</p>
<pre><code># 查询平均薪资大于6000的部门.
</code></pre><p>分析:<br>1)  需要在分组后,对数据进行过滤,使用 关键字<br>2)  分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。</p>
<p>SQL实现:</p>
<pre><code># 查询平均薪资大于6000的部门
-- 需要在分组后再次进行过滤,使用 having 
SELECT
    dept_name , 
    AVG(salary)
FROM emp  WHERE dept_name IS NOT NULL GROUP BY dept_name HAVING AVG(salary) &gt; 6000 ;
</code></pre><ul>
<li>where 与 having的区别</li></ul>
<table>
<thead>
<tr>
<th><strong>过滤方式</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>where</td>
<td>where 进行分组前的过滤 ,where 后面不能写 聚合函数</td>
</tr>
<tr>
<td>having</td>
<td>having 是分组后的过滤 ,having 后面可以写 聚合函数</td>
</tr>
</tbody>
</table>
<p><strong>1.4  limit关键字</strong></p>
<p>limit 关键字的作用</p>
<ul>
<li>limit是限制的意思,用于 限制返回的查询结果的行数 (可以通过limit指定查询多少行数据)</li><li>limit 语法是 MySql的方言,用来完成分页</li></ul>
<p>语法结构</p>
<pre><code>SELECT 字段1,字段2... FROM 表名 LIMIT offset , length;
</code></pre><p>参数说明</p>
<table>
<thead>
<tr>
<th><strong>limit oﬀset , length; 关键字可以接受一个 或者两个 为0 或者正整数的参数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>oﬀset 起始行数, 从0开始记数, 如果省略 则默认为 0.</td>
</tr>
<tr>
<td>length 返回的行数</td>
</tr>
</tbody>
</table>
<p>需求1:</p>
<pre><code># 查询emp表中的前 5条数据
# 查询emp表中 从第4条开始,查询6条
</code></pre><p>SQL实现</p>
<pre><code># 查询emp表中的前 5条数据
-- 参数1 起始值,默认是0 , 参数2 要查询的条数
SELECT   FROM emp LIMIT 5; 
SELECT   FROM emp LIMIT 0 , 5;

# 查询emp表中 从第4条开始,查询6条
--  起始值默认是从0开始的. 
SELECT   FROM emp LIMIT 3 , 6;
</code></pre><p>需求2:  分页操作 每页显示3条数据</p>
<p>SQL实现</p>
<pre><code>-- 分页操作 每页显示3条数据
SELECT   FROM emp LIMIT 0,3; -- 第1页
SELECT   FROM emp LIMIT 3,3; -- 第2页 2-1=1   1 3=3 
SELECT   FROM emp LIMIT 6,3; -- 第三页

-- 分页公式 起始索引 = (当前页 - 1)   每页条数

-- limit是MySql中的方言
</code></pre><hr>
<h2 id="-2-sql-">第2节 SQL约束</h2>
<p>SQL语句来创建数据库约束 </p>
<ol>
<li><p>约束的作用:</p>
<p> 对表中的数据进行进一步的限制，从而保证数据的正确性、有效性、完整性.违反约束的不正确数据,将无法插入到表中</p>
<p> <strong>注意：约束是针对字段的</strong></p>
</li><li><p>常见的约束</p>
</li></ol>
<table>
<thead>
<tr>
<th><strong>约束名</strong></th>
<th><strong>约束关键字</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>主键</td>
<td>primary key</td>
</tr>
<tr>
<td>唯一</td>
<td>unique</td>
</tr>
<tr>
<td>非空</td>
<td>not null</td>
</tr>
<tr>
<td>外键</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
<h3 id="-2-1-"><strong>2.1  主键约束</strong></h3>
<table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>不可重复 唯一 非空</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用</strong></td>
<td><strong>用来表示数据库中的每一条记录</strong>（用来唯一标识数据表中的一条记录）</td>
</tr>
</tbody>
</table>
<h4 id="2-1-1-">2.1.1 添加主键约束</h4>
<p>语法格式</p>
<pre><code>字段名 字段类型 primary key
</code></pre><p><strong>1) 需求:   创建一个带主键的表</strong></p>
<pre><code># 方式1 创建一个带主键的表
CREATE TABLE emp2(
    -- 设置主键 唯一 非空
    eid INT PRIMARY KEY,
    ename VARCHAR(20),
    sex CHAR(1)
);

-- 删除表
DROP TABLE emp2;

-- 方式2 创建一个带主键的表
CREATE TABLE emp2(
    eid INT ,
    ename VARCHAR(20),
    sex CHAR(1),
    -- 指定主键为 eid字段
    PRIMARY KEY(eid)
);

-- 方式3 创建一个带主键的表
CREATE TABLE emp2(
    eid INT ,
    ename VARCHAR(20),
    sex CHAR(1)
)

-- 创建的时候不指定主键,然后通过 DDL语句进行设置
ALTER TABLE emp2 ADD PRIMARY KEY(eid);
</code></pre><p><strong>DESC 查看表结构</strong></p>
<pre><code>-- 查看表的详细信息
DESC emp2;
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425468761-fa4db852-13e7-4e9a-a464-935e74f3eb9f.jpeg" alt=""></p>
<p><strong>2)  测试主键的唯一性 非空性</strong></p>
<pre><code># 正常插入一条数据
INSERT INTO emp2 VALUES(1,&#39;宋江&#39;,&#39;男&#39;);

# 插入一条数据,主键为空
-- Column &#39;eid&#39; cannot be null 主键不能为空
INSERT INTO emp2 VALUES(NULL,&#39;李逵&#39;,&#39;男&#39;);

# 插入一条数据,主键为 1
-- Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39; 主键不能重复
INSERT INTO emp2 VALUES(1,&#39;孙二娘&#39;,&#39;女&#39;);
</code></pre><p><strong>3)  哪些字段可以作为主键 ?</strong></p>
<ul>
<li><p>通常针对业务去设计主键,<strong>往往每张表都设计一个主键</strong></p>
</li><li><p>主键是给数据库和程序使用的,跟最终的客户无关,所以主键没有意义没有关系,只要能够保证不重复就好,</p>
<p>  比如 身份证号列就可以作为主键.</p>
<p>  另外，如果没有和业务关联太大的可以设计为主键的列的话，我们在进行数据库设计的时候往往人为加一列作为主键列，习惯上起名为id,rid等<br>id<br>1<br>2<br>3<br>4<br>5<br>6</p>
</li></ul>
<h4 id="2-1-2-">2.1.2   删除主键约束</h4>
<ul>
<li>删除 表中的主键约束 (了解)</li></ul>
<pre><code>-- 使用DDL语句 删除表中的主键
ALTER TABLE emp2 DROP PRIMARY KEY;
DESC emp2;
</code></pre><h4 id="2-1-3-">2.1.3   主键的自增</h4>
<p><strong>注: 主键如果让我们自己添加很有可能重复,我们通常希望在每次插入新记录时,数据库自动生成主键字段的值.</strong></p>
<hr>
<pre><code>关键字:
AUTO_INCREMENT 表示自动增长(字段类型必须是整数类型)
</code></pre><p><strong>1)  创建主键自增的表</strong></p>
<pre><code>-- 创建主键自增的表
CREATE TABLE emp2(
    -- 关键字 AUTO_INCREMENT,主键类型必须是整数类型 
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20), 
    sex CHAR(1)
);
</code></pre><p><strong>2)  添加数据 观察主键的自增</strong></p>
<pre><code>INSERT INTO emp2(ename,sex) VALUES(&#39;张三&#39;,&#39;男&#39;);
INSERT INTO emp2(ename,sex) VALUES(&#39;李四&#39;,&#39;男&#39;);
INSERT INTO emp2 VALUES(NULL,&#39;翠花&#39;,&#39;女&#39;);
INSERT INTO emp2 VALUES(NULL,&#39;艳秋&#39;,&#39;女&#39;);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425468953-63d825bc-6801-4c98-9cac-7a0345bf114c.jpeg#height=184&amp;width=440" alt=""></p>
<h4 id="2-1-4-">2.1.4   修改主键自增的起始值</h4>
<p><strong>默认地 AUTO_INCREMENT 的开始值是  1，如果希望修改起始值,请使用下面的方式</strong></p>
<hr>
<pre><code>-- 创建主键自增的表,自定义自增其实值
CREATE TABLE emp2(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20),
    sex CHAR(1)
)AUTO_INCREMENT=100;

-- 插入数据,观察主键的起始值
INSERT INTO emp2(ename,sex) VALUES(&#39;张百万&#39;,&#39;男&#39;);
INSERT INTO emp2(ename,sex) VALUES(&#39;艳秋&#39;,&#39;女&#39;);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425469108-f1b38b72-7a84-4c49-8225-f68d2fa58f40.jpeg" alt=""></p>
<h4 id="-2-1-5-delete-truncate-">**2.1.5 DELETE和TRUNCATE对自增长的影响</h4>
<ul>
<li>删除表中所有数据有两种方式**</li></ul>
<table>
<thead>
<tr>
<th><strong>清空表数据的方式</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>DELETE</td>
<td>只是删除表中所有数据,对自增没有影响</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>truncate 是将整个表删除掉,然后创建一个新的表自增的主键,重新从 1开始</td>
</tr>
</tbody>
</table>
<p>测试1:     delete 删除表中所有数据</p>
<pre><code>-- 目前最后的主键值是 101
SELECT * FROM emp2;

-- delete 删除表中数据,对自增没有影响
DELETE FROM emp2;

-- 插入数据 查看主键
INSERT INTO emp2(ename,sex) VALUES(&#39;张百万&#39;,&#39;男&#39;);
INSERT INTO emp2(ename,sex) VALUES(&#39;艳秋&#39;,&#39;女&#39;);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425469298-b5d97be1-3673-4e9d-a27c-648e35a9bc44.jpeg" alt=""></p>
<p>测试2: truncate删除 表中数据</p>
<pre><code>-- 使用 truncate 删除表中所有数据,
TRUNCATE TABLE emp2;

-- 插入数据 查看主键
INSERT INTO emp2(ename,sex) VALUES(&#39;张百万&#39;,&#39;男&#39;);
INSERT INTO emp2(ename,sex) VALUES(&#39;艳秋&#39;,&#39;女&#39;);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425469484-44ce053b-2a72-4d04-9664-25d15a1e1763.jpeg" alt=""></p>
<h3 id="2-2-">2.2  非空约束</h3>
<p><strong>非空约束特点：某⼀列不允许为空</strong></p>
<p>语法格式</p>
<pre><code>字段名 字段类型 not null
</code></pre><p>需求1: 为 ename 字段添加非空约束</p>
<pre><code># 非空约束
CREATE TABLE emp2(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    -- 添加非空约束, ename字段不能为空
    ename VARCHAR(20) NOT NULL,
    sex CHAR(1)
);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425469771-830200df-73fc-4132-a8b9-13de05c14b74.jpeg" alt=""></p>
<h3 id="2-3-">2.3  唯一约束</h3>
<p><strong>唯一约束的特点: 表中的某一列的值不能重复( 对null不做唯一的判断 )</strong></p>
<p>语法格式</p>
<pre><code>字段名 字段值 unique
</code></pre><p>1)  添加唯一约束</p>
<pre><code>#创建emp3表 为ename 字段添加唯一约束
CREATE TABLE emp3(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20) UNIQUE,
    sex CHAR(1)
);
</code></pre><p>2)  测试唯一约束</p>
<pre><code>-- 测试唯一约束 添加一条数据
INSERT INTO emp3 (ename,sex) VALUES(&#39;张百万&#39;,&#39;男&#39;);

-- 添加一条 ename重复的 数据
-- Duplicate entry &#39;张百万&#39; for key &#39;ename&#39; ename不能重复
INSERT INTO emp3 (ename,sex) VALUES(&#39;张百万&#39;,&#39;女&#39;);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425469940-a0de2ba3-fb7a-4909-9954-4f15039994e8.jpeg#height=186&amp;width=443" alt=""></p>
<table>
<thead>
<tr>
<th><strong>主键约束与唯一约束的区别:</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 主键约束 唯一且不能够为空（主键约束=非空约束+唯一约束）</td>
</tr>
<tr>
<td>2. 唯一约束,唯一 但是可以为空</td>
</tr>
<tr>
<td>3. 一个表中只能有一个主键 , 但是可以有多个唯一约束</td>
</tr>
</tbody>
</table>
<h3 id="2-4-">2.4  外键约束</h3>
<ul>
<li>FOREIGN  KEY 表示外键约束，将在多表中学习。</li></ul>
<h3 id="-2-5-"><strong>2.5  默认值</strong></h3>
<p><strong>默认值约束 用来指定某列的默认值</strong></p>
<p>语法格式</p>
<pre><code>字段名 字段类型 DEFAULT 默认值
</code></pre><p>1)  创建emp4表, 性别字段默认 女</p>
<pre><code>-- 创建带有默认值的表
CREATE TABLE emp4(
   eid INT PRIMARY KEY AUTO_INCREMENT,
   -- 为ename 字段添加默认值
   ename VARCHAR(20) DEFAULT &#39;女&#39;,
   sex CHAR(1)
);
</code></pre><p>2)  测试 添加数据使用默认值</p>
<pre><code>-- 添加数据 使用默认值
INSERT INTO emp4(ename,sex) VALUES(DEFAULT,&#39;男&#39;);
INSERT INTO emp4(sex) VALUES(&#39;女&#39;);

-- 不使用默认值
INSERT INTO emp4(ename,sex) VALUES(&#39;艳秋&#39;,&#39;女&#39;);
</code></pre><h2 id="-3-">第3节 多表查询</h2>
<h3 id="3-1-">3.1  外键约束</h3>
<p>主键：数据表A中有一列，这一列可以唯一的标识一条记录<br>外键：数据表A中有一列，这一列指向了另外一张数据表B的主键</p>
<h4 id="3-1-1-">3.1.1   什么是外键</h4>
<ul>
<li><p>外键指的是在<code>从表</code>中与<code>主表</code>的主键对应的那个字段,比如员工表的 dept_id,就是外键</p>
</li><li><p>使用外键约束可以让两张表之间产生一个对应关系,从而保证主从表的引用的完整性</p>
</li></ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425470390-8098e9db-31c9-40e1-b8a4-23613f48e0d2.jpeg" alt=""></p>
<ul>
<li>多表关系中的主表和从表<ul>
<li>主表: 主键id所在的表, 约束别人的表</li><li>从表: 外键所在的表多, 被约束的表</li></ul>
</li></ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425470905-aa68d1cc-70e1-4cba-adaf-f3447e380b05.jpeg" alt=""></p>
<p>在上述的关系场景中，外键所在的表叫做从表，外键所指向的表叫做主表</p>
<h4 id="3-1-2-">3.1.2   创建外键约束</h4>
<p>语法格式:</p>
<ol>
<li>新建表时添加外键</li></ol>
<pre><code>[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名)
</code></pre><ol>
<li>已有表添加外键</li></ol>
<pre><code>ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名)
REFERENCES 主表(主 键字段名);
</code></pre><p>1) 重新创建employee表, 添加外键约束</p>
<pre><code>-- 先删除 employee表
DROP TABLE employee;

-- 重新创建 employee表,添加外键约束
CREATE TABLE employee(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20),
    age INT,
    dept_id INT, -- 外键字段类型要和主表的主键字段类型保持一致
    -- 添加外键约束
    CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id)
);
</code></pre><p>2)  插入数据</p>
<pre><code>-- 正常添加数据 (从表外键 对应主表主键)
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;张百万&#39;, 20, 1);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;赵四&#39;, 21, 1);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;广坤&#39;, 20, 1);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;小斌&#39;, 20, 2);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;艳秋&#39;, 22, 2);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;大玲子&#39;, 18, 2);

-- 插入一条有问题的数据 (部门id不存在)
-- Cannot add or update a child row: a foreign key constraint fails
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;错误&#39;, 18, 3);
</code></pre><ul>
<li>添加外键约束,就会产生强制性的外键数据检查, 从而保证了数据的完整性和一致性,</li></ul>
<h4 id="3-1-3-">3.1.3   删除外键约束</h4>
<p><strong>添加/删除外键针对的都是从表</strong></p>
<p>语法格式</p>
<pre><code>alter table 从表 drop foreign key 外键约束名称
</code></pre><p>1)  删除 外键约束</p>
<pre><code>-- 删除employee 表中的外键约束,外键约束名 emp_dept_fk
ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;
</code></pre><p>2)  再将外键 添加回来</p>
<p>语法格式</p>
<pre><code>ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名)
REFERENCES 主表(主 键字段名);

-- 可以省略外键名称, 系统会自动生成一个
ALTER TABLE employee ADD FOREIGN KEY (dept_id) REFERENCES department (id);
</code></pre><h4 id="3-1-4-">3.1.4   外键约束的注意事项</h4>
<p>1)  从表外键类型必须与主表主键类型一致 否则创建失败.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425471063-745f3c93-4be3-475f-965e-bc0971590b98.jpeg" alt=""></p>
<p>2)  添加数据时, 应该先添加主表中的数据.</p>
<pre><code>-- 添加一个新的部门
INSERT INTO department(dep_name,dep_location) VALUES(&#39;市场部&#39;,&#39;北京&#39;);

-- 添加一个属于市场部的员工
INSERT INTO employee(ename,age,dept_id) VALUES(&#39;老胡&#39;,24,3);
</code></pre><p>3)  删除数据时,应该先删除从表中的数据.</p>
<pre><code>-- 删除数据时 应该先删除从表中的数据
-- 报错 Cannot delete or update a parent row: a foreign key constraint fails
-- 报错原因 不能删除主表的这条数据,因为在从表中有对这条数据的引用
DELETE FROM department WHERE id = 3;
</code></pre><pre><code>-- 先删除从表的关联数据
DELETE FROM employee WHERE dept_id = 3;

-- 再删除主表的数据
DELETE FROM department WHERE id = 3;
</code></pre><h4 id="3-1-5-">3.1.5   级联删除操作(了解)</h4>
<ul>
<li><strong>如果想实现删除主表数据的同时,也删除掉从表数据,可以使用级联删除操作</strong></li></ul>
<pre><code>级联删除
ON DELETE CASCADE
</code></pre><p>1) 删除 employee表,重新创建,添加级联删除</p>
<pre><code>-- 重新创建添加级联操作
CREATE TABLE employee(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20),
    age INT,
    dept_id INT,
    CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id)
    -- 添加级联删除
    ON DELETE CASCADE
);

-- 添加数据
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;张百万&#39;, 20, 1);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;赵四&#39;, 21, 1);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;广坤&#39;, 20, 1);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;小斌&#39;, 20, 2);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;艳秋&#39;, 22, 2);
INSERT INTO employee (ename, age, dept_id) VALUES (&#39;大玲子&#39;, 18, 2);

-- 删除部门编号为2 的记录
DELETE FROM department WHERE id = 2;
</code></pre><ul>
<li>员工表中 外键值是2的记录,也被删除了</li></ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425471266-7e700985-c97d-4820-881a-16173b6d4f48.jpeg" alt=""></p>
<h3 id="3-2-">3.2  什么是多表查询</h3>
<ul>
<li><p>DQL: 查询多张表（至少涉及2张表）,获取到需要的数据</p>
</li><li><p>比如 我们要查询<strong>家电分类下 都有哪些商品</strong>,那么我们就<strong>分类表+商品表</strong></p>
</li></ul>
<h3 id="3-3-">3.3  数据准备</h3>
<p>1)  创建db3_2 数据库</p>
<pre><code>-- 创建 db3_2 数据库,指定编码
CREATE DATABASE db3_2 CHARACTER SET utf8;
</code></pre><p>2)  创建分类表与商品表</p>
<pre><code>#分类表 (一方 主表)
CREATE TABLE category (
    cid VARCHAR(32) PRIMARY KEY ,
    cname VARCHAR(50)
);

#商品表 (多方 从表)
CREATE TABLE products(
    pid VARCHAR(32) PRIMARY KEY ,
    pname VARCHAR(50),
    price INT,
    flag VARCHAR(2), #是否上架标记为：1表示上架、0表示下架
    category_id VARCHAR(32),
    -- 添加外键约束
    FOREIGN KEY (category_id) REFERENCES category (cid)
);
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425471433-0889b82e-1899-4cf0-a777-9a2e7b5643bc.jpeg" alt=""></p>
<p>3)  插入数据</p>
<pre><code>#分类数据
INSERT INTO category(cid,cname) VALUES(&#39;c001&#39;,&#39;家电&#39;); INSERT INTO category(cid,cname) VALUES(&#39;c002&#39;,&#39;鞋服&#39;); INSERT INTO category(cid,cname) VALUES(&#39;c003&#39;,&#39;化妆品&#39;); INSERT INTO category(cid,cname) VALUES(&#39;c004&#39;,&#39;汽车&#39;);

#商品数据
INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#39;p001&#39;,&#39;小米电视机&#39;,5000,&#39;1&#39;,&#39;c001&#39;);
INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#39;p002&#39;,&#39;格力空调&#39;,3000,&#39;1&#39;,&#39;c001&#39;);
INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#39;p003&#39;,&#39;美的冰箱&#39;,4500,&#39;1&#39;,&#39;c001&#39;);

INSERT INTO products (pid, pname,price,flag,category_id) VALUES(&#39;p004&#39;,&#39;篮球鞋&#39;,800,&#39;1&#39;,&#39;c002&#39;);
INSERT INTO products (pid, pname,price,flag,category_id) VALUES(&#39;p005&#39;,&#39;运动裤&#39;,200,&#39;1&#39;,&#39;c002&#39;);
INSERT INTO products (pid, pname,price,flag,category_id) VALUES(&#39;p006&#39;,&#39;T
恤&#39;,300,&#39;1&#39;,&#39;c002&#39;);
INSERT INTO products (pid, pname,price,flag,category_id) VALUES(&#39;p007&#39;,&#39;冲锋衣&#39;,2000,&#39;1&#39;,&#39;c002&#39;);

INSERT INTO products (pid, pname,price,flag,category_id) VALUES(&#39;p008&#39;,&#39;神仙水&#39;,800,&#39;1&#39;,&#39;c003&#39;);
INSERT INTO products (pid, pname,price,flag,category_id) VALUES(&#39;p009&#39;,&#39;大宝&#39;,200,&#39;1&#39;,&#39;c003&#39;);
</code></pre><h3 id="3-4-">3.4  笛卡尔积</h3>
<p>交叉连接查询,因为会产生笛卡尔积,所以 基本不会使用</p>
<p>1)  语法格式</p>
<pre><code>SELECT 字段名 FROM  表1, 表2;
</code></pre><p>2)  使用交叉连接查询 商品表与分类表</p>
<pre><code>SELECT   FROM category , products;
</code></pre><p>3)  观察查询结果,产生了笛卡尔积 (得到的结果是无法使用的)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200830162721.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200830162722.jpg" alt=""></p>
<p>4) 笛卡尔积</p>
<p>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425471644-fe345716-3772-4c7a-a9ec-e8e4d159b099.jpeg#height=120&amp;width=441" alt=""></p>
<p>笛卡尔积更进一步，添加where条件，过滤出有效数据</p>
<h3 id="3-5-">3.5  多表查询的分类</h3>
<h4 id="3-5-1-">3.5.1   内连接查询</h4>
<p>内连接的特点:</p>
<p>通过指定的条件去匹配两张表中的数据, 匹配上就显示,匹配不上就不显示</p>
<p>比如通过: 从表的外键 = 主表的主键 方式去匹配</p>
<p><strong>1、隐式内链接</strong></p>
<p><strong>form子句 后面直接写 多个表名 使用where指定连接条件的 这种连接方式是 隐式内连接.使用where条件过滤无用的数据</strong></p>
<p>语法格式</p>
<pre><code>SELECT 字段名 FROM 左表, 右表 WHERE 连接条件;
</code></pre><p>1)  查询所有商品信息和对应的分类信息</p>
<pre><code># 隐式内连接
SELECT   FROM products,category WHERE category_id = cid;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200830163146.png" alt=""></p>
<p>2)   查询商品表的商品名称 和 价格,以及商品的分类信息</p>
<p><strong>可以通过给表起别名的方式,  方便我们的查询(有提示)</strong></p>
<pre><code class="lang-`">SELECT
    p.`pname`,
    p.`price`,
    c.`cname`
FROM products p , category c WHERE p.`category_id` = c.`cid`;
</code></pre>
<p>3)   查询 格力空调是属于哪一分类下的商品</p>
<pre><code>#查询 格力空调是属于哪一分类下的商品
SELECT p.`pname`,c.`cname` FROM products p , category c 
WHERE p.`category_id` = c.`cid` AND p.`pid` = &#39;p002&#39;;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200830164829.jpg" alt=""></p>
<p><strong>2、显式内连接</strong></p>
<p>使用 inner join …on 这种方式, 就是显式内连接</p>
<p><strong>语法格式</strong></p>
<pre><code>SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件
-- inner 可以省略
</code></pre><p>1)  查询所有商品信息和对应的分类信息</p>
<pre><code># 显式内连接查询
SELECT   FROM products p INNER JOIN category c ON p.category_id = c.cid;
</code></pre><p>2)  查询鞋服分类下,价格大于500的商品名称和价格</p>
<pre><code># 查询鞋服分类下,价格大于500的商品名称和价格
-- 我们需要确定的几件事
-- 1.查询几张表 products &amp; category
-- 2.表的连接条件 从表.外键 = 主表的主键
-- 3.查询的条件 cname = &#39;鞋服&#39; and price &gt; 500
-- 4.要查询的字段 pname price

SELECT
    p.pname, 
    p.price
FROM products p INNER JOIN category c ON p.category_id = c.cid 
WHERE p.price &gt; 500 AND cname = &#39;鞋服&#39;;
</code></pre><h4 id="3-5-2-">3.5.2   外连接查询</h4>
<h5 id="-1-"><strong>1、左外连接</strong></h5>
<ul>
<li><p>左外连接 , 使用 LEFT OUTER JOIN , OUTER 可以省略</p>
</li><li><p>左外连接的特点</p>
<ul>
<li>以左表为基准, 匹配右边表中的数据,如果匹配的上,就展示匹配到的数据</li><li>如果匹配不到, 左表中的数据正常展示, 右边的展示为null.</li></ul>
</li></ul>
<p>1)  语法格式</p>
<pre><code>SELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件
</code></pre><pre><code>-- 左外连接查询
SELECT   FROM category c LEFT JOIN products p  ON c.`cid`= p.`category_id`;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200831233001.jpg" alt=""></p>
<p>2)  左外连接, 查询每个分类下的商品个数</p>
<pre><code># 查询每个分类下的商品个数
/*
    1.连接条件: 主表.主键 = 从表.外键
    2.查询条件: 每个分类 需要分组
    3.要查询的字段: 分类名称, 分类下商品个数
*/
SELECT
    c.`cname` AS &#39;分类名称&#39;,
    COUNT(p.`pid`) AS &#39;商品个数&#39;
FROM category c LEFT JOIN products p ON c.`cid` = p.`category_id`
GROUP BY c.`cname`;
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425471765-442477ff-7926-4d4c-a6c4-c9e2ea8246a8.jpeg#height=137&amp;width=344" alt=""></p>
<h5 id="2-">2、右外连接</h5>
<ul>
<li>右外连接 , 使用 RIGHT OUTER JOIN , OUTER 可以省略</li></ul>
<ul>
<li>右外连接的特点<ul>
<li>以右表为基准，匹配左边表中的数据，如果能匹配到，展示匹配到的数据</li><li>如果匹配不到，右表中的数据正常展示, 左边展示为null</li></ul>
</li></ul>
<p>1) 语法格式</p>
<pre><code>SELECT 字段名 FROM 左表 RIGHT [OUTER ]JOIN 右表 ON 条件
</code></pre><pre><code>-- 右外连接查询
SELECT   FROM products p RIGHT JOIN category c ON p.`category_id` = c.`cid`;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200831233438.jpg" alt=""></p>
<h4 id="3-5-3-">3.5.3   各种连接方式的总结</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425471907-a073a344-dd67-4775-b6a4-d5be8020190e.jpeg#height=250&amp;width=438" alt=""></p>
<ul>
<li>内连接: inner join , 只获取两张表中 交集部分的数据.</li></ul>
<ul>
<li>左外连接: left join ,  以左表为基准 ,查询左表的所有数据, 以及与右表有交集的部分</li></ul>
<ul>
<li>右外连接: right join , 以右表为基准,查询右表的所有的数据,以及与左表有交集的部分内连接和左外连接使用居多</li></ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200831233740.jpg" alt=""></p>
<p>表1 表2 表3 表4 表5<br>（表1+表2）a<br>（a + 表3）b<br>（b + 表4）c<br>（c+表5）</p>
<hr>
<h2 id="-4-">第4节 合并查询</h2>
<h3 id="4-1-union">4.1  UNION</h3>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集，并消除重复行。</p>
<p>注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p>
<p><strong>UNION </strong>子句的基本语法如下所示：</p>
<pre><code>SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
</code></pre><p>示例</p>
<p>如下两张表</p>
<ol>
<li>Customers 表：</li></ol>
<pre><code>+----+----------+-----+-----------+----------+
| Id | Name | Sex | Address | Salary |
+----+----------+-----+-----------+----------+
| 1 | 孙悟空 | 男 | 花果山 | 2000 |
| 2 | 猪八戒 | 男 | 高老庄 | 1500 |
| 3 | 唐僧 | 男 | 东土大唐 | 3000 |
| 4 | 沙僧 | 男 | 流沙河 | 2500 |
| 5 | 女儿国王 | 女 | 女儿国 | 10000 |
| 6 | 黄蓉 | 女 | 桃花岛 | 7500 |
| 7 | 郭静 | 男 | 牛家村 | 6000 |
+----+----------+-----+-----------+----------+
</code></pre><ol>
<li>Orders 表：</li></ol>
<pre><code>+-----+---------------------+-------------+--------+
|Oid  | Date               | Customers_Id | Amount |
+-----+---------------------+-------------+--------+
| 102 | 2019-12-08 00:00:00 |          3 |  2000   |
| 100 | 2019-10-06 00:00:00 |          3 |  1500   |
| 101 | 2019-09-20 00:00:00 |          6 |  3000   |
| 103 | 2020-05-20 00:00:00 |          5 |  5000   |
+-----+---------------------+-------------+--------+
</code></pre><ul>
<li>创建表</li></ul>
<pre><code>CREATE TABLE Customers(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Name VARCHAR(20),
    Sex VARCHAR(20),
    Address VARCHAR(20),
    Salary INT
);

CREATE TABLE Orders(
    Oid INT PRIMARY KEY AUTO_INCREMENT,
    Date VARCHAR(20),
    Customers_Id VARCHAR(20),
    Amount INT
);
</code></pre><ul>
<li>插入数据</li></ul>
<pre><code>INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;孙悟空&#39;, &#39;男&#39;,
&#39;花果山&#39;,2000);
INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;猪八戒&#39;, &#39;男&#39;,
&#39;高老庄&#39;,1500);
INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;唐僧&#39;, &#39;男&#39;,
&#39;东土大唐&#39;,3000);
INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;沙僧&#39;, &#39;男&#39;,
&#39;流沙河&#39;,2500);
INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;女儿国王&#39;,
&#39;女&#39;, &#39;女儿国&#39;,10000);
INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;黄蓉&#39;, &#39;女&#39;,
&#39;桃花岛&#39;,7500);
INSERT INTO Customers (Name, Sex, Address, Salary) VALUES (&#39;郭静&#39;, &#39;男&#39;,
&#39;牛家村&#39;,6000);
INSERT INTO Orders (Oid, Date, Customers_Id, Amount) VALUES (102, &#39;2019-
12-08 00:00:00&#39;, 3, 2000);
INSERT INTO Orders (Oid, Date, Customers_Id, Amount) VALUES (100, &#39;2019-
10-06 00:00:00&#39;, 3, 1500);
INSERT INTO Orders (Oid, Date, Customers_Id, Amount) VALUES (101, &#39;2019-
09-20 00:00:00&#39;, 6, 3000);
INSERT INTO Orders (Oid, Date, Customers_Id, Amount) VALUES (103, &#39;2020-
05-20 00:00:00&#39;, 5, 5000);
</code></pre><ul>
<li>用 SELECT 语句将这两张表连接起来：</li></ul>
<pre><code>SELECT Id,NAME,Amount,Date
FROM customers
LEFT JOIN orders
on customers.Id = orders.Customers_Id

UNION

SELECT Id,NAME,Amount,Date
from customers
RIGHT JOIN orders
on customers.Id = orders.Customers_Id;
</code></pre><p>结果如下所示：</p>
<pre><code>+------+----------+--------+---------------------+
| ID | NAME | AMOUNT | DATE |
+------+----------+--------+---------------------+
| 3 | 唐僧 | 1500 | 2019-10-06 00:00:00 |
| 6 | 黄蓉 | 3000 | 2019-09-20 00:00:00 |
| 3 | 唐僧 | 2000 | 2019-12-08 00:00:00 |
| 5 | 女儿国王 | 5000 | 2020-05-20 00:00:00 |
| 1 | 孙悟空 | NULL | NULL |
| 2 | 猪八戒 | NULL | NULL |
| 4 | 沙僧 | NULL | NULL |
| 7 | 郭静 | NULL | NULL |
+------+----------+--------+---------------------+
</code></pre><p>小结：</p>
<ol>
<li>选择的列数必须相同；</li><li>所选列的数据类型必须在相同的数据类型组中（如数字或字符）</li><li>列的名称不必相同</li><li>在重复检查期间，NULL值不会被忽略</li></ol>
<h3 id="4-2-union-all">4.2  UNION ALL</h3>
<p>UNION ALL 运算符用于将两个 SELECT 语句的结果组合在一起，重复行也包含在内。</p>
<p>UNION ALL 运算符所遵从的规则与 UNION 一致。</p>
<p>语法：</p>
<p><strong>UNION  ALL</strong>的基本语法如下：</p>
<pre><code>SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION ALL

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
</code></pre><p>示例：</p>
<p>现在，让我们用 SELECT 语句将Customers、Orders两张表连接起来：</p>
<pre><code>SELECT Id,NAME,Amount,Date
FROM customers
LEFT JOIN orders
on customers.Id = orders.Customers_Id

UNION ALL

SELECT Id,NAME,Amount,Date
from customers
RIGHT JOIN orders
on customers.Id = orders.Customers_Id;
</code></pre><p>结果如下所示：</p>
<pre><code>+------+----------+--------+---------------------+
| ID   | NAME     | AMOUNT | DATE               |
+------+----------+--------+---------------------+
|    3 | 唐僧      |   1500 | 2019-10-06 00:00:00 |
|    6 | 黄蓉      |   3000 | 2019-09-20 00:00:00 |
|    3 | 唐僧      |   2000 | 2019-12-08 00:00:00 |
|    5 | 女儿国王   |   5000 | 2020-05-20 00:00:00 |
|    1 | 孙悟空    |   NULL | NULL               |
|    2 | 猪八戒    |   NULL | NULL               |
|    4 | 沙僧      |   NULL | NULL               |
|    7 | 郭静      |   NULL | NULL               |
|    3 | 唐僧      |   1500 | 2019-10-06 00:00:00 |
|    6 | 黄蓉      |   3000 | 2019-09-20 00:00:00 |
|    3 | 唐僧      |   2000 | 2019-12-08 00:00:00 |
|    5 | 女儿国王   |   5000 | 2020-05-20 00:00:00 |
+------+----------+--------+---------------------+
</code></pre><p>总结：</p>
<p>UNION和UNION ALL关键字都是将两个结果集合并为一个，也有区别。</p>
<p>1、重复值：UNION在进行表连接后会筛选掉重复的记录，而Union All不会去除重复记录。</p>
<p>2、UNION ALL只是简单的将两个结果合并后就返回。</p>
<p>3、在执行效率上，UNION ALL 要比UNION快很多，因此，若可以确认合并的两个结果集中不包含重复数据，那么就使用UNION ALL。</p>
<hr>
<h2 id="-5-">第5节 子查询</h2>
<h3 id="5-1-">5.1  什么是子查询</h3>
<ul>
<li><p>子查询概念</p>
<ul>
<li>一条select 查询语句的结果, 作为另一条 select 语句的一部分</li></ul>
</li><li><p>子查询的特点</p>
<ul>
<li>子查询必须放在小括号中</li><li>子查询的场景中还会有另外一个特点，整个sql至少会有两个select关键字</li></ul>
</li><li><p>子查询常见分类</p>
<ul>
<li><strong>where型 子查询:  </strong>将子查询的结果, 作为父查询的比较条件   =</li><li><strong>from型 子查询 :  </strong>将子查询的结果, 作为 一张表,提供给父层查询使用</li><li><strong>exists型 子查询: </strong>子查询的结果是单列多行, 类似一个数组, 父层查询使用含子查询的结果</li></ul>
</li></ul>
<h3 id="5-2-">5.2  子查询的结果作为查询条件</h3>
<p>语法格式</p>
<pre><code>SELECT 查询字段 FROM 表 WHERE 字段=（子查询）;
</code></pre><ol>
<li>通过子查询的方式, 查询价格最高的商品信息</li></ol>
<pre><code># 通过子查询的方式, 查询价格最高的商品信息
-- 1.先查询出最高价格
SELECT MAX(price) FROM products;

-- 2.将最高价格作为条件,获取商品信息
SELECT * FROM products WHERE price = (SELECT MAX(price) FROM products);
</code></pre><ol>
<li>查询化妆品分类下的 商品名称 商品价格</li></ol>
<pre><code>#查询化妆品分类下的 商品名称 商品价格

-- 先查出化妆品分类的 id
SELECT cid FROM category WHERE cname = &#39;化妆品&#39;;

-- 根据分类id ,去商品表中查询对应的商品信息
SELECT
    p.`pname`,
     p.`price`
FROM products p
WHERE p.`category_id` = (SELECT cid FROM category WHERE cname = &#39;化妆品&#39;);
</code></pre><ol>
<li>查询小于平均价格的商品信息</li></ol>
<pre><code>-- 1.查询平均价格
SELECT AVG(price) FROM products; -- 1866

-- 2.查询小于平均价格的商品 SELECT   FROM products
WHERE price &lt; (SELECT AVG(price) FROM products);
</code></pre><h3 id="5-3-">5.3  子查询的结果作为一张表</h3>
<p>语法格式</p>
<pre><code>SELECT 查询字段 FROM （ 子查询） 表别名 WHERE 条件;
</code></pre><ol>
<li>查询商品中,价格大于500的商品信息,包括 商品名称 商品价格 商品所属分类名称</li></ol>
<pre><code>-- 1. 先查询分类表的数据
SELECT * FROM category;

-- 2.将上面的查询语句 作为一张表使用
SELECT
    p.`pname`,
    p.`price`,
    c.cname
FROM products p

-- 子查询作为一张表使用时 要起别名 才能访问表中字段
INNER JOIN (SELECT * FROM category) c
ON p.`category_id` = c.cid WHERE p.`price` &gt; 500;
</code></pre><p><strong>注意： 当子查询作为一张表的时候，需要起别名，否则无法访问表中的字段。</strong></p>
<h3 id="-5-4-"><strong>5.4  子查询结果是单列多行</strong></h3>
<ul>
<li>子查询的结果类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果</li></ul>
<p>语法格式</p>
<pre><code>SELECT 查询字段 FROM 表 WHERE 字段 IN （ 子查询）;
</code></pre><ol>
<li>查询价格小于两千的商品,来自于哪些分类(名称)</li></ol>
<pre><code># 查询价格小于两千的商品,来自于哪些分类(名称)

-- 先查询价格小于2000 的商品的,分类ID
SELECT DISTINCT category_id FROM products WHERE price &lt; 2000;

-- 在根据分类的id信息,查询分类名称
-- 报错: Subquery returns more than 1 row
-- 子查询的结果 大于一行
SELECT * FROM category
WHERE cid = (SELECT DISTINCT category_id FROM products WHERE price &lt;
2000);
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/20200901000018.jpg" alt=""></p>
<ul>
<li>使用in函数,  in( c002,  c003 )</li></ul>
<pre><code>-- 子查询获取的是单列多行数据
SELECT   FROM category
WHERE cid IN (SELECT DISTINCT category_id FROM products WHERE price &lt; 2000);
</code></pre><ol>
<li>查询家电类 与 鞋服类下面的全部商品信息</li></ol>
<pre><code># 查询家电类 与 鞋服类下面的全部商品信息
-- 先查询出家电与鞋服类的 分类ID
SELECT cid FROM category WHERE cname IN (&#39;家电&#39;,&#39;鞋服&#39;);

-- 根据cid 查询分类下的商品信息
SELECT   FROM products
WHERE category_id IN (SELECT cid FROM category WHERE cname IN (&#39;家电&#39;,&#39;鞋服&#39;));
</code></pre><h3 id="5-5-">5.5  子查询总结</h3>
<ol>
<li><p>子查询如果查出的是一个字段(单列), 那就在where后面作为条件使用.</p>
<p>单列单行  =<br>单列多行 in</p>
</li><li><p>子查询如果查询出的是多个字段(多列), 就当做一张表使用(要起别名).</p>
</li></ol>
<hr>
<h2 id="-6-">第6节 牛刀小试（汽车新零售）</h2>
<p>一、涉及业务介绍</p>
<p>某头部汽车新零售企业立足下沉市场，通过网络渠道和品牌广告获取大量汽车销售线索，并借助大量地面销售在线下门店完成客户成交孵化，该企业最终依靠自建供应链建立的护城河来赚取采购差价，同时也通过给客户提供低首付金融租赁产品来赚取金融费用（车贷）。该公司商业分析师需要从数据层面去驱动投放团队去做效率优化，以助力业务正常健康发展。</p>
<p>二、涉及业务数据及字典</p>
<pre><code>数据库：business_sample_car_retail
涉及表：clue_day，order_day
</code></pre><ul>
<li>线索表clue_day</li></ul>
<table>
<thead>
<tr>
<th><strong>Column</strong></th>
<th><strong>Type</strong></th>
<th><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>clue_id</td>
<td>bigint</td>
<td>线索id</td>
</tr>
<tr>
<td>city_id</td>
<td>bigint</td>
<td>用户城市id(线索产生时的城市)</td>
</tr>
<tr>
<td>deal_city_id</td>
<td>bigint</td>
<td>交易城市id</td>
</tr>
<tr>
<td>district_id</td>
<td>bigint</td>
<td>区县 id</td>
</tr>
<tr>
<td>cc_id</td>
<td>bigint</td>
<td>客户id</td>
</tr>
<tr>
<td>guid</td>
<td>varchar</td>
<td>设备id</td>
</tr>
<tr>
<td>customer_phone</td>
<td>varchar</td>
<td>客户手机号(密文)</td>
</tr>
<tr>
<td>ca_s</td>
<td>varchar</td>
<td>一级渠道（网络渠道/品牌广告）</td>
</tr>
<tr>
<td>ca_n</td>
<td>varchar</td>
<td>二级渠道</td>
</tr>
<tr>
<td>ca_s_new</td>
<td>varchar</td>
<td>归因后一级渠道</td>
</tr>
<tr>
<td>ca_n_new</td>
<td>varchar</td>
<td>归因后二级渠道</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>Column</strong></th>
<th><strong>Type</strong></th>
<th><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>clue_platform</td>
<td>varchar</td>
<td>电销侧来源平台</td>
</tr>
<tr>
<td>cainfo</td>
<td>varchar</td>
<td>附加信息</td>
</tr>
<tr>
<td>platform</td>
<td>varchar</td>
<td>手机wap端/pc端</td>
</tr>
<tr>
<td>newcar_product_type</td>
<td>integer</td>
<td>新车产品类型,0-4s店带看 1-付一成,2是回访 3是在线客服 4是400,-250战败工单</td>
</tr>
<tr>
<td>is_high_quality</td>
<td>integer</td>
<td>是否高质量线索标识</td>
</tr>
<tr>
<td>is_valid</td>
<td>integer</td>
<td>线索是否有效</td>
</tr>
<tr>
<td>is_new</td>
<td>integer</td>
<td>是否新线索</td>
</tr>
<tr>
<td>clue_created_at</td>
<td>varchar</td>
<td>创建时间</td>
</tr>
</tbody>
</table>
<ul>
<li>成交订单表order_day</li></ul>
<table>
<thead>
<tr>
<th><strong>Column</strong></th>
<th><strong>Type</strong></th>
<th><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>order_id</td>
<td>int</td>
<td>订单id</td>
</tr>
<tr>
<td>customer_name</td>
<td>varchar</td>
<td>客户姓名</td>
</tr>
<tr>
<td>phone</td>
<td>varchar</td>
<td>电话，加密</td>
</tr>
<tr>
<td>city_id</td>
<td>int</td>
<td>城市ID</td>
</tr>
<tr>
<td>brand_id</td>
<td>int</td>
<td>品牌ID</td>
</tr>
<tr>
<td>chexi_id</td>
<td>int</td>
<td>车系ID</td>
</tr>
<tr>
<td>chexing_id</td>
<td>int</td>
<td>车型ID</td>
</tr>
<tr>
<td>sku_id</td>
<td>int</td>
<td>sku_id</td>
</tr>
<tr>
<td>vin</td>
<td>varchar</td>
<td>车辆vin码</td>
</tr>
<tr>
<td>engine_num</td>
<td>varchar</td>
<td>发动机号</td>
</tr>
<tr>
<td>hegezheng_pic</td>
<td>varchar</td>
<td>合格证照片</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>Column</strong></th>
<th><strong>Type</strong></th>
<th><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>apply_id</td>
<td>varchar</td>
<td>金融支付id</td>
</tr>
<tr>
<td>color</td>
<td>int</td>
<td>购买车型颜色</td>
</tr>
<tr>
<td>created_at</td>
<td>varchar</td>
<td>创建时间</td>
</tr>
<tr>
<td>clue_id</td>
<td>int</td>
<td>线索ID</td>
</tr>
<tr>
<td>saler_id</td>
<td>int</td>
<td>销售id</td>
</tr>
<tr>
<td>downpayment_paid_time</td>
<td>varchar</td>
<td>首付完成时间</td>
</tr>
<tr>
<td>ﬁnished_time</td>
<td>varchar</td>
<td>订单完成时间</td>
</tr>
</tbody>
</table>
<p>创建数据表</p>
<pre><code>create table clue_day (
    clue_id int (8),
    city_id int (3),
    deal_city_id int (3),
    cc_id int (9),
    guid varchar (36),
    customer_phone varchar (26),
    ca_s varchar (18),
    ca_n varchar (13),
    ca_s_new varchar (12),
    ca_n_new varchar (13),
    clue_platform varchar (23),
    cainfo varchar (318),
    platform varchar (5),
    newcar_product_type int (1),
    is_high_quality int (1),
    is_valid int (1),
    is_new int (1),
    clue_created_at datetime,
    district_id int (4)
);

create table order_day
(
    created_at datetime,
    order_id int(5),
    clue_id int(10),
    city_id int(5),
    chexing_id int(10),
    sku_id int(5),
    vin varchar(46),
    engine_num varchar(26)
);
</code></pre><p>初始化数据， 源数据，参考资料文件夹中的：</p>
<p>D:\course\mysql\资料\汽车新零售数据\clue_day.csv</p>
<p>D:\course\mysql\资料\汽车新零售数据\order_day.csv</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8.jpg" alt=""></p>
<p>三、需求确认：</p>
<p>需求1： 查询线索(二级渠道jdsc)后续转化成交车型详情</p>
<ul>
<li>解析：</li></ul>
<pre><code>/*
需求1： 查询线索(二级渠道jdsc)后续转化成交车型详情

大白话：看一下二级渠道jdsc，它下面的线索成交时，人家客户购买的都是什么车型

结合数据表分析
    线索和渠道 ———&gt; clue表
    成交购买的车型 ——&gt; order表

    需要进行clue表和order表的关联查询（使用内连接进行关联查询）

     条件：二级渠道jdsc
     返回结果：线索id 线索所属渠道名称 购买的车型
*/

-- 隐式内连接
SELECT
    c.clue_id,
    ca_n,
    chexing_id
FROM
    clue_day c,
    order_day o
WHERE
    c.clue_id = o.clue_id
    AND ca_n = &#39;jdsc&#39;;

-- 显式内连接
SELECT
    c.clue_id,
    ca_n,
    chexing_id
FROM
    clue_day c
    INNER JOIN order_day o ON c.clue_id = o.clue_id
WHERE
    ca_n = &#39;jdsc&#39;;
</code></pre><p>需求2：统计所有渠道（按照二级渠道）的转化率解析：</p>
<pre><code>#查询所有渠道的转化率 - 左外连接
SELECT
    c.ca_n,
    count(DISTINCT o.clue_id)/count(distinct c.clue_id) sale_rate
FROM
    clue_day c
    LEFT OUTER JOIN
    order_day o
    ON o.clue_id = c.clue_id
GROUP BY c.ca_n
order by sale_rate desc
limit 6;
</code></pre><p>需求3：查询各城市线索数并计算所有城市线索总数</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/377461/1598425472037-ac79a4ca-4d50-49d0-a2be-33a3e250ad6d.png#height=524&amp;width=249" alt=""></p>
<ul>
<li>解析：</li></ul>
<pre><code>关键词：城市 线索
    一个城市可以有多条线索
    各个城市的线索数分别是多少
    1 a
    2 b
    3 a
    4 a
    5 b
    6 c

    这里原来是一个分组聚合count统计(针对线索表clue_day单表的操作)
*/

select city_id,count(clue_id) as clue_count from clue_day group by city_id
union all
select &#39;总计&#39; as city_id,count(clue_id) clue_count from clue_day;
</code></pre><p>需求4：找出优质渠道，做重点投入</p>
<ul>
<li><p>我们对于优质渠道（以二级渠道来说）的定义：</p>
<ul>
<li><p>该二级渠道内平均转化周期&lt; 整体平均转化周期</p>
</li><li><p>该二级渠道的线索量 &gt; 各二级渠道平均线索量</p>
</li></ul>
</li><li><p>解析：</p>
<p>  with as 的用法(扩展)：如果一整句查询中多个子查询都需要使用同一个子查询的结果，那么我们就就建议用with，将共用的子查询用简写表示出来。</p>
</li></ul>
<pre><code>//找出优质渠道，做重点投入
//我们对于优质渠道（以二级渠道来说）的定义:
//该二级渠道内平均转化周期&lt; 整体平均转化周期
//该二级渠道的线索量 &gt; 各二级渠道平均线索量
/*
--针对《二级渠道内平均转化周期》和《二级渠道的线索量》的分析

转化周期：成单日期 — 线索创建日期
平均：avg
渠道线索量：分组 count统计
*/

-- 分组聚合（count/avg）
-- with as 在一个sql中提取公共的子查询出来（相当于一个表）

WITH ca_value AS (
    SELECT
        ca_n,
        avg( DATEDIFF( created_at, clue_created_at ) ) avg_time,
        count( o.clue_id ) clue_num
    FROM
        clue_day c
        LEFT JOIN order_day o ON c.clue_id = o.clue_id
    WHERE
        o.created_at IS NOT NULL
        AND c.clue_created_at IS NOT NULL
    GROUP BY
        ca_n
    ) SELECT
    ca_n,
    avg_time,
    clue_num
FROM
    ca_value
WHERE
    avg_time &lt; (-- 整体线索平均转化周期
    SELECT
        avg( DATEDIFF( created_at, clue_created_at ) )
    FROM
        clue_day c
        LEFT JOIN order_day o ON c.clue_id = o.clue_id
    WHERE
        o.created_at IS NOT NULL
        AND c.clue_created_at IS NOT NULL
    )
    AND
    clue_num &gt; (
        -- 二级渠道平均线索量（需要基于上面select查询进一步avg处理）
        SELECT ceil( avg( clue_num ) ) FROM ca_value
);
</code></pre><hr>
<h2 id="-7-mysql-">第7节  扩展—MySQL函数</h2>
<p>数学函数、字符串函数、日期时间函数、条件判断函数、系统信息函数</p>
<h3 id="7-1-">7.1. 数学函数</h3>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>FLOOR(x)向下取整 CEIL(X)向上取整</td>
<td>返回不大于x的最大整数值</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0～1的随机数</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x除以y以后的余数</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<pre><code>-- 系统信息函数 
select database(); 
select version(); 
select user();

-- 数学函数
select floor(5.9) as &#39;向下取整&#39;; 
select ceil(5.01) as &#39;向上取整&#39;


select round(5.419,2)  as &#39;四舍五入&#39;  -- 第二个数值是保留几位小数的意思


select rand();   -- 返回0-1之间的随机数
select pi();     -- 返回圆周率
select mod(5,2);  -- 求余数
</code></pre><p>举例：</p>
<ol>
<li>ABS(x)函数</li></ol>
<pre><code>SELECT ABS(-10) AS 绝对数;
</code></pre><ol>
<li>FLOOR(x)函数</li></ol>
<pre><code>SELECT FLOOR(5.9) AS 向下取整;
</code></pre><ol>
<li>RAND()</li></ol>
<pre><code>SELECT RAND() AS 随机数;
</code></pre><ol>
<li>PI()</li></ol>
<pre><code>SELECT PI() AS 圆周率;
</code></pre><p>5.MOD(X,Y)</p>
<pre><code>SELECT MOD(5,2) AS 对2取余数
#整除
a div b
</code></pre><h3 id="7-2-">7.2  字符串函数</h3>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT(s1,s2…)</td>
<td>将字符串拼接，连接为一个字符串</td>
</tr>
<tr>
<td>LEFT(s,n)</td>
<td>返回从字符串s开始的n最左字符</td>
</tr>
<tr>
<td>TRIM(s)</td>
<td>移除掉字串中s的字头或字尾处空格</td>
</tr>
<tr>
<td>REPLACE(s,s1,s2)</td>
<td>用字符串s2替代字符串s重的字符串s1</td>
</tr>
<tr>
<td>SUBSTRING(s,n,len)</td>
<td>截取字符串s中第n个位置开始，长度为len的字符串</td>
</tr>
<tr>
<td>MID(s,n.len)</td>
<td>同SUBSTRING(s,n,len)</td>
</tr>
<tr>
<td>REVERSE(s)</td>
<td>将字符串s的顺序翻转过来</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ol>
<li>CONCAT(s1,s2…)</li></ol>
<pre><code>SELECT CONCAT(&#39;la&#39;,&#39;gou&#39;) AS 字符串链接; 
concat(table.a,table.b) from table
</code></pre><ol>
<li>LEFT(s,n)</li></ol>
<pre><code>SELECT LEFT(&#39;lagou&#39;,2) AS le_sub #从左侧提取2位;
#la
select right(&#39;lagou&#39;,2) as ri_sub
#ou
select mid(&#39;lagou&#39;,2,3) as mid_sub
#ago
</code></pre><ol>
<li>TRIM(s)</li></ol>
<pre><code>SELECT TRIM(&#39; lagou &#39;) AS 去掉首尾空格;
</code></pre><ol>
<li>REPLACE(s,s1,s2)</li></ol>
<pre><code>SELECT REPLACE(&#39;lagou_jiaoyu&#39;,&#39;_&#39;,&#39;.&#39;) AS 字符串替换;
#lagou.jiaoyu
</code></pre><ol>
<li>SUBSTRING(s,n,len)  — 字符串截取</li></ol>
<pre><code>SELECT SUBSTRING(&#39;lagou_jiaoyu&#39;,7,6) AS SUBSTRING提取子串
,MID(&#39;lagou_jiaoyu&#39;,7,6) AS MID提取子串;
</code></pre><p>6.REVERSE(s)</p>
<pre><code>SELECT REVERSE(&#39;lagou&#39;) AS 字符串翻转;
</code></pre><h3 id="7-3-">7.3  日期和时间函数</h3>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>MONTH(d)</td>
<td>返回月份</td>
</tr>
<tr>
<td>YEAR(d)</td>
<td>返回年份</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ol>
<li>CURDATE()</li></ol>
<pre><code>SELECT CURDATE() AS 当前日期;
</code></pre><ol>
<li>CURTIME()</li></ol>
<pre><code>SELECT CURTIME() AS 当前时间;
</code></pre><ol>
<li>NOW()</li></ol>
<pre><code>SELECT NOW() AS 当前日期和时间;
</code></pre><h3 id="7-4-">7.4  条件判断函数</h3>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>IF(expo,v1,v2)</td>
<td>如果表达式成立，则执行v1，否则执行v2</td>
</tr>
<tr>
<td>CASE WHEN</td>
<td>用于计算条件列表并返回多个可能结果表达式之一</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ol>
<li>IF(expo,v1,v2)</li></ol>
<pre><code>SELECT IF(10&gt;5,10,5) as 最大值;

select if(10&gt;2,10,2);
select pname,if(price&gt;2000,&#39;奢侈品&#39;,&#39;普通商品&#39;) &#39;商品性质&#39; from products; 
select pname,if(price&gt;2000,price-1000,price) &#39;优惠后的价格&#39; from products;
</code></pre><ol>
<li>CASE WHEN</li></ol>
<pre><code>SELECT CASE WHEN 10&gt;5 THEN 10 ELSE 5 END AS 最大值;

case
when 条件1 then 结果1
when 条件2 then 结果2 when ... then 结果n
(else 结果n+1) end
</code></pre><h3 id="7-5-">7.5  系统信息函数</h3>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>VERSION()</td>
<td>返回数据库的版本号</td>
</tr>
<tr>
<td>DATABASES()</td>
<td>返回当前数据库名</td>
</tr>
<tr>
<td>USER()</td>
<td>返回当前用户名</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<ol>
<li>VERSION()</li></ol>
<pre><code>SELECT VERSION() as 数据库版本;
</code></pre><ol>
<li>DATABASES()</li></ol>
<pre><code>SELECT DATABASES() as 当前数据库名;
</code></pre><ol>
<li>USER()</li></ol>
<pre><code>SELECT USER() as    用户名;
</code></pre><hr>
<h1 id="-mysql-">第三部分 MySQL高级应用</h1>
<p>窗口函数、索引、视图</p>
<h2 id="-1-">第1节 窗口函数</h2>
<h3 id="1-1-">1.1  什么是窗口函数</h3>
<p>MySQL从8.0开始支持窗口函数，有的也叫<strong>分析函数（处理相对复杂的报表统计分析场景）</strong>，这个功能在大多商业数据库和部分开源数据库中早已支持。</p>
<p>窗口函数：窗口、函数（应用在窗口内的函数）——-窗口类似于窗户，限定一个空间范围那什么叫窗口呢?</p>
<p>窗口的概念非常重要，它可以理解为<strong>记录集合</strong>，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数。对于每条记录都要在此窗口内执行函数，窗口大小都是固定的，这种属于静态窗口；不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。</p>
<p>窗口函数的基本用法如下：</p>
<pre><code>函数名（[expr]） over子句

函数()  over()
</code></pre><p>其中，over是关键字，用来指定函数执行的窗口范围，包含三个分析子句：分组(partition by)子句，排序(order by)子句，窗口(rows)子句，如果后面括号中什么都不写，则意味着窗口包含满足where条件的所有行，窗口函数基于所有行进行计算；如果不为空，则支持以下语法来设置窗口：</p>
<pre><code>函数名（[expr]） over(partition by &lt;要分列的组&gt; order by &lt;要排序的列&gt; rows between &lt;数据范围&gt;)
</code></pre><ul>
<li>知识点总结</li></ul>
<pre><code>sum(...**A**...)  over(partition by ...**B**... order by ...**C**... rows between ...**D1**... and ...**D2**...)
avg(...**A**...)  over(partition by ...**B**... order by ...**C**... rows between ...**D1**... and ...**D2**...)

**A**: 需要被加工的字段名称
**B**: 分组的字段名称
**C**: 排序的字段名称
**D**: 计算的行数范围
</code></pre><pre><code>rows between 2 preceding and current row # 取当前行和前面两行

rows between unbounded preceding and current row # 包括本行和之前所有的行

rows between current row and unbounded following # 包括本行和之后所有的行

rows between 3 preceding and current row # 包括本行和前面三行

rows between 3 preceding and 1 following # 从前面三行和下面一行，总共五行

# 当order by后面缺少窗口从句条件，窗口规范默认是rows between unbounded
preceding and current row.

# 当order by和窗口从句都缺失, 窗口规范默认是 rows between unbounded preceding
and unbounded following
</code></pre><h3 id="1-2-">1.2  窗口函数应用</h3>
<p>一般，我们可以把窗口函数分为两种：</p>
<ul>
<li><p>专有窗口函数：</p>
<ul>
<li>rank() </li><li>dense_rank() </li><li>row_number()</li></ul>
</li><li><p>聚合类窗口函数：</p>
<p>  普通场景下，聚合函数往往和group by一起使用，但是窗口环境下，聚合函数也可以应用进来，那么此时它们就被称之为聚合类窗口函数，属于窗口函数的一种</p>
<ul>
<li>sum() </li><li>count() </li><li>avg()</li><li>max()</li><li>min()</li></ul>
</li></ul>
<p>窗口函数（专有窗口函数+聚合类窗口函数）和普通场景下的聚合函数也很容易混淆，二者区别如下：</p>
<ul>
<li><p>普通场景下的聚合函数是将多条记录聚合为一条<strong>（多到一）</strong>；窗口函数是每条记录都会执行，有几条记录执行完还是几条<strong>（多到多）</strong>。</p>
</li><li><p>分组(partition by)：记录按照字段进行分组，窗口函数在不同的分组上分别执行。</p>
</li><li><p>排序(order by)：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号，可以和partition子句配合使用，也可以单独使用。如果没有partition子句，数据范围则是整个表的数据行。</p>
</li><li><p>窗口(rows)：就是进行函数分析时要处理的数据范围，属于当前分区的一个子集，通常用来作为滑动窗口使用。比如要根据每个订单动态计算包括本订单和按时间顺序前后两个订单的移动平均支付金额，则可以设置rows子句来创建滑动窗口(rows)。</p>
</li></ul>
<p>现有2018～2020某电商平台订单信息表user_trade表结构如下:</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>释义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>user_name</td>
<td>用户名</td>
</tr>
<tr>
<td>piece</td>
<td>购买数量</td>
</tr>
<tr>
<td>price</td>
<td>价格</td>
</tr>
<tr>
<td>pay_amount</td>
<td>支付金额</td>
</tr>
<tr>
<td>goods_category</td>
<td>商品品类</td>
</tr>
<tr>
<td>pay_time</td>
<td>支付日期</td>
</tr>
</tbody>
</table>
<pre><code># 建立数据表
use lagou;
create table user_trade
(
    user_name   varchar(20), piece   int,
    price   double, 
    pay_amount  double,
    goods_category  varchar(20), 
    pay_time    date
);
</code></pre><p>数据前10行如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.jpg" alt=""></p>
<p>navicat导入数据：D:/course/mysql/资料/窗口函数数据/user_trade.xlsx</p>
<p>———累计计算函数应用、排序函数应用、偏移分析函数应用</p>
<h4 id="1-2-1-">1.2.1   累计计算函数</h4>
<p><strong>累计求和：sum() over()</strong></p>
<pre><code>需求1: 查询出2019年每月的支付总额和当年累积支付总额
/*
需求1: 查询出2019年每月的支付总额和当年累积支付总额
*/

-- step1 过滤出2019年数据
select * from user_trade where year(pay_time)=2019;

-- step2 在1的基础上，按照月份进行group by 分组，统计每个月份的支付总额
SELECT MONTH
    ( pay_time ),
    sum( pay_amount )
FROM
    user_trade
WHERE
    YEAR ( pay_time ) = 2019
GROUP BY
    MONTH ( pay_time );

-- step3 在2的基础上应用窗口函数实现需求
SELECT
    a.MONTH,-- 月份
    a.pay_amount,-- 当月总支付金额
    sum( a.pay_amount ) over ( ORDER BY a.MONTH ) -- 就是2019年的数据，所以不用分组
-- --此时没有使用rows指定窗口数据范围，默认当前行及其之前的所有行

FROM
    (
    SELECT MONTH
    ( pay_time ) MONTH,
    sum( pay_amount ) pay_amount
FROM
    user_trade
WHERE
    YEAR ( pay_time ) = 2019
GROUP BY
    MONTH ( pay_time )
    ) a
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425472158-cf06cba5-d8bd-4e0a-a5f3-cfe48499fa10.jpeg#height=193&amp;width=302" alt=""></p>
<pre><code>需求2：查询出2018-2019年每月的支付总额和当年累积支付总额

SELECT a.year,
    a.month,
    a.pay_amount,
      sum(a.pay_amount) over(partition by a.year order by a.month)
FROM
    (SELECT year(pay_time) year,
        month(pay_time) month,
        sum(pay_amount) pay_amount
    FROM user_trade
    WHERE year(pay_time) in (2018,2019)
    GROUP BY year(pay_time),
        month(pay_time))a;
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425472317-9a4e0cb8-b395-4d05-9c43-fb07fe701c7d.jpeg#height=360&amp;width=419" alt=""></p>
<ul>
<li>移动平均：avg() over()</li></ul>
<pre><code>需求3: 查询出2019年每个月的近三月移动平均支付金额

SELECT a.month,
    a.pay_amount,
    avg(a.pay_amount) over(order by a.month rows between 2 preceding
and current row)
FROM
    (SELECT month(pay_time) month,
        sum(pay_amount) pay_amount
    FROM user_trade
    WHERE year(pay_time)=2019
    GROUP BY month(pay_time))a;
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425472476-a857f70a-dcb6-44ee-afe5-34dccb684a4a.jpeg#height=180&amp;width=445" alt=""></p>
<ul>
<li>最大/小值：max()/min() over()</li></ul>
<pre><code>需求4: 查询出每四个月的最大月总支付金额

SELECT a.month,
    a.pay_amount,
    max(a.pay_amount) over(order by a.month rows between 3 preceding
and current row)
FROM
    (SELECT substr(pay_time,1,7) as month,
        sum(pay_amount) as pay_amount
    FROM user_trade
    GROUP BY substr(pay_time,1,7))a;
</code></pre><p>结果如下；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425472758-f547ec31-c1a3-4782-ae83-18b67df70f67.jpeg#height=385&amp;width=439" alt=""></p>
<h4 id="1-2-2-">1.2.2   排序函数</h4>
<ul>
<li>row_number() over(……)</li></ul>
<ul>
<li>rank() over(……)</li></ul>
<ul>
<li>dense_rank() over(……)</li></ul>
<pre><code>需求5: 2020年1月，购买商品品类数的用户排名

/*
需求5: 2020年1月，购买商品品类数的用户排名

2020年1月（基础数据范围）

一个商品属于某一个品类
A用户购买了100件商品，那么可能涉及到了10个品类
B用户购买了50件商品，那么可能涉及到了15个品类

根据所购买商品涉及的品类数量进行排名（给用户）

思路：
1）先把各个用户所购买商品涉及的品类数给统计出来
2) 在1的基础上排名，使count()用到排名窗口函数
*/

-- 1）先把各个用户所购买商品涉及的品类数给统计出来
SELECT
    user_name,
    count( DISTINCT goods_category ) category_count,
    row_number() over(order by count( DISTINCT goods_category ) ) order1,
-- row_number生成了行的编号从1开始
    rank() over(order by count( DISTINCT goods_category ) ) order2,
    dense_rank() over(order by count( DISTINCT goods_category ) ) order3
FROM
    user_trade
WHERE
    substring( pay_time, 1, 7 ) = &#39;2020-01&#39;
GROUP BY
    user_name;
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/paixu.jpg" alt=""></p>
<ul>
<li>知识点总结</li></ul>
<p>这三个函数的作用都是返回相应规则的排序序号</p>
<p>row_number()  over(partition by …<strong>A</strong>… order by …<strong>B</strong>… )</p>
<p>rank()  over(partition by …<strong>A</strong>… order by …<strong>B</strong>… )</p>
<p>dense_rank()  over(partition by …<strong>A</strong>… order by …<strong>B</strong>… )</p>
<p><strong>A</strong>:分组的字段名称<br><strong>B</strong>:排序的字段名称</p>
<p>注意:row_number()、rank() 和dense_rank()紧邻的括号内是不加任何字段名称的。</p>
<p><strong>row_number</strong>:它会为查询出来的每一行记录生成一个序号，依次排序且不会重复。</p>
<p><strong>rank&amp;dense_rank</strong>:如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一。</p>
<p>dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。</p>
<p>dense_rank函数 出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。</p>
<p>在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第三名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。</p>
<ul>
<li>ntile(n) over(……)</li></ul>
<pre><code>需求6: 查询出将2020年2月的支付用户，按照支付金额分成5组后的结果

SELECT user_name,
    sum(pay_amount) pay_amount,
    ntile(5) over(order by sum(pay_amount) desc) level
FROM user_trade
WHERE substr(pay_time,1,7)=&#39;2020-02&#39;
GROUP BY user_name;
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/ntile1.jpg" alt=""></p>
<pre><code>需求7: 查询出2020年支付金额排名前30%的所有用户

SELECT a.user_name,
        a.pay_amount,
        a.level
FROM
        (SELECT user_name,
                sum(pay_amount) pay_amount,
                ntile(10) over(order by sum(pay_amount) desc) level
        FROM user_trade
        WHERE year(pay_time)=2020
        GROUP BY user_name)a
WHERE a.level in (1,2,3);
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/ntile2.jpg" alt=""></p>
<ul>
<li>知识点总结</li></ul>
<p>ntile(<strong>n</strong>) over(partition by …<strong>A</strong>… order by …<strong>B</strong>… )</p>
<p><strong>n</strong>:切分的片数</p>
<p><strong>A</strong>:分组的字段名称</p>
<p><strong>B</strong>:排序的字段名称</p>
<p>ntile(<strong>n</strong>)，用于将分组数据按照顺序切分成n片，返回当前切片值</p>
<p>NTILE不支持ROWS BETWEEN，</p>
<h4 id="1-2-3-">1.2.3   偏移分析函数</h4>
<ul>
<li><p>lag(…) over(……)</p>
</li><li><p>lead(…) over(……)</p>
</li></ul>
<pre><code>需求8: 查询出King和West的时间偏移(前N行)

SELECT user_name,
    pay_time,
    lag(pay_time,1,pay_time) over(partition by user_name order by pay_time) lag1,
    -- 没有传入偏移量，那么默认就是1，找不到的话，此处也没有给默认值，为null
    lag(pay_time) over(partition by user_name order by pay_time) lag1_s,
    lag(pay_time,2,pay_time) over(partition by user_name order by pay_time) lag2,
    lag(pay_time,2) over(partition by user_name order by pay_time) lag2_s
FROM user_trade
WHERE user_name in (&#39;King&#39;,&#39;West&#39;);
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/%E5%81%8F%E7%A7%BB%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B01.jpg" alt=""></p>
<pre><code>需求9: King和West的时间偏移(后N行)

SELECT user_name,
    pay_time,
    lead(pay_time,1,pay_time) over(partition by user_name order by pay_time) lead1,
    lead(pay_time) over(partition by user_name order by pay_time) lead2,
    lead(pay_time,2,pay_time) over(partition by user_name order by pay_time) lead3,
    lead(pay_time,2) over(partition by user_name order by pay_time) lead4
FROM user_trade
WHERE user_name in (&#39;King&#39;,&#39;West&#39;);
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/%E5%81%8F%E7%A7%BB%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B02.jpg" alt=""></p>
<ul>
<li>知识点总结</li></ul>
<p><strong>Lag</strong>和<strong>Lead</strong>函数可以在同一次查询中取出同一字段的前<strong>N</strong>行的数据<strong>(Lag)</strong>和后<strong>N</strong>行的数据<strong>(Lead)</strong>作为独立的列。</p>
<p>在实际应用当中，若要用到取今天和昨天的某字段差值时，Lag和Lead函数的应用就显得尤为重要。</p>
<p><strong>lag(exp_str,oﬀset,defval) over(partion by ……order by ……) </strong><br><strong>lead(exp_str,oﬀset,defval) over(partion by ……order by ……)</strong></p>
<p>exp_str是字段名称。 oﬀset是偏移量，即是上1个或上N个的值，假设当前行在表中排在第5行，则oﬀset 为3，则表示我 们所要找的数据行就是表中的第2行(即5-3=2)。oﬀset默认值为1。</p>
<p>defval默认值，当两个函数取上N/下N个值，当在表中从当前行位置向前数N行已经超出了表的范 围时，lag()函数将defval这个参数值作为函数的返回值，若没有指定默认值，则返回NULL，那么 在数学运算中，总要给一个默认值才不会出错。</p>
<ul>
<li>补充练习：</li></ul>
<pre><code>需求10: 查询出支付时间间隔超过100天的用户数

SELECT count(distinct user_name) 
FROM
    (SELECT user_name,
        pay_time,
        lead(pay_time) over(partition by user_name order by pay_time) lead_dt
    FROM user_trade)a 
WHERE a.lead_dt is not null
and datediff(a.lead_dt,a.pay_time)&gt;100;
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/%E6%9F%A5%E8%AF%A2%E5%87%BA%E6%94%AF%E4%BB%98%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E8%B6%85%E8%BF%87100%E5%A4%A9%E7%9A%84%E7%94%A8%E6%88%B7%E6%95%B0.jpg" alt=""></p>
<pre><code>需求11: 查询出每年支付时间间隔最长的用户

SELECT
    years, 
    b.user_name, 
    b.pay_days
FROM
    (SELECT
        years, 
        a.user_name,
        datediff(a.pay_time,a.lag_dt) pay_days, 
        rank() over(partition by years order by
datediff(a.pay_time,a.lag_dt) desc) rank1 
    FROM
        (SELECT
            year(pay_time) as years, 
            user_name,
            pay_time,
            lag(pay_time) over(partition by user_name,year(pay_time) order by pay_time) lag_dt
        FROM user_trade)a
    WHERE a.lag_dt is not null)b WHERE b.rank1=1;
</code></pre><p>结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/377461/1598425472971-b08cdaaf-6bad-4625-a767-229639047c63.jpeg#height=83&amp;width=178" alt=""></p>
<hr>
<h2 id="-2-mysql-">第2节 MySQL索引</h2>
<h3 id="2-1-">2.1  什么是索引</h3>
<p>索引可以提升查询速度，会影响where条件查询（where xxx=’’），order by（order by yyy）排序</p>
<p>索引是针对字段的，需要添加到字段上索引在大量数据场景下效果明显</p>
<h3 id="2-2-">2.2  常见索引分类</h3>
<p>从索引的存储结构划分：B Tree索引、Hash索引、fulltext全文索引、R Tree索引（了解）</p>
<p><strong>从应用层次划分：主键索引、唯一索引、普通索引、复合索引</strong></p>
<p>从索引的键值（字段）类型划分：主键索引、辅助索引（二级索引）</p>
<p>从索引数据和内容数据逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）</p>
<table>
<thead>
<tr>
<th><strong>索引名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引 (primary key)</td>
<td>主键是一种唯一性索引,每个表只能有一个主键, 用于标识数据表中的每一条记录</td>
</tr>
<tr>
<td>唯一索引 (unique)</td>
<td>唯一索引指的是 索引列的所有值都只能出现一次, 必须唯一.</td>
</tr>
<tr>
<td>普通索引 (index)</td>
<td>最常见的索引,作用就是 加快对数据的访问速度</td>
</tr>
</tbody>
</table>
<h4 id="2-2-1-primary-key-">2.2.1   主键索引 (PRIMARY KEY)</h4>
<p>一个表可以没有主键，但最多只能有一个主键，并且主键值不能包含NULL。</p>
<p><strong>添加主键的时候会自动创建主键索引，主键索引是一种唯一性索引</strong></p>
<p>根据主键进行where条件查询，效率高</p>
<p>1) 语法格式</p>
<ul>
<li>创建表的时候直接添加主键索引 (就是添加主键的方式，最常用)</li></ul>
<pre><code>CREATE TABLE test_index( 
    did INT primary key, 
    dname VARCHAR(20),
    hobby VARCHAR(30)
);
</code></pre><ul>
<li>修改表结构 添加主键索引</li></ul>
<pre><code>ALTER TABLE 表名 ADD PRIMARY KEY ( 列名 )
# 示例
ALTER TABLE test_index ADD PRIMARY KEY (did);
</code></pre><h4 id="2-2-2-unique-">2.2.2   唯一索引(UNIQUE)（了解）</h4>
<p><strong>特点: 索引列的所有值都只能出现一次, 必须唯一.</strong></p>
<p>唯一索引可以保证数据记录的唯一性。</p>
<p>事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p>
<p>1)  语法格式</p>
<ul>
<li>创建表的时候直接添加唯一索引</li></ul>
<pre><code>CREATE TABLE 表名(
    列名 类型(长度),
    -- 添加唯一索引
    UNIQUE [索引名称] (列名)
);
</code></pre><ul>
<li>使用create语句创建: 在已有的表上创建索引</li></ul>
<pre><code>create unique index 索引名 on 表名(列名(长度))
create unique index index_dname on test_index(dname);
</code></pre><ul>
<li>修改表结构添加索引</li></ul>
<pre><code>ALTER TABLE 表名 ADD UNIQUE 索引名( 列名 )
</code></pre><p>2)  向表中插入数据</p>
<pre><code>#为 hobby字段添加唯一索引
create unique index ind_hobby on demo01(hobby)

INSERT INTO test_index VALUES(1,&#39;张三&#39;,&#39;DBJ&#39;);

# 报错Duplicate entry &#39;DBJ&#39; for key &#39;hobby&#39;
# 唯一索引保证了数据的唯一性,索引的效率也提升了
INSERT INTO test_index VALUES(2,&#39;李四&#39;,&#39;DBJ&#39;);
</code></pre><h4 id="2-2-3-normal-index-">2.2.3   普通索引 (NORMAL INDEX)</h4>
<p>普通索引的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column=）或排序条件（ORDER BY column）中的数据列创建索引。</p>
<p>普通索引对数据没有唯一、非空的强制要求</p>
<p>1)  语法格式</p>
<p>使用create index 语句创建: 在已有的表上创建索引</p>
<pre><code>create index 索引名 on 表名(列名[长度])
</code></pre><p>修改表结构添加索引</p>
<pre><code>ALTER TABLE f ADD INDEX 索引名 (列名)
#给 dname字段添加索引
alter table test_index add index dname_indx(dname);
</code></pre><h4 id="2-2-4-">2.2.4   删除索引</h4>
<p>由于索引会占用一定的磁盘空间，因此，为了避免影响数据库的性能，应该及时删除不再使用的索引</p>
<p>1)  语法格式</p>
<pre><code>ALTER  TABLE  table_name   DROP  INDEX  index_name;
</code></pre><p>2)  删除  test_index 表中名为  dname_indx 的普通索引。</p>
<pre><code>ALTER TABLE test_index DROP INDEX dname_indx;
</code></pre><h3 id="2-3-">2.3  索引的优缺点总结</h3>
<ul>
<li>索引的优点<ol>
<li>大大的提高查询速度</li><li>可以显著的减少查询和排序的时间。</li></ol>
</li></ul>
<ul>
<li><p>索引的缺点</p>
<p>  当对表中的数据进行增加，修改，删除的时候，索引要同时进行维护，数据量越大维护时间越长</p>
</li></ul>
<hr>
<h2 id="-3-mysql-">第3节 MySQL 视图</h2>
<h3 id="3-1-">3.1  什么是视图</h3>
<ol>
<li>视图是一种虚拟表。</li><li>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。</li><li>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句.</li><li>视图向用户提供基表数据的另一种表现形式</li></ol>
<h3 id="3-2-">3.2  视图的作用</h3>
<ul>
<li><p>权限控制时可以使用</p>
<ul>
<li>比如,某几个列可以运行用户查询,其他列不允许,可以开通视图 查询特定的列, 起到权限控制的作用</li></ul>
</li><li><p>简化复杂的多表查询</p>
<ul>
<li><p>视图 本身就是一条查询SQL,我们可以将一次复杂的查询 构建成一张视图, 用户只要查询视图就可以获取想要得到的信息(不需要再编写复杂的SQL)</p>
</li><li><p>视图主要就是为了简化多表的查询</p>
</li></ul>
</li></ul>
<h3 id="3-3-">3.3  视图的使用</h3>
<h4 id="3-3-1-">3.3.1   创建视图</h4>
<p>1)  语法格式</p>
<pre><code>create view 视图名 [column_list] as select语句;

view: 表示视图
column_list: 可选参数， 表示属性清单， 指定视图中各个属性的名称， 默认情况下， 与
SELECT语句中查询的属性相同 as : 表示视图要执行的操作
select语句: 向视图提供数据内容
</code></pre><p>2)  创建一张视图</p>
<pre><code>#1. 先编写查询语句
#查询所有商品 和 商品的对应分类信息
SELECT   FROM products p LEFT JOIN category c ON p.`category_id` = c.`cid`;

#2.基于上面的查询语句,创建一张视图 CREATE VIEW products_category_view
AS SELECT   FROM products p LEFT JOIN category c ON p.`category_id` = c.`cid`;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/chuangjian.jpg" alt=""></p>
<p>3)  查询视图 ,当做一张只读的表操作就可以</p>
<pre><code>SELECT   FROM products_category_view;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE.jpg" alt=""></p>
<h4 id="3-3-2-">3.3.2   通过视图进行查询</h4>
<p>1)  需求: 查询各个分类下的商品平均价格</p>
<pre><code>#通过 多表查询
SELECT
    cname AS &#39;分类名称&#39;,
    AVG(p.`price`) AS &#39;平均价格&#39;

FROM products p LEFT JOIN category c ON p.`category_id` = c.`cid`
GROUP BY c.`cname`;

# 通过视图查询 可以省略连表的操作
SELECT
    cname AS &#39;分类名称&#39;,
    AVG(price) AS &#39;平均价格&#39;
FROM products_category_view GROUP BY cname;
</code></pre><p>2)  需求:  查询鞋服分类下最贵的商品的全部信息</p>
<pre><code>#通过连表查询
#1.先求出鞋服分类下的最高商品价格 
SELECT
    MAX(price) AS maxPrice 
FROM
products p LEFT JOIN category c ON p.`category_id` = c.`cid` 
WHERE c.`cname` = &#39;鞋服&#39;

#2.将上面的查询 作为条件使用
SELECT   FROM products p LEFT JOIN category c ON p.`category_id` = c.`cid` 
WHERE c.`cname` = &#39;鞋服&#39; AND p.`price` =
(SELECT
    MAX(price) AS maxPrice 
FROM
products p LEFT JOIN category c ON p.`category_id` = c.`cid` 
WHERE c.`cname` = &#39;鞋服&#39;); |
</code></pre><h3 id="3-4-">3.4 视图与表的区别</h3>
<p>视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示</p>
<p>通过视图不能改变表中数据（一般情况下视图中的数据都是表中的列 经过计算得到的结果,不允许更新）</p>
<p>删除视图，表不受影响，而删除表，视图不再起作用</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
