<!DOCTYPE html>
<html>
<head>
<title>MySql</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
@charset "UTF-8";

/*** Custom fonts ***/
@import url('./blubook/fonts.css');

/*** Color setting ***/
:root {
    --side-bar-bg-color: #183055;
    --active-file-bg-color: #2f4566;
    --active-file-text-color: #ffffff;
    --active-file-border-color: #757575;
    --active-search-item-bg-color: #23242b;
    --item-hover-bg-color: #ececec;
    --item-hover-text-color: #f5f7f9;
    --control-text-color: #ddd;
    --window-border: 1px solid #183055;
    --code-cursor: #f0f0f0;
}


/****** #write basic ******/
#write {
    position: static;
    width: 90%;
    max-width: 700px;
    line-height: 1.6;
    transform: none;
    height: auto;
}

/****** #write h1-h6 ******/
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre {
    width: auto;
  }
  
#write h1::before, #write h2::before, #write h3::before, #write h4::before, #write h5::before, #write h6::before {
  position: absolute;
  right: calc(100% + 10px);
  bottom: 0;
  color: #b4b4b4;
  font-size: 1rem;
  font-weight: bold;
  font-variant: 'small-caps';
  border: 0;
  border-radius: 0;
  left: auto;
  float: none;
  padding: 0;
  vertical-align: baseline;
  line-height: 2;
}

#write h1 {
  font-size: 32px;
  font-style: normal;
  font-weight: 800;
  line-height: 2;
  margin-top: 14px;
  margin-bottom: 14px;
}

#write h1::before {
  content: 'H1';
  bottom: 1rem;
}

#write h2 {
  font-size: 28px;
  font-weight: 800;
  font-style: normal;
  line-height: 2;
  margin-top: 14px;
  margin-bottom: 14px;
}

#write h2::before {
  content: 'H2';
  bottom: .85rem;
}

#write h3 {
  font-size: 24px;
  font-weight: 800;
  line-height: 2;
  font-style: normal;
  margin-top: 14px;
  margin-bottom: 14px;
}

#write h3::before {
  content: 'H3';
  bottom: .55rem;
}

#write h4 {
  font-size: 20px;
  font-weight: 800;
  line-height: 2;
  font-style: normal;
  margin-top: 14px;
  margin-bottom: 14px;
}

#write h4::before {
  content: 'H4';
  bottom: .35rem;
}

#write h5, #write h6 {
  font-size: 16px;
  font-weight: 800;
  line-height: 2;
  font-style: normal;
  margin-top: 14px;
  margin-bottom: 14px;
}

#write h5::before, #write h6::before {
  bottom: .1rem;
}

#write h5::before {
  content: 'H5';
}

#write h6::before {
  content: 'H6';
}

/****** Global Style ******/
body {
  margin: 0;
  font-family: "Glow Sans SC", -apple-system, sans-serif;
  font-weight: 500;
  text-rendering: geometricPrecision;
  -webkit-font-smoothing: antialiased;
  -webkit-text-size-adjust: 100%
}

html, 
body {
  color: #242A31;
  /* width: 100%; */
  height: 100%;
  margin: 0;
  padding: 0;
  font-size: 15px;
  background: #ffffff;
  box-sizing: border-box;
  line-height: 1em;
  text-size-adjust: 100%;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
} 

hr {
  border-color: #e6ecf1;
  height: 2px;
  border-top: 2px solid #e6ecf1;
}

img {
  max-width: 80%;
  margin-top: 0.2em;
  margin-bottom: 0.2em;
}

/****** ul ol Style ******/

ul>li>ul>li {
  list-style-type: circle;
}

ul>li>ul>li>ul>li {
  list-style-type: square;
}

ol,
ul {
  padding-left: 2em;
  line-height: 2;
}

ol>li {
  list-style-type: decimal
}

ol>li>ol>li {
  list-style-type: lower-alpha
}

ol>li>ol>li>ol>li {
  list-style-type: lower-roman
}

/****** Table Style ******/

table {
  padding: 0;
  word-break: initial;
}

table tr {
  border-top: 1px solid #dfe2e5;
  margin: 0;
  padding: 0;
}
table tr:nth-child(2n),
thead {
  background-color: #f5f7f9;
}
table tr th {
  font-weight: bold;
  border: 1px solid #dfe2e5;
  border-bottom: 0;
  margin: 0;
  padding: 6px 13px;
}
table tr td {
  border: 1px solid #dfe2e5;
  margin: 0;
  padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
  margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
  margin-bottom: 0;
}


/****** YAML Style ******/
pre.md-meta-block {
  font-size: .75rem !important;
  color: #5d5d5d;
  min-height: .8rem;
  white-space: pre-wrap;
  background: #f5f7f9;
  display: block;
  overflow-x: hidden;
  padding: 1rem;
  border-radius: 8px;
}



/****** Global Text ******/
p {
  font-size: 16px;
  font-family: "Glow Sans SC", -apple-system, sans-serif;
  font-weight: 500;
  line-height: 1.6;
  font-style: normal;
  color: rgb(59, 69, 78);
}

a {
  /* color: rgb(164, 78, 237); */
  color: rgb(56, 132, 254);
  font-weight: 500;
  text-decoration: none;
  text-decoration-style: none;
  cursor: pointer;
  padding: 0 3px 0 3px;
}

#write a:hover {
  color: rgb(56, 132, 254);
  text-decoration: underline;
  text-decoration-style: solid;
}

strong {
  font-weight: 700;
}

h1 {
  font-size: 2rem;
  font-style: normal;
  font-weight: 800;
  line-height: 2;
  margin-top: 14px;
  margin-bottom: 14px;
}

h2 {
  font-size: 1.8px;
  font-weight: 800;
  font-style: normal;
  line-height: 2;
  margin-top: 14px;
  margin-bottom: 14px;
}

h3 {
  font-size: 1.6px;
  font-weight: 800;
  line-height: 2;
  font-style: normal;
  margin-top: 14px;
  margin-bottom: 14px;
}

h4 {
  font-size: 1.2px;
  font-weight: 800;
  line-height: 2;
  font-style: normal;
  margin-top: 14px;
  margin-bottom: 14px;
}

h5,  h6 {
  font-size: 1rem;
  font-weight: 800;
  line-height: 2;
  font-style: normal;
  margin-top: 14px;
  margin-bottom: 14px;
}


/****** #write Code Fences ******/
#write .md-fences {
    -webkit-font-smoothing: initial;
    margin: 1.8rem 0 2rem 0 !important;
    line-height: 1.43rem;
    border-radius: 3px;
    font-size: 0.95rem;
    word-wrap: normal;
}


#write .CodeMirror-wrap .CodeMirror-code pre {
    padding-left: 12px;
    line-height: 1.55rem;
}
  
#write .CodeMirror-cursors .CodeMirror-cursor {
    border-left: 2px solid var(--code-cursor);
}
  
#write code,
  tt {
    margin: 0 2px;
    padding: 4px 6px;
    border-radius: 6px;
    font-size: 0.92rem;
    background: #f5f7f9;
}
  
#write .md-footnote {
    color: var(--main-5);
    background-color: var(--main-1);
}

.cm-s-inner.CodeMirror, .cm-s-inner .CodeMirror-gutters {
  padding: 0.75rem 0.15rem 0.75rem 0.15rem;
  background-color: #183055 !important;
  color: #f8f8f2 !important;
  border: none;
  border-radius: 6px;
}


.code-tooltip {
  box-shadow: 0 1px 1px 0 rgba(0, 28, 36, .3);
  border-top: 1px solid #eef2f2;
  background: #183055;
  border-radius: 6px;
}

.md-fences {
  font-size: .9rem;
  position: relative!important;
  display: block;
  page-break-inside: avoid;
  text-align: left;
  overflow: visible;
  white-space: pre;
  background: inherit;
}

.md-fences {
  background-color: #f8f8f8;
  margin-bottom: 15px;
  margin-top: 15px;
  padding-top: 8px;
  padding-bottom: 6px;
}

.md-fences, tt {
  border-radius: 3px;
  color: #f0f0f0;
  padding: 0;
  font-size: 0.9em;
}

/****** Sidebar ******/
#typora-sidebar * {
  color: #f0f0f0;
}

#typora-sidebar .file-tree-node.file-library-file-node.active .file-node-background {
  border-left: 5px solid #3884ff;
  height: 2.6rem;
}

.file-list-item {
  border-bottom: var(--window-border);
}

.file-list-item {
  overflow: hidden;
  padding: 12px;
  border-bottom: 1px solid #eee;
  border-bottom: var(--window-border);
  cursor: pointer;
  padding-right: 8px;
  padding-top: 12px;
  padding-left: 24px;
  transition: top .5s;
  -webkit-transition: top .5s;
}

.file-list-item.active {
  background: #2f4566;
  /* background: var(--active-file-bg-color); */
  color: var(--active-file-text-color);
  border-radius: 12px;
}

.file-list-item:not(.active) {
  opacity: .9;
}

.file-node-content {
  padding-top: .8rem;
  margin-bottom: .8rem;
  cursor: default;
  color: var(--control-text-color);
  white-space: nowrap;
  height: 2rem;
}

.file-node-content:active {
  border-radius: 0px!important;
  background: #2f4566;
}

.active .file-node-content {
  font-weight: bold;
}

.file-node-content:hover {
  cursor: pointer;
  border-radius: 0px!important;
}

.file-node-icon, .file-node-open-state {
  display: block;
  float: left;
  line-height: 15px;
  min-height: 15px;
}

.file-node-icon {
  margin-right: 6px;
}

.sidebar-footer {
background: var(--side-bar-bg-color);
border-top: 1px #555 solid;
}

#typora-sidebar #ty-sidebar-footer .sidebar-footer-item:hover {
background: #021d43;
}

#typora-sidebar #outline-content .outline-item:hover {
background: #202020;
}

#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .show + .menuitem-group-label.show {
border-color: #202020;
}

#typora-sidebar #ty-sidebar-footer {
border-top: 1px solid #19191c;
}

#typora-sidebar #ty-sidebar-footer #sidebar-files-menu li > a:hover {
background: #021d43;
}

#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn.active, #typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn:hover {
color: #3884FF;
}

#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn.active {
background: #001129;
}

#typora-sidebar .file-list-item.file-library-node:not(.active):hover {
  background: #243959;
  border-radius: 12px;
}

#typora-sidebar .file-tree-node.file-library-file-node:not(.active):hover .file-node-background {
  background: #243959;
  border-radius: 12px;
  height: 2.6rem;
}

/****** Quote style ******/
blockquote {
    position: relative;
  /*  margin: 1rem 1 1rem 2rem; */
    padding: 1rem;
    color: #827676;
    background-color: #f5f7f9;
    border-radius: 6px;
    line-height: 1;
}
  
blockquote::before {
    content: '';
    position: absolute;
    top: 0rem;
    left: 0rem;
    height: 100%;
    width: .30rem;
    background: #3884ff;
    border-top-left-radius: 6px;
    border-bottom-left-radius: 6px;
}



/****** Code style ******/
code {
    font-size:0.9em; 
    color: #1980ff; /*  #537AA2;  
    border: 1px solid #d0d0d0;  */
    font-family: 'Cascadia Code', Consolas, 'Noto Sans SC','Courier New', monospace;
    padding: .2em .2em;
    border-radius: 3px;
    background: #f5f7f9 !important;
}
  
code,
pre{
    font-size: 90% !important;
    font-weight: normal;
    font-family: 'Cascadia Code', Consolas, 'Noto Sans SC','Courier New', monospace;
    -webkit-font-smoothing: initial;
    -moz-osx-font-smoothing: initial
}

/****** Code highlight ******/
.cm-s-inner .CodeMirror-guttermarker, .cm-s-inner .CodeMirror-guttermarker-subtle, .cm-s-inner .CodeMirror-linenumber { color: #596774; }
.cm-s-inner .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }
.cm-s-inner div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }
.cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }
.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line > span::selection, .cm-s-inner .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }
.cm-s-inner .CodeMirror-line::-moz-selection, .cm-s-inner .CodeMirror-line > span::-moz-selection, .cm-s-inner .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }

.cm-s-inner .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }
.cm-s-inner .cm-keyword { color: rgba(199, 146, 234, 1); }
.cm-s-inner .cm-operator { color: rgba(233, 237, 237, 1); }
.cm-s-inner .cm-variable-2 { color: #80CBC4; }
.cm-s-inner .cm-variable-3 { color: #82B1FF; }
.cm-s-inner .cm-builtin { color: #DECB6B; }
.cm-s-inner .cm-atom { color: #F77669; }
.cm-s-inner .cm-number { color: #F77669; }
.cm-s-inner .cm-def { color: rgba(233, 237, 237, 1); }
.cm-s-inner .cm-string { color: #C3E88D; }
.cm-s-inner .cm-string-2 { color: #80CBC4; }
.cm-s-inner .cm-comment { color: #546E7A; }
.cm-s-inner .cm-variable { color: #82B1FF; }
.cm-s-inner .cm-tag { color: #80CBC4; }
.cm-s-inner .cm-meta { color: #80CBC4; }
.cm-s-inner .cm-attribute { color: #FFCB6B; }
.cm-s-inner .cm-property { color: #80CBAE; }
.cm-s-inner .cm-qualifier { color: #DECB6B; }
.cm-s-inner .cm-variable-3 { color: #DECB6B; }
.cm-s-inner .cm-tag { color: rgba(255, 83, 112, 1); }
.cm-s-inner .cm-error {
  color: rgba(255, 255, 255, 1.0);
  background-color: #EC5F67;
}
.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}

.md-fences .code-tooltip {
  background-color: #263238;
}


</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<!-- 声明文档使用的字符编码 -->
    <meta charset='utf-8'>
    <!-- 优先使用 IE 最新版本和 Chrome -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <!-- 页面描述 -->
    <meta name="description" content="不超过150个字符"/>
    <!-- 页面关键词 -->
    <meta name="keywords" content=""/>
    <!-- 网页作者 -->
    <meta name="author" content="name, email@gmail.com"/>
    <!-- 搜索引擎抓取 -->
    <meta name="robots" content="index,follow"/>
    <!-- 为移动设备添加 viewport -->
    <meta name="viewport" content="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no">
    <!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz -->

    <!-- iOS 设备 begin -->
    <meta name="apple-mobile-web-app-title" content="标题">
    <!-- 添加到主屏后的标题（iOS 6 新增） -->
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 -->

    <meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">
    <!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
    <!-- 设置苹果工具栏颜色 -->
    <meta name="format-detection" content="telphone=no, email=no"/>
    <!-- 忽略页面中的数字识别为电话，忽略email识别 -->
    <!-- 启用360浏览器的极速模式(webkit) -->
    <meta name="renderer" content="webkit">
    <!-- 避免IE使用兼容模式 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
    <meta name="HandheldFriendly" content="true">
    <!-- 微软的老式浏览器 -->
    <meta name="MobileOptimized" content="320">
    <!-- uc强制竖屏 -->
    <meta name="screen-orientation" content="portrait">
    <!-- QQ强制竖屏 -->
    <meta name="x5-orientation" content="portrait">
    <!-- UC强制全屏 -->
    <meta name="full-screen" content="yes">
    <!-- QQ强制全屏 -->
    <meta name="x5-fullscreen" content="true">
    <!-- UC应用模式 -->
    <meta name="browsermode" content="application">
    <!-- QQ应用模式 -->
    <meta name="x5-page-mode" content="app">
    <!-- windows phone 点击无高光 -->
    <meta name="msapplication-tap-highlight" content="no">
    <!-- iOS 图标 begin -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-57x57-precomposed.png"/>
    <!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"/>
    <!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"/>
    <!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->
    <!-- iOS 图标 end -->

    <!-- iOS 启动画面 begin -->
    <link rel="apple-touch-startup-image" sizes="768x1004" href="/splash-screen-768x1004.png"/>
    <!-- iPad 竖屏 768 x 1004（标准分辨率） -->
    <link rel="apple-touch-startup-image" sizes="1536x2008" href="/splash-screen-1536x2008.png"/>
    <!-- iPad 竖屏 1536x2008（Retina） -->
    <link rel="apple-touch-startup-image" sizes="1024x748" href="/Default-Portrait-1024x748.png"/>
    <!-- iPad 横屏 1024x748（标准分辨率） -->
    <link rel="apple-touch-startup-image" sizes="2048x1496" href="/splash-screen-2048x1496.png"/>
    <!-- iPad 横屏 2048x1496（Retina） -->

    <link rel="apple-touch-startup-image" href="/splash-screen-320x480.png"/>
    <!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) -->
    <link rel="apple-touch-startup-image" sizes="640x960" href="/splash-screen-640x960.png"/>
    <!-- iPhone/iPod Touch 竖屏 640x960 (Retina) -->
    <link rel="apple-touch-startup-image" sizes="640x1136" href="/splash-screen-640x1136.png"/>
    <!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) -->
    <!-- iOS 启动画面 end -->

    <!-- iOS 设备 end -->
    <meta name="msapplication-TileColor" content="#000"/>
    <!-- Windows 8 磁贴颜色 -->
    <meta name="msapplication-TileImage" content="icon.png"/>
    <!-- Windows 8 磁贴图标 -->

    <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"/>
    <!-- 添加 RSS 订阅 -->
    <link rel="shortcut icon" type="image/ico" href="/favicon.ico"/>
    <!-- 添加 favicon icon -->
    
<meta name='viewport' content='width=device-width initial-scale=1'>
<meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache">
<meta http-equiv="Cache" content="no-cache">
<!-- 去缓存 -->

<script src="https://unpkg.com/umoji@2.0.0/dist/umoji.umd.js"></script>
<!-- 表情包 -->

<link href="http://cdn.bootcss.com/highlight.js/8.0/styles/vs.min.css" rel="stylesheet">
<script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  
<script >hljs.initHighlightingOnLoad();</script> 

<link href="https://cdn.bootcss.com/jquery.tocify/1.9.0/stylesheets/jquery.tocify.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/1.8.2/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/jqueryui/1.10.1/jquery-ui.min.js"></script>
<script src="https://cdn.bootcss.com/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js"></script>

<style>
.tocCal{
	position: fixed;
	width: 400px;
	max-width: 450px;
	margin: 0px 0px 20px 0px;	
	top: 36px;	
	right:30px;	
	font-size: 13px;
	max-height:90%;		
	background-color: #0088CC;	
	border: 1px solid #ccc;
	webkit-border-radius: 6px;
	moz-border-radius: 6px;
	border-radius: 6px;
	color: white;
}

.toc {
	position: fixed;
	width: 400px;
	max-width: 450px;
	margin: 0px 0px 20px 0px;
	top: 60px;
	right:30px;	
	/*background: #f1f1f1;*/	
	background-color: #ffffff;
	
	font-size: 13px;
	max-height:86%;		
	
	border: 1px solid #ccc;
	webkit-border-radius: 6px;
	moz-border-radius: 6px;
	border-radius: 6px;
}

.nav-list > .active > a, .nav-list > .active > a:hover {
    color: #ffffff;
    text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.2);
    background-color: #0088cc;
}
</style>

<script type="text/javascript">
// ==UserScript==
// @name 窄边滚动条 (Narrow Scrollbar)
// @description 原始配色8px滚动条(仅适用于WebKit内核浏览器)
// @namespace https://github.com/ue1/userscripts
// @version 1.0.1
// @run-at document-start
// @include http*
// @compatible chrome
// @grant none
// ==/UserScript==
var _tag = "head|body|html".split("|");
for (var i = 0; i < _tag.length; i++) {
    var _head = document.getElementsByTagName(_tag[i])[0];
    if (!_head) continue;
    var _style = document.createElement('style');
    _style.setAttribute("type", "text/css");
    _style.innerHTML = "::-webkit-scrollbar{width:8px;height:8px;}::-webkit-scrollbar-thumb:hover{background-color:#a8a8a8;}::-webkit-scrollbar-thumb{background-color:#c0c0c0;}::-webkit-scrollbar-track-piece{background-color:#f1f1f1;}::-webkit-scrollbar-thumb:active{background-color:#787878;}";
    _head.appendChild(_style);
    break;
}
</script>

<script type="text/javascript">
    function wrapOldContentByDiv() {
        var oldContentDiv = document.createElement("div");
        oldContentDiv.style.cssText = "float:right; width:72%; padding-left: 3%; padding-right:3%;border: 2px solid #CACACA;";
        oldContentDiv.innerHTML = document.body.innerHTML;
        document.body.style["max-width"] = "100%";
        document.body.style["margin"] = "20px";
        document.body.style["padding"] = "0";
        document.body.innerHTML = '';
        document.body.appendChild(oldContentDiv);
    };

    function addDirectorySwitch(directoryDiv) {
        var directorySwitchP = document.createElement("p");
        directorySwitchP.style.cssText = "text-align: left; margin: 0;";
        directoryDiv.appendChild(directorySwitchP);

        var ele_span = document.createElement("span");
        ele_span.style.cssText = "font-weight: 1000;";
        var ele_text = document.createTextNode("目录");
        ele_span.appendChild(ele_text);

        var ele_a = document.createElement("a");
        ele_a.appendChild(document.createTextNode("[-]"));
        ele_a.setAttribute("href", "#");
        ele_a.setAttribute("onclick", "javascript:return switchAllDirectory(this);");
        ele_a.setAttribute("title", "Click to Open TOC");

        ele_span.appendChild(ele_a);
        directorySwitchP.appendChild(ele_span);
    }

    function createTree(parentNode, tags, index, maxLevel) {
        if (index >= tags.length) {
            return -1;
        }

        var lastLevel = -1;
        for (var i = index; i < tags.length; i++) {
            var header = tags[i];
            var level = parseInt(header.tagName.substr(1), 10);

            var childNode = {'tag': header, 'childNodes': [], 'level': level};
            if (level > parentNode.level) {
                if (lastLevel > 0 && level > lastLevel) {
                    // 子子类
                    index = createTree(parentNode.childNodes[parentNode.childNodes.length - 1], tags, i);
                    if (index < 0) {
                        return -1;
                    } else {
                        i = index - 1;
                    }
                } else {
                    parentNode.childNodes.push(childNode);
                    lastLevel = level;
                }
            } else if (level <= maxLevel && parentNode.level > maxLevel) {
                parentNode.childNodes.push(childNode);
                lastLevel = level;
            } else {
                return i;
            }
        }
    }

    function createAElement(tag, index) {
        var a = document.createElement("a");
        a.style.cssText = "";
        a.setAttribute("href", "#" + tag.textContent);
        a.innerHTML = index.toString() + tag.textContent;
        return a;
    }

    function createOlElement() {
        var ol_el = document.createElement("ol");
        ol_el.style["line-height"] = "180%";
        ol_el.style["list-style-type"] = "none";
        ol_el.style["margin-left"] = "0";
        return ol_el
    }

    function createEmptyLiElement() {
        var emptyLiEle = document.createElement("li");
        return emptyLiEle
    }

    function getIndex(parentDirectory, directoryLevel, index) {
        if (directoryLevel === 0) {
            return parentDirectory + (index + 1).toString() + "."
        } else {
            return parentDirectory + (index + 1).toString() + ".";
        }
    }

    function createLeafElement(node, curDirectory) {
        var liEle = createEmptyLiElement();
        var aEle = createAElement(node.tag, curDirectory);
        liEle.appendChild(aEle);
        return liEle
    }

    function getArrowDownStyle() {
        return " width: 0;" +
            "    height: 0;" +
            "    position: relative;" +
            "    margin-right: 8px;" +
            "    top: 3px;" +
            "    display: inline-block;" +
            "    border: 6px outset;" +
            "    border-color: black transparent transparent transparent;"
    }

    function getArrowRightStyle() {
        return " width: 0;" +
            "    height: 0;" +
            "    left: 5px;" +
            "    position: relative;" +
            "    margin-right: 8px;" +
            "    display: inline-block;" +
            "    border: 6px solid;" +
            "    border-color: transparent transparent transparent black;"
    }

    /*
    <ol>
        <li><a>根节点1</a></li>
        <li><a>根节点2</a></li>
        <li>
            <div>
                <a><span>[-]</span>根节点3</a>
                <ol>
                    <li><a>子节点1</a></li>
                    <li><a>子节点2</a></li>
                    <li><a>子节点3</a></li>
                </ol>
            </div>
        </li>
        <li><a>根节点4</a></li>
     </ol>
    * */
    // node, 1.2.3 4 0
    function renderTree(node, parentDirectory, directoryLevel, index) {
        var childNodes = node.childNodes;
        var tagContent = node.tag.textContent;

        node.tag.setAttribute("id", tagContent);

        var curDirectory = getIndex(parentDirectory, directoryLevel, index);
        var directoryName = curDirectory + "&nbsp;" + tagContent;

        // 叶子节点
        if (childNodes.length === 0) {
            return "<li style='padding-left: 24px;'><a href='#" + tagContent + "'>" + directoryName + "</a></li>"
    //                return createLeafElement(node, curDirectory)
        }

        // 非叶子节点
        var childContent = "";
        for (var j = 0; j < node.childNodes.length; j++) {
            childContent += renderTree(node.childNodes[j], curDirectory, directoryLevel + 1, j);
        }

        return "<li>" +
            "   <div>" +
            "      <div>" +
            "         <div id='" + directoryName + "' class='open' style='" + getArrowDownStyle() + "' onclick='return switchDirectory(this);'></div>" +
            "         <a href='#" + tagContent + "' ondblclick='return switchByDbClick(this);'>" + directoryName + "</a>" +
            "      </div>" +
            "      <ol id='ol-" + directoryName + "' style='line-height: 180%;list-style-type: none; padding-left: 20px;'>" + childContent + "</ol>" +
            "   </div>" +
            "</li>";

        /*var liEle = createEmptyLiElement();
        var aEle = createAElement(node.tag, curDirectory);

        var parentElement = document.createElement("div");
        parentElement.appendChild(aEle);

        var olElement = createOlElement();

        var tempNode;
        for (var j = 0; j < node.childNodes.length; j++) {
            tempNode = node.childNodes[j];
            var element = renderTree(tempNode, curDirectory, directoryLevel + 1, j);
            olElement.appendChild(element);
        }
        parentElement.appendChild(olElement);

        liEle.appendChild(parentElement);
        return liEle;*/
    }

    function switchByDbClick(aEle) {
        switchDirectory(aEle.parentElement().firstChild)
    }

    // 开关目录
    function switchDirectory(ele) {
        var divEle = ele.parentNode.parentNode;
        var olEle = divEle.lastElementChild;
        if (ele.className === "open") {
            // 关闭
            olEle.style.cssText = "display:none;line-height: 180%;list-style-type: none; padding-left: 20px";
            ele.setAttribute("class", "close");
            ele.style.cssText = getArrowRightStyle();
        } else if (ele.className === "close") {
            // 打开
            olEle.style.cssText = "line-height: 180%;list-style-type: none; padding-left: 20px";
            ele.setAttribute("class", "open");
            ele.style.cssText = getArrowDownStyle();
        }
    }

    function switchAllDirectory(e) {
        var rootOlElement = document.getElementById("outline_ol");
        var ols = rootOlElement.getElementsByTagName("ol");
        var isOpen = false;

        if (e.innerHTML === '[+]') {
            e.setAttribute('title', 'collapse');
            e.innerHTML = '[-]';
            isOpen = true;
        } else {
            e.setAttribute('title', 'expand');
            e.innerHTML = '[+]';
        }


        for (var i = 0; i < ols.length; i++) {
            var olEle = ols[i];
            if (isOpen) {
                olEle.style.display = "block";
                olEle.parentNode.firstElementChild.firstElementChild.style.cssText = getArrowDownStyle();
            } else {
                olEle.style.display = "none";
                olEle.parentNode.firstElementChild.firstElementChild.style.cssText = getArrowRightStyle();
            }
        }

        e.blur();
        return false;
    }

    document.addEventListener("DOMContentLoaded", function () {
        // 1, 将body内容提取到div标签中
        wrapOldContentByDiv();

        // 2, 创建左边目录列表Div
        var directoryDiv = document.createElement("div");
        directoryDiv.setAttribute("id", "outline-list");
        directoryDiv.style.cssText = "width:20%;height:100%; float:left;font-size:16px,z-index:1;position: fixed;overflow: hidden;";

        // 3, 目录展开折叠开关
        addDirectorySwitch(directoryDiv);

        // 4, 创建目录列表
        var directoryOl = document.createElement("ol");
        directoryOl.style.cssText = "padding-left:14px;line-height:180%;list-style-type:none;height: 85%;padding-bottom: 30px; overflow: auto;";
        directoryOl.setAttribute("id", "outline_ol");
        directoryDiv.appendChild(directoryOl);
        var div1 = document.createElement("div");
        div1.style.cssText = "clear:both";

        // 插入目录
        document.body.insertBefore(directoryDiv, document.body.childNodes[0]);

        // 5, 获取所有的H标签
        var hTags = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
        if (hTags.length < 2)
            return;

        var rootNode = {'tag': directoryOl, 'childNodes': [], 'level': 0};
        var maxLevel = parseInt(hTags[0].tagName.substr(1), 10);
        // 6, 创建树形结构
        createTree(rootNode, hTags, 0, maxLevel);

        // 7, 绘制树结构
        var htmlContent = "";
        for (var j = 0; j < rootNode.childNodes.length; j++) {
    //                var element = renderTree(rootNode.childNodes[j], '', 1, j);
    //                directoryOl.appendChild(element);

            htmlContent += renderTree(rootNode.childNodes[j], '', 1, j);
        }
        directoryOl.innerHTML = htmlContent;
    });
</script>

<script>
var wx ,wy;	
$(document).mousemove(function(e){ 
	wx  = e.clientX;
	wy = e.clientY; 
});

$(window).scroll(function() {	

	var _height=$("#toc").height()/3;
	
	var _hh=$("#toc").scrollTop() + $("#toc").find(".active").offset().top - $("#toc").offset().top;		
	
	var d_left = document.getElementById("toc").offsetLeft;
    var d_top = document.getElementById("toc").offsetTop;
    var d_width = document.getElementById("toc").clientWidth;
    var d_height = document.getElementById("toc").clientHeight;

    if(wx < d_left || wy<d_top || wx > (d_left + d_width) || wy > (d_top + d_height)){
		$("#toc").scrollTop(_hh-_height);			
	}
	
});
</script>


<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


/* 全局属性 */
#write {
  max-width: 860px;
  font-size: 16px;
  color: black;
  padding: 0 10px;
  line-height: 1.6;
  word-spacing: 0px;
  letter-spacing: 0px;
  word-break: break-word;
  word-wrap: break-word;
  text-align: left;
  font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;
}

/*段落*/
#write p {
  font-size: 16px;
  padding-top: 8px;
  padding-bottom: 8px;
  margin: 0;
  line-height: 26px;
  color: black;
}


/*标题*/
#write h1,
#write h2,
#write h3,
#write h4,
#write h5,
#write h6 {
  margin-top: 30px;
  margin-bottom: 15px;
  padding: 0px;
  font-weight: bold;
  color: black;
}
#write h1 {
  font-size: 1.5rem;
}
#write h2 {
  font-size: 1.3rem;
  border-bottom: 2px solid rgb(239, 112, 96);
}
#write h2 span {
 display: inline-block;
 font-weight: bold;
 background: rgb(239, 112, 96);
 color: #ffffff;
 padding: 3px 10px 1px;
 border-top-right-radius: 3px;
 border-top-left-radius: 3px;
 margin-right: 3px;
}
#write h2:after {
 display: inline-block;
 content: "";
 vertical-align: bottom;
 border-bottom: 36px solid #efebe9;
 border-right: 20px solid transparent;
}
#write h3 {
  font-size: 1.2rem;
}
#write h4 {
  font-size: 1.1rem;
}
#write h5 {
  font-size: 1rem;
}
#write h6 {
  font-size: 1rem;
}

/*列表*/
#write ul,
#write ol {
  margin-top: 8px;
  margin-bottom: 8px;
  padding-left: 25px;
  color: black;
}
#write ul {
  list-style-type: disc;
}
#write ul ul {
  list-style-type: square;
}
#write ol {
  list-style-type: decimal;
}
#write li section {
  margin-top: 5px;
  margin-bottom: 5px;
  line-height: 26px;
  text-align: left;
  color: rgb(1,1,1); /* 只要是纯黑色微信编辑器就会把color这个属性吞掉。。。*/
  font-weight: 500;
}

/*引用*/
#write blockquote {
  display: block;
  font-size: 0.9em;
  overflow: auto;
  overflow-scrolling: touch;
  border-left: 3px solid rgb(239, 112, 96);
  color: #6a737d;
  padding: 10px 10px 10px 20px;
  margin-bottom: 20px;
  margin-top: 20px;
  background: #fff9f9;
}
#write blockquote p {
  margin: 0px;
  color: black;
  line-height: 26px;
}

/*链接*/
#write a {
  text-decoration: none;
  word-wrap: break-word;
  font-weight: bold;
  border-bottom: 1px solid #1e6bb8;
  color: rgb(239, 112, 96);
  border-bottom: 1px solid rgb(239, 112, 96);
}

/*行内代码*/
#write p code,
#write li code {
  font-size: 14px;
  word-wrap: break-word;
  padding: 2px 4px;
  border-radius: 4px;
  margin: 0 2px;
  color:  rgb(239, 112, 96);;
  background-color: rgba(27,31,35,.05);
  font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;
  word-break: break-all;
}

/*图片*/
#write img {
  display: block;
  margin: 0 auto;
  max-width: 100%;
}

/*表格*/
#write table {
  display: table;
  text-align: left;
}
#write tbody {
  border: 0;
}
#write table tr {
  border: 0;
  border-top: 1px solid #ccc;
  background-color: white;
}
#write table tr:nth-child(2n) {
  background-color: #F8F8F8;
}
#write table tr th,
#write table tr td {
  font-size: 16px;
  border: 1px solid #ccc;
  padding: 5px 10px;
  text-align: left;
}
#write table tr th {
  font-weight: bold;
  background-color: #f0f0f0;
}

/* 行内代码 */
#write span code, #write li code {
 color: rgb(239, 112, 96);
}

/* 脚注上标 */
#write .md-footnote {
 font-weight: bold;
 color: rgb(239, 112, 96);
}
#write .md-footnote > .md-text:before {
 content: '['
}
#write .md-footnote > .md-text:after {
 content: ']'
}

/* 脚注 */
#write .md-def-name {
  padding-right: 1.8ch;
}
#write .md-def-name:before {
  content: '[';
  color: #000;
}
#write .md-def-name:after {
  color: #000;
}

/* 代码块主题 */
.md-fences:before {
  content: ' ';
  display: block;
  width: 100%;
  background-size: 40px;
  background-repeat: no-repeat;
  background-color: #282c34;
  margin-bottom: -7px;
  border-radius: 5px;
  background-position: 10px 10px;
}
.cm-s-inner.CodeMirror {
  padding-top: .5rem;
  padding-bottom: .5rem;
  background-color: #292d3e;
  color: #a6accd;
  font-family: Consolas;
  border-radius: 4px;
}
.CodeMirror-lines {
  padding-left: 4px;
}
.cm-s-inner .cm-keyword {
  color: #c792ea;
}
.cm-s-inner .cm-operator {
  color: #89ddff;
}
.cm-s-inner .cm-variable-2 {
  color: #eeffff;
}
.cm-s-inner .cm-variable-3,
.cm-s-inner .cm-type {
  color: #f07178;
}
.cm-s-inner .cm-builtin {
  color: #ffcb6b;
}
.cm-s-inner .cm-atom {
  color: #f78c6c;
}
.cm-s-inner .cm-number {
  color: #ff5370;
}
.cm-s-inner .cm-def {
  color: #82aaff;
}
.cm-s-inner .cm-string {
  color: #c3e88d;
}
.cm-s-inner .cm-string-2 {
  color: #f07178;
}
.cm-s-inner .cm-comment {
  color: #676e95;
}
.cm-s-inner .cm-variable {
  color: #f07178;
}
.cm-s-inner .cm-tag {
  color: #ff5370;
}
.cm-s-inner .cm-meta {
  color: #ffcb6b;
}
.cm-s-inner .cm-attribute {
  color: #c792ea;
}
.cm-s-inner .cm-property {
  color: #c792ea;
}
.cm-s-inner .cm-qualifier {
  color: #decb6b;
}
.cm-s-inner .cm-variable-3,
.cm-s-inner .cm-type {
  color: #decb6b;
}
.cm-s-inner .cm-error {
  color: rgba(255, 255, 255, 1);
  background-color: #ff5370;
}
.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}
.CodeMirror div.CodeMirror-cursor {
  border-left: 1px solid rgb(239, 112, 96);
  z-index: 3;
}

</style>

<script>
(function(){window.onload = function(){
    console.log('DOM already loaded.');
    if(window.top == window.self){ 
        var aNode = document.createElement('a');
        aNode.href = 'javascript:;';
        aNode.id = 'click-to-top';
        aNode.title = 'Click it to go to the top';
        var availHeight = window.screen.availHeight; // 获取可用高度
        var css = '#click-to-top{ display:none; position: fixed; right: 5%; bottom: 20%; opacity: 0.2; z-index: 9999; } #click-to-top:hover{ position: fixed; right: 5%; bottom: 20%; opacity: 1; z-index: 9999; }';
        //滚出一屏以后才显示返回顶部按钮
        window.onscroll = function(){
            var curPos = (document.documentElement.scrollTop == 0) ? document.body.scrollTop : document.documentElement.scrollTop; //document.documentElement.scrollTop; //preparation for hack (document.documentElement.scrollTop == 0) ? document.body.scrollTop : document.documentElement.scrollTop; 
            if(curPos > availHeight){
                aNode.style.display = 'block';
            }else {
                aNode.style.display = 'none';
            }
        };
        //图片相关
        var img = document.createElement('img');
        img.src = 'https://ooo.0o0.ooo/2017/05/23/59245c636b321.png';
        img.style = 'width: 30px; height: 30px;';
        //样式相关
        var style = document.createElement('style');
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }
        document.getElementsByTagName('head')[0].appendChild(style);
        aNode.append(img);
        aNode.addEventListener('click', function(){
            document.body.scrollIntoView();
            /*var timer = setInterval(function(){
            document.documentElement.scrollTop -= 500;
                if(document.documentElement.scrollTop < 100){
                    clearInterval(timer);
                }
            }, 50);
        }, true);*/
        });
        var eBody = document.querySelector('body');
        eBody.append(aNode);
    }
};})();
</script>

<script>
	!function(e, t, a) {
		function r() {
			for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
			requestAnimationFrame(r)
		}
		function n() {
			var t = "function" == typeof e.onclick && e.onclick;
			e.onclick = function(e) {
				t && t(),
					o(e)
			}
		}
		function o(e) {
			var a = t.createElement("div");
			a.className = "heart",
				s.push({
					el: a,
					x: e.clientX - 5,
					y: e.clientY - 5,
					scale: 1,
					alpha: 1,
					color: c()
				}),
				t.body.appendChild(a)
		}
		function i(e) {
			var a = t.createElement("style");
			a.type = "text/css";
			try {
				a.appendChild(t.createTextNode(e))
			} catch(t) {
				a.styleSheet.cssText = e
			}
			t.getElementsByTagName("head")[0].appendChild(a)
		}
		function c() {
			return "rgb(" + ~~ (255 * Math.random()) + "," + ~~ (255 * Math.random()) + "," + ~~ (255 * Math.random()) + ")"
		}
		var s = [];
		e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||
			function(e) {
				setTimeout(e, 1e3 / 60)
			},
			i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),
			n(),
			r()
	} (window, document);
</script>
</head>
<body>
<p><a href="&quot;#&quot;">返回上一页</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/SQL%E7%BB%8F%E5%85%B8%E5%85%A5%E9%97%A8.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaoshengblog/Picbed/img/Mysql.jpg" alt=""></p>
<h1 id="sql-">SQL 基础教程</h1>
<h2 id="sql-">SQL 教程</h2>
<p>SQL 是用于访问和处理数据库的标准的计算机语言。</p>
<p>在本教程中，您将学到如何使用 SQL 访问和处理数据系统中的数据，这类数据库包括：Oracle, Sybase, SQL Server, DB2, Access 等等。</p>
<h2 id="sql-">SQL 简介</h2>
<p>SQL 是用于访问和处理数据库的标准的计算机语言。</p>
<h3 id="-sql-"><strong>什么是 SQL？</strong></h3>
<ul>
<li>SQL 指结构化查询语言</li><li>SQL 使我们有能力访问数据库</li><li>SQL 是一种 ANSI 的标准计算机语言<br>编者注：ANSI，美国国家标准化组织</li></ul>
<h3 id="-sql-"><strong>SQL 能做什么？</strong></h3>
<ul>
<li>SQL 面向数据库执行查询</li><li>SQL 可从数据库取回数据</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可从数据库删除记录</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可以设置表、存储过程和视图的权限</li></ul>
<h3 id="-sql-"><strong>SQL 是一种标准</strong> - 但是…</h3>
<p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。</p>
<p>不幸地是，存在着很多不同版本的 SQL 语言，但是为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p>
<p>注释：除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的私有扩展！</p>
<h3 id="-sql-"><strong>在您的网站中使用 SQL</strong></h3>
<p>要创建发布数据库中数据的网站，您需要以下要素：</p>
<ul>
<li>RDBMS 数据库程序（比如 MS Access, SQL Server, MySQL）</li><li>服务器端脚本语言（比如 PHP 或 ASP）</li><li>SQL</li><li>HTML / CSS</li></ul>
<h3 id="-rdbms-"><strong>RDBMS</strong></h3>
<p>RDBMS 指的是关系型数据库管理系统。</p>
<p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server, IBM DB2, Oracle, MySQL 以及 Microsoft Access。</p>
<p>RDBMS 中的数据存储在被称为表（tables）的数据库对象中。</p>
<p>表是相关的数据项的集合，它由列和行组成</p>
<hr>
<h2 id="sql-">SQL 语法</h2>
<h3 id="-">数据库表</h3>
<p>一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行）。</p>
<p>下面的例子是一个名为 “Persons” 的表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Adams</td>
<td style="text-align:center">John</td>
<td style="text-align:center">Oxford Street</td>
<td style="text-align:center">London</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Bush</td>
<td style="text-align:center">George</td>
<td style="text-align:center">Fifth Avenue</td>
<td style="text-align:center">New York</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<p>上面的表包含三条记录（每一条对应一个人）和五个列（Id、姓、名、地址和城市）。</p>
<h3 id="sql-">SQL 语句</h3>
<p>您需要在数据库上执行的大部分工作都由 SQL 语句完成。</p>
<p>下面的语句从表中选取 LastName 列的数据：</p>
<pre><code>SELECT LastName FROM Persons
</code></pre><p>结果集类似这样：</p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Adams</td>
</tr>
<tr>
<td style="text-align:center">Bush</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
</tr>
</tbody>
</table>
<p>在本教程中，我们将为您讲解各种不同的 SQL 语句。</p>
<h3 id="-"><strong>重要事项</strong></h3>
<p>一定要记住，SQL 对大小写不敏感！</p>
<h3 id="sql-">SQL 语句后面的分号？</h3>
<p>某些数据库系统要求在每条 SQL 命令的末端使用分号。在我们的教程中不使用分号。</p>
<p>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。</p>
<p>如果您使用的是 MS Access 和 SQL Server 2000，则不必在每条 SQL 语句之后使用分号，不过某些数据库软件要求必须使用分号。</p>
<h3 id="sql-dml-ddl">SQL DML 和 DDL</h3>
<p>可以把 SQL 分为两个部分：<strong>数据操作语言 (DML) </strong>和 <strong>数据定义语言 (DDL)</strong>。<br>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p>
<p><strong>查询和更新指令构成了 SQL 的 DML 部分：</strong></p>
<ul>
<li>SELECT 从数据库表中获取数据</li><li>UPDATE 更新数据库表中的数据</li><li>DELETE 从数据库表中删除数据</li><li>INSERT INTO 向数据库表中插入数据</li></ul>
<p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p>
<p><strong>SQL 中最重要的 DDL 语句:</strong></p>
<ul>
<li>CREATE DATABASE 创建新数据库</li><li>ALTER DATABASE 修改数据库</li><li>CREATE TABLE 创建新表</li><li>ALTER TABLE 变更（改变）数据库表</li><li>DROP TABLE 删除表</li><li>CREATE INDEX 创建索引（搜索键）</li><li>DROP INDEX 删除索引</li></ul>
<hr>
<h2 id="sql-select">SQL select</h2>
<p>本章讲解 SELECT 和 SELECT * 语句。</p>
<h3 id="sql-select-">SQL SELECT 语句</h3>
<p>SELECT 语句用于从表中选取数据。</p>
<p>结果被存储在一个结果表中（称为结果集）。</p>
<p><strong>SQL SELECT 语法</strong></p>
<pre><code>SELECT 列名称 FROM 表名称
</code></pre><p>以及：</p>
<pre><code>SELECT * FROM 表名称
</code></pre><p>注释：SQL 语句对大小写不敏感。SELECT 等效于 select。</p>
<h3 id="sql-select-">SQL SELECT 实例</h3>
<p>如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句：</p>
<pre><code>SELECT LastName,FirstName FROM Persons
</code></pre><p>“Persons” 表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Adams</td>
<td style="text-align:center">John</td>
<td style="text-align:center">Oxford Street</td>
<td style="text-align:center">London</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Bush</td>
<td style="text-align:center">George</td>
<td style="text-align:center">Fifth Avenue</td>
<td style="text-align:center">New York</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Adams</td>
<td style="text-align:center">John</td>
</tr>
<tr>
<td style="text-align:center">Bush</td>
<td style="text-align:center">George</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
</tr>
</tbody>
</table>
<h3 id="sql-select-">SQL SELECT * 实例</h3>
<p>现在我们希望从 “Persons” 表中选取所有的列。</p>
<p>请使用符号 * 取代列的名称，就像这样：</p>
<pre><code>SELECT * FROM Persons
</code></pre><p>提示：星号（*）是选取所有列的快捷方式。</p>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Adams</td>
<td style="text-align:center">John</td>
<td style="text-align:center">Oxford Street</td>
<td style="text-align:center">London</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Bush</td>
<td style="text-align:center">George</td>
<td style="text-align:center">Fifth Avenue</td>
<td style="text-align:center">New York</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-result-set-">在结果集（result-set）中导航</h3>
<p>由 SQL 查询程序获得的结果被存放在一个结果集中。大多数数据库软件系统都允许使用编程函数在结果集中进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。</p>
<hr>
<h2 id="sql-distinct">SQL distinct</h2>
<p>本章讲解 SELECT DISTINCT 语句。</p>
<h3 id="sql-select-distinct-">SQL SELECT DISTINCT 语句</h3>
<p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>关键词 DISTINCT 用于返回唯一不同的值。</p>
<p>语法：</p>
<pre><code>SELECT DISTINCT 列名称 FROM 表名称
</code></pre><h3 id="-distinct-">使用 DISTINCT 关键词</h3>
<p>如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句：</p>
<pre><code>SELECT Company FROM Orders
</code></pre><p>“Orders”表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Company</th>
<th style="text-align:left">OrderNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IBM</td>
<td style="text-align:left">3532</td>
</tr>
<tr>
<td style="text-align:left">W3School</td>
<td style="text-align:left">2356</td>
</tr>
<tr>
<td style="text-align:left">Apple</td>
<td style="text-align:left">4698</td>
</tr>
<tr>
<td style="text-align:left">W3School</td>
<td style="text-align:left">6953</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Company</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IBM</td>
</tr>
<tr>
<td style="text-align:left">W3School</td>
</tr>
<tr>
<td style="text-align:left">Apple</td>
</tr>
<tr>
<td style="text-align:left">W3School</td>
</tr>
</tbody>
</table>
<p>请注意，在结果集中，W3School 被列出了两次。</p>
<p>如需从 Company” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句：</p>
<pre><code>SELECT DISTINCT Company FROM Orders
</code></pre><p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Company</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IBM</td>
</tr>
<tr>
<td style="text-align:left">Apple</td>
</tr>
<tr>
<td style="text-align:left">W3School</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-where">SQL where</h2>
<p>WHERE 子句用于规定选择的标准。</p>
<h3 id="where-">WHERE 子句</h3>
<p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p>
<p>语法</p>
<pre><code>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值
</code></pre><p>下面的运算符可在 WHERE 子句中使用：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left">在某个范围内</td>
</tr>
<tr>
<td style="text-align:left">LIKE</td>
<td style="text-align:left">搜索某种模式</td>
</tr>
</tbody>
</table>
<p>注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。</p>
<h3 id="-where-">使用 WHERE 子句</h3>
<p>如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句：</p>
<pre><code>SELECT * FROM Persons WHERE City=&#39;Beijing&#39;
</code></pre><p>“Persons” 表</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
<th style="text-align:center">Year</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Adams</td>
<td style="text-align:center">John</td>
<td style="text-align:center">Oxford Street</td>
<td style="text-align:center">London</td>
<td style="text-align:center">1970</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Bush</td>
<td style="text-align:center">George</td>
<td style="text-align:center">Fifth Avenue</td>
<td style="text-align:center">New York</td>
<td style="text-align:center">1975</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
<td style="text-align:center">1980</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Gates</td>
<td style="text-align:center">Bill</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
<td style="text-align:center">1980</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
<th style="text-align:center">Year</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
<td style="text-align:center">1980</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Gates</td>
<td style="text-align:center">Bill</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
<td style="text-align:center">1980</td>
</tr>
</tbody>
</table>
<h3 id="-">引号的使用</h3>
<p>请注意，我们在例子中的条件值周围使用的是单引号。</p>
<p>SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。</p>
<p><strong>文本值：</strong></p>
<pre><code>这是正确的：
SELECT * FROM Persons WHERE FirstName=&#39;Bush&#39;

这是错误的：
SELECT * FROM Persons WHERE FirstName=Bush
</code></pre><p><strong>数值：</strong></p>
<pre><code>这是正确的：
SELECT * FROM Persons WHERE Year&gt;1965

这是错误的：
SELECT * FROM Persons WHERE Year&gt;&#39;1965&#39;
</code></pre><hr>
<h2 id="sql-and-or">SQL AND &amp; OR</h2>
<p>AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。</p>
<h3 id="and-or-">AND 和 OR 运算符</h3>
<p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p>
<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<p><strong>原始的表 (用在例子中的)：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Adams</td>
<td style="text-align:center">John</td>
<td style="text-align:center">Oxford Street</td>
<td style="text-align:center">London</td>
</tr>
<tr>
<td style="text-align:center">Bush</td>
<td style="text-align:center">George</td>
<td style="text-align:center">Fifth Avenue</td>
<td style="text-align:center">New York</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<h3 id="and-">AND 运算符实例</h3>
<p>使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：</p>
<pre><code>SELECT * FROM Persons WHERE FirstName=&#39;Thomas&#39; AND LastName=&#39;Carter&#39;
</code></pre><p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<h3 id="or-">OR 运算符实例</h3>
<p>使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：</p>
<pre><code>SELECT * FROM Persons WHERE firstname=&#39;Thomas&#39; OR lastname=&#39;Carter&#39;
</code></pre><p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-order-by">SQL Order By</h2>
<p>ORDER BY 语句用于对结果集进行排序。</p>
<h3 id="order-by-">ORDER BY 语句</h3>
<p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p>
<p>ORDER BY 语句默认按照升序对记录进行排序。</p>
<p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p>
<p><strong>原始的表 (用在例子中的)：</strong></p>
<p>Orders 表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Company</th>
<th style="text-align:center">OrderNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IBM</td>
<td style="text-align:center">3532</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">2356</td>
</tr>
<tr>
<td style="text-align:center">Apple</td>
<td style="text-align:center">4698</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">6953</td>
</tr>
</tbody>
</table>
<p><strong>实例 1</strong></p>
<p>以字母顺序显示公司名称：</p>
<pre><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Company</th>
<th style="text-align:center">OrderNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Apple</td>
<td style="text-align:center">4698</td>
</tr>
<tr>
<td style="text-align:center">IBM</td>
<td style="text-align:center">3532</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">6953</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">2356</td>
</tr>
</tbody>
</table>
<p><strong>实例 2</strong></p>
<p>以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：</p>
<pre><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Company</th>
<th style="text-align:center">OrderNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Apple</td>
<td style="text-align:center">4698</td>
</tr>
<tr>
<td style="text-align:center">IBM</td>
<td style="text-align:center">3532</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">2356</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">6953</td>
</tr>
</tbody>
</table>
<p><strong>实例 3</strong></p>
<p>以逆字母顺序显示公司名称：</p>
<pre><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Company</th>
<th style="text-align:center">OrderNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">6953</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">2356</td>
</tr>
<tr>
<td style="text-align:center">IBM</td>
<td style="text-align:center">3532</td>
</tr>
<tr>
<td style="text-align:center">Apple</td>
<td style="text-align:center">4698</td>
</tr>
</tbody>
</table>
<p><strong>实例 4</strong></p>
<p>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</p>
<pre><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC
</code></pre><p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Company</th>
<th style="text-align:center">OrderNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">2356</td>
</tr>
<tr>
<td style="text-align:center">W3School</td>
<td style="text-align:center">6953</td>
</tr>
<tr>
<td style="text-align:center">IBM</td>
<td style="text-align:center">3532</td>
</tr>
<tr>
<td style="text-align:center">Apple</td>
<td style="text-align:center">4698</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。</p>
<hr>
<h2 id="sql-insert">SQL insert</h2>
<h3 id="insert-into-">INSERT INTO 语句</h3>
<p>INSERT INTO 语句用于向表格中插入新的行。</p>
<p><strong>语法</strong></p>
<pre><code>INSERT INTO 表名称 VALUES (值1, 值2,....)
</code></pre><p>我们也可以指定所要插入数据的列：</p>
<pre><code>INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
</code></pre><h3 id="-">插入新的行</h3>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<p><strong>SQL 语句：</strong></p>
<pre><code>INSERT INTO Persons VALUES (&#39;Gates&#39;, &#39;Bill&#39;, &#39;Xuanwumen 10&#39;, &#39;Beijing&#39;)
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-">在指定的列中插入数据</h3>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<p><strong>SQL 语句：</strong></p>
<pre><code>INSERT INTO Persons (LastName, Address) VALUES (&#39;Wilson&#39;, &#39;Champs-Elysees&#39;)
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">Thomas</td>
<td style="text-align:center">Changan Street</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Wilson</td>
<td style="text-align:center">&amp;nbsp(空格)</td>
<td style="text-align:center">Champs-Elysees</td>
<td style="text-align:center">&amp;nbsp(空格)</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-update">SQL update</h2>
<h3 id="update-">Update 语句</h3>
<p>Update 语句用于修改表中的数据。</p>
<p><strong>语法：</strong></p>
<pre><code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
</code></pre><p><strong>Person:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Wilson</td>
<td style="text-align:center">&amp;nbsp(空格)</td>
<td style="text-align:center">Champs-Elysees</td>
<td style="text-align:center">&amp;nbsp(空格)</td>
</tr>
</tbody>
</table>
<h3 id="-">更新某一行中的一个列</h3>
<p>我们为 lastname 是 “Wilson” 的人添加 firstname：</p>
<pre><code>UPDATE Person SET FirstName = &#39;Fred&#39; WHERE LastName = &#39;Wilson&#39;
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Wilson</td>
<td style="text-align:center">Fred</td>
<td style="text-align:center">Champs-Elysees</td>
<td style="text-align:center">&amp;nbsp(空格)</td>
</tr>
</tbody>
</table>
<h3 id="-">更新某一行中的若干列</h3>
<p>我们会修改地址（address），并添加城市名称（city）：</p>
<pre><code>UPDATE Person SET Address = &#39;Zhongshan 23&#39;, City = &#39;Nanjing&#39; WHERE LastName = &#39;Wilson&#39;
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Wilson</td>
<td style="text-align:center">Fred</td>
<td style="text-align:center">Champs-Elysees</td>
<td style="text-align:center">Nanjing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-delete">SQL delete</h2>
<h3 id="delete-">DELETE 语句</h3>
<p>DELETE 语句用于删除表中的行。</p>
<p><strong>语法</strong></p>
<p>DELETE FROM 表名称 WHERE 列名称 = 值</p>
<p><strong>Person:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
<tr>
<td style="text-align:center">Wilson</td>
<td style="text-align:center">Fred</td>
<td style="text-align:center">Champs-Elysees</td>
<td style="text-align:center">Nanjing</td>
</tr>
</tbody>
</table>
<h3 id="-">删除某行</h3>
<p>“Fred Wilson” 会被删除：</p>
<pre><code>DELETE FROM Person WHERE LastName = &#39;Wilson&#39;
</code></pre><p><strong>结果:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LastName</th>
<th style="text-align:center">FirstName</th>
<th style="text-align:center">Address</th>
<th style="text-align:center">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Carter</td>
<td style="text-align:center">William</td>
<td style="text-align:center">Xuanwumen 10</td>
<td style="text-align:center">Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-">删除所有行</h3>
<p>可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</p>
<pre><code>DELETE FROM table_name
</code></pre><p><strong>或者：</strong></p>
<pre><code>DELETE * FROM table_name
</code></pre><hr>
<h1 id="-sql-"><strong>SQL 高级教程</strong></h1>
<h2 id="sql-top">SQL Top</h2>
<h3 id="-top-"><strong>TOP 子句</strong></h3>
<p>TOP 子句用于规定要返回的记录的数目。</p>
<p>对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。</p>
<p><strong>注释：</strong>并非所有的数据库系统都支持 TOP 子句。</p>
<h3 id="-sql-server-"><strong>SQL Server 的语法：</strong></h3>
<p>SELECT TOP number|percent column_name(s)</p>
<p>FROM table_name</p>
<p><strong>MySQL 和 Oracle 中的 SQL SELECT TOP 是等价的</strong></p>
<h3 id="-mysql-"><strong>MySQL 语法</strong></h3>
<pre><code>SELECT column_name(s)

FROM table_name

LIMIT number
</code></pre><h4 id="-"><strong>例子</strong></h4>
<pre><code>SELECT \*

FROM Persons

LIMIT 5
</code></pre><h3 id="-oracle-"><strong>Oracle 语法</strong></h3>
<pre><code>SELECT column_name(s)

FROM table_name

WHERE ROWNUM \&lt;= number
</code></pre><h4 id="-"><strong>例子</strong></h4>
<pre><code>SELECT \*

FROM Persons

WHERE ROWNUM \&lt;= 5
</code></pre><p><strong>原始的表 (用在例子中的)：</strong></p>
<p>Persons 表:</p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
<tr>
<td>4</td>
<td>Obama</td>
<td>Barack</td>
<td>Pennsylvania Avenue</td>
<td>Washington</td>
</tr>
</tbody>
</table>
<h3 id="-sql-top-"><strong>SQL TOP 实例</strong></h3>
<p>现在，我们希望从上面的 “Persons” 表中选取头两条记录。</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT TOP 2 \* FROM Persons
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<h3 id="-sql-top-percent-"><strong>SQL TOP PERCENT 实例</strong></h3>
<p>现在，我们希望从上面的 “Persons” 表中选取 50% 的记录。</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT TOP 50 PERCENT \* FROM Persons
</code></pre><p>结果：</p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-like">SQL Like</h2>
<p><strong>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</strong></p>
<h3 id="-like-"><strong>LIKE 操作符</strong></h3>
<p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p>
<p><strong>SQL LIKE 操作符语法</strong></p>
<pre><code>SELECT column_name(s)

FROM table_name

WHERE column_name LIKE pattern
</code></pre><p><strong>原始的表 (用在例子中的)：</strong></p>
<p>Persons 表:</p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-like-"><strong>LIKE 操作符实例</strong></h3>
<p><strong>例子 1</strong></p>
<p>现在，我们希望从上面的 “Persons” 表中选取居住在以 “N” 开始的城市里的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;N%&#39;
</code></pre><p><strong>提示:</strong>“%” 可用于定义通配符（模式中缺少的字母）。</p>
<p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<p><strong>例子 2</strong></p>
<p>接下来，我们希望从 “Persons” 表中选取居住在以 “g” 结尾的城市里的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;%g&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p><strong>例子 3</strong></p>
<p>接下来，我们希望从 “Persons” 表中选取居住在包含 “lon” 的城市里的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;%lon%&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
</tbody>
</table>
<p><strong>例子 4</strong></p>
<p>通过使用 NOT 关键字，我们可以从 “Persons” 表中选取居住在<strong>不包含</strong> “lon”的城市里的人：</p>
<pre><code>我们可以使用下面的 SELECT 语句：

SELECT \* FROM Persons

WHERE City NOT LIKE &#39;%lon%&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-">SQL 通配符</h2>
<p><strong>在搜索数据库中的数据时，您可以使用 SQL 通配符。</strong></p>
<h3 id="-sql-"><strong>SQL 通配符</strong></h3>
<p>在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。</p>
<p>SQL 通配符必须与 LIKE 运算符一起使用。</p>
<p>在 SQL 中，可使用以下通配符：</p>
<table>
<thead>
<tr>
<th><strong>通配符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>替代一个或多个字符</td>
</tr>
<tr>
<td>_</td>
<td>仅替代一个字符</td>
</tr>
<tr>
<td>[charlist]</td>
<td>字符列中的任何单一字符</td>
</tr>
<tr>
<td>[\^charlist] 或者 [!charlist]</td>
<td>不在字符列中的任何单一字符</td>
</tr>
</tbody>
</table>
<p><strong>原始的表 (用在例子中的)：</strong></p>
<p>Persons 表:</p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-"><strong>使用 % 通配符</strong></h3>
<h4 id="-1-"><strong>例子 1</strong></h4>
<p>现在，我们希望从上面的 “Persons” 表中选取居住在以 “Ne” 开始的城市里的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;Ne%&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<h4 id="-2-"><strong>例子 2</strong></h4>
<p>接下来，我们希望从 “Persons” 表中选取居住在包含 “lond” 的城市里的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;%lond%&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
</tbody>
</table>
<h3 id="-_-"><strong>使用 _ 通配符</strong></h3>
<h4 id="-1-"><strong>例子 1</strong></h4>
<p>现在，我们希望从上面的 “Persons” 表中选取名字的第一个字符之后是 “eorge” 的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE FirstName LIKE &#39;_eorge&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<h4 id="-2-"><em>例子 2*</em></h4>
<p>接下来，我们希望从 “Persons” 表中选取的这条记录的姓氏以 “C”<br>开头，然后是一个任意字符，然后是 “r”，然后是任意字符，然后是 “er”：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE LastName LIKE &#39;C_r_er&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-charlist-"><strong>使用 [charlist] 通配符</strong></h3>
<h4 id="-1-"><strong>例子 1</strong></h4>
<p>现在，我们希望从上面的 “Persons” 表中选取居住的城市以 “A” 或 “L” 或 “N”<br>开头的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;[ALN]%&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<h4 id="-2-"><strong>例子 2</strong></h4>
<p>现在，我们希望从上面的 “Persons” 表中选取居住的城市<strong>不以</strong> “A” 或 “L” 或 “N”开头的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE City LIKE &#39;[!ALN]%&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-in">SQL In</h2>
<h3 id="-in-"><strong>IN 操作符</strong></h3>
<p>IN 操作符允许我们在 WHERE 子句中规定多个值。</p>
<h4 id="-sql-in-"><strong>SQL IN 语法</strong></h4>
<pre><code>SELECT column_name(s)

FROM table_name

WHERE column_name IN (value1,value2,...)
</code></pre><p><strong>原始的表 (在实例中使用：)</strong></p>
<p>Persons 表:</p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<h4 id="-in-"><strong>IN 操作符实例</strong></h4>
<p>现在，我们希望从上表中选取姓氏为 Adams 和 Carter 的人：</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT \* FROM Persons

WHERE LastName IN (&#39;Adams&#39;,&#39;Carter&#39;)
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-between">SQL Between</h2>
<p><strong>BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于两个值之间的数据范围。</strong></p>
<h3 id="-between-"><strong>BETWEEN 操作符</strong></h3>
<p>操作符<code>BETWEEN ... AND</code><br>会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</p>
<h4 id="-sql-between-"><strong>SQL BETWEEN 语法</strong></h4>
<pre><code>SELECT column_name(s)

FROM table_name

WHERE column_name

BETWEEN value1 AND value2
</code></pre><p><strong>原始的表 (在实例中使用：)</strong></p>
<p>Persons 表:</p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
<tr>
<td>4</td>
<td>Gates</td>
<td>Bill</td>
<td>Xuanwumen 10</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<h3 id="-between-"><strong>BETWEEN 操作符实例</strong></h3>
<p>如需以字母顺序显示介于 “Adams”（包括）和”Carter”（不包括）之间的人，请使用下面的 SQL：</p>
<pre><code>SELECT \* FROM Persons

WHERE LastName

BETWEEN &#39;Adams&#39; AND &#39;Carter&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
</tbody>
</table>
<p><strong>重要事项：</strong>不同的数据库对<code>BETWEEN...AND</code>操作符的处理方式是有差异的。某些数据库会列出介于 “Adams” 和 “Carter”之间的人，但不包括 “Adams” 和 “Carter” ；某些数据库会列出介于 “Adams” 和”Carter” 之间并包括 “Adams” 和 “Carter” 的人；而另一些数据库会列出介于 “Adams”和 “Carter” 之间的人，包括 “Adams” ，但不包括 “Carter” 。</p>
<p>所以，请检查你的数据库是如何处理 BETWEEN….AND 操作符的！</p>
<p><strong>实例 2</strong></p>
<p>如需使用上面的例子显示范围之外的人，请使用 NOT 操作符：</p>
<pre><code>SELECT \* FROM Persons

WHERE LastName

NOT BETWEEN &#39;Adams&#39; AND &#39;Carter&#39;
</code></pre><p><strong>结果集：</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
<tr>
<td>4</td>
<td>Gates</td>
<td>Bill</td>
<td>Xuanwumen 10</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-aliases">SQL Aliases</h2>
<p><strong>通过使用 SQL，可以为列名称和表名称指定别名（Alias）。</strong></p>
<h3 id="-sql-alias-"><strong>SQL Alias</strong></h3>
<h4 id="-sql-alias-"><strong>表的 SQL Alias 语法</strong></h4>
<pre><code>SELECT column_name(s)

FROM table_name

AS alias_name
</code></pre><h4 id="-sql-alias-"><strong>列的 SQL Alias 语法</strong></h4>
<pre><code>SELECT column_name AS alias_name

FROM table_name
</code></pre><h3 id="-alias-"><strong>Alias 实例: 使用表名称别名</strong></h3>
<p>假设我们有两个表分别是：”Persons” 和 “Product_Orders”。我们分别为它们指定别名”p” 和 “po”。</p>
<p>现在，我们希望列出 “John Adams” 的所有定单。</p>
<p>我们可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT po.OrderID, p.LastName, p.FirstName

FROM Persons AS p, Product_Orders AS po

WHERE p.LastName=&#39;Adams&#39; AND p.FirstName=&#39;John&#39;
</code></pre><p>不使用别名的 SELECT 语句：</p>
<pre><code>SELECT Product_Orders.OrderID, Persons.LastName, Persons.FirstName

FROM Persons, Product_Orders

WHERE Persons.LastName=&#39;Adams&#39; AND Persons.FirstName=&#39;John&#39;
</code></pre><p>从上面两条 SELECT 语句您可以看到，别名使查询程序更易阅读和书写。</p>
<h3 id="-alias-"><strong>Alias 实例: 使用一个列名别名</strong></h3>
<p><strong>表 Persons:</strong></p>
<table>
<thead>
<tr>
<th><strong>Id</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p><strong>SQL:</strong></p>
<pre><code>SELECT LastName AS Family, FirstName AS Name

FROM Persons
</code></pre><p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th><strong>Family</strong></th>
<th><strong>Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
</tr>
<tr>
<td>Bush</td>
<td>George</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-join">SQL Join</h2>
<p><strong>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</strong></p>
<h3 id="join-key">Join 和 Key</h3>
<p>有时为了得到完整的结果，我们需要从两个或更多的表中获取结果。我们就需要执行join。</p>
<p>数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。</p>
<p>请看 “Persons” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>请注意，”Id_P” 列是 Persons 表中的的主键。这意味着没有两行能够拥有相同的Id_P。即使两个人的姓名完全相同，Id_P 也可以区分他们。</p>
<p>接下来请看 “Orders” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_O</strong></th>
<th><strong>OrderNo</strong></th>
<th><strong>Id_P</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>77895</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>44678</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>22456</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24562</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>34764</td>
<td>65</td>
</tr>
</tbody>
</table>
<p>请注意，”Id_O” 列是 Orders 表中的的主键，同时，”Orders” 表中的 “Id_P” 列用于引用”Persons” 表中的人，而无需使用他们的确切姓名。</p>
<p>请留意，”Id_P” 列把上面的两个表联系了起来。</p>
<h3 id="-">引用两个表</h3>
<p>我们可以通过引用两个表的方式，从两个表中获取数据：</p>
<p>谁订购了产品，并且他们订购了什么产品？</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo

FROM Persons, Orders

WHERE Persons.Id_P = Orders.Id_P
</code></pre><p>结果集：</p>
<table>
<thead>
<tr>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>OrderNo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
<td>22456</td>
</tr>
<tr>
<td>Adams</td>
<td>John</td>
<td>24562</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>77895</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>44678</td>
</tr>
</tbody>
</table>
<h3 id="sql-join-join">SQL JOIN - 使用 Join</h3>
<p>除了上面的方法，我们也可以使用关键词 JOIN 来从两个表中获取数据。</p>
<p>如果我们希望列出所有人的定购，可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo

FROM Persons

INNER JOIN Orders

ON Persons.Id_P = Orders.Id_P

ORDER BY Persons.LastName
</code></pre><p>结果集：</p>
<table>
<thead>
<tr>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>OrderNo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
<td>22456</td>
</tr>
<tr>
<td>Adams</td>
<td>John</td>
<td>24562</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>77895</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>44678</td>
</tr>
</tbody>
</table>
<h3 id="-sql-join">不同的 SQL JOIN</h3>
<p>除了我们在上面的例子中使用的 INNER JOIN（内连接），我们还可以使用其他几种连接。</p>
<p>下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。</p>
<ul>
<li><p>JOIN: 如果表中有至少一个匹配，则返回行</p>
</li><li><p>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</p>
</li><li><p>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</p>
</li><li><p>FULL JOIN: 只要其中一个表中存在匹配，就返回行</p>
</li></ul>
<hr>
<h2 id="sql-inner-join">SQL Inner Join</h2>
<h3 id="sql-inner-join-">SQL INNER JOIN 关键字</h3>
<p>在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</p>
<h4 id="inner-join-">INNER JOIN 关键字语法</h4>
<pre><code>SELECT column_name(s)

FROM table_name1

INNER JOIN table_name2

ON table_name1.column_name=table_name2.column_name
</code></pre><p><strong>注释：</strong>INNER JOIN 与 JOIN 是相同的。</p>
<h4 id="-">原始的表 (用在例子中的)：</h4>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>“Orders” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_O</strong></th>
<th><strong>OrderNo</strong></th>
<th><strong>Id_P</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>77895</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>44678</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>22456</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24562</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>34764</td>
<td>65</td>
</tr>
</tbody>
</table>
<h3 id="-inner-join-">内连接（INNER JOIN）实例</h3>
<p>现在，我们希望列出所有人的定购。</p>
<p>您可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo

FROM Persons

INNER JOIN Orders

ON Persons.Id_P=Orders.Id_P

ORDER BY Persons.LastName
</code></pre><p>结果集：</p>
<table>
<thead>
<tr>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>OrderNo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
<td>22456</td>
</tr>
<tr>
<td>Adams</td>
<td>John</td>
<td>24562</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>77895</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>44678</td>
</tr>
</tbody>
</table>
<p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “Persons” 中的行在”Orders” 中没有匹配，就不会列出这些行。</p>
<hr>
<h2 id="sql-left-join">SQL Left Join</h2>
<h3 id="sql-left-join-">SQL LEFT JOIN 关键字</h3>
<p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表(table_name2) 中没有匹配的行。</p>
<h4 id="left-join-">LEFT JOIN 关键字语法</h4>
<pre><code>SELECT column_name(s)

FROM table_name1

LEFT JOIN table_name2

ON table_name1.column_name=table_name2.column_name
</code></pre><p><strong>注释：</strong>在某些数据库中， LEFT JOIN 称为 LEFT OUTER JOIN。</p>
<h3 id="-">原始的表 (用在例子中的)：</h3>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>“Orders” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_O</strong></th>
<th><strong>OrderNo</strong></th>
<th><strong>Id_P</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>77895</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>44678</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>22456</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24562</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>34764</td>
<td>65</td>
</tr>
</tbody>
</table>
<h3 id="-left-join-">左连接（LEFT JOIN）实例</h3>
<p>现在，我们希望列出所有的人，以及他们的定购 - 如果有的话。</p>
<p>您可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo

FROM Persons

LEFT JOIN Orders

ON Persons.Id_P=Orders.Id_P

ORDER BY Persons.LastName
</code></pre><p>结果集：</p>
<table>
<thead>
<tr>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>OrderNo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
<td>22456</td>
</tr>
<tr>
<td>Adams</td>
<td>John</td>
<td>24562</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>77895</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>44678</td>
</tr>
<tr>
<td>Bush</td>
<td>George</td>
</tr>
</tbody>
</table>
<p>LEFT JOIN 关键字会从左表 (Persons) 那里返回所有的行，即使在右表 (Orders)中没有匹配的行。</p>
<hr>
<h2 id="sql-right-join">SQL Right Join</h2>
<h3 id="sql-right-join-">SQL RIGHT JOIN 关键字</h3>
<p>RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1)<br>中没有匹配的行。</p>
<h4 id="right-join-">RIGHT JOIN 关键字语法</h4>
<pre><code>SELECT column_name(s)

FROM table_name1

RIGHT JOIN table_name2

ON table_name1.column_name=table_name2.column_name
</code></pre><p><strong>注释：</strong>在某些数据库中， RIGHT JOIN 称为 RIGHT OUTER JOIN。</p>
<h3 id="-">原始的表 (用在例子中的)：</h3>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>“Orders” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_O</strong></th>
<th><strong>OrderNo</strong></th>
<th><strong>Id_P</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>77895</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>44678</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>22456</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24562</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>34764</td>
<td>65</td>
</tr>
</tbody>
</table>
<h3 id="-right-join-">右连接（RIGHT JOIN）实例</h3>
<p>现在，我们希望列出所有的定单，以及定购它们的人 - 如果有的话。</p>
<p>您可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo

FROM Persons

RIGHT JOIN Orders

ON Persons.Id_P=Orders.Id_P

ORDER BY Persons.LastName
</code></pre><p>结果集：</p>
<table>
<thead>
<tr>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>OrderNo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
<td>22456</td>
</tr>
<tr>
<td>Adams</td>
<td>John</td>
<td>24562</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>77895</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>44678</td>
</tr>
<tr>
<td>34764</td>
</tr>
</tbody>
</table>
<p>RIGHT JOIN 关键字会从右表 (Orders) 那里返回所有的行，即使在左表 (Persons)中没有匹配的行。</p>
<hr>
<h2 id="sql-full-join">SQL Full Join</h2>
<h3 id="sql-full-join-">SQL FULL JOIN 关键字</h3>
<p>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。</p>
<h4 id="full-join-">FULL JOIN 关键字语法</h4>
<pre><code>SELECT column_name(s)

FROM table_name1

FULL JOIN table_name2

ON table_name1.column_name=table_name2.column_name
</code></pre><p><strong>注释：</strong>在某些数据库中， FULL JOIN 称为 FULL OUTER JOIN。</p>
<h3 id="-">原始的表 (用在例子中的)：</h3>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>“Orders” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_O</strong></th>
<th><strong>OrderNo</strong></th>
<th><strong>Id_P</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>77895</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>44678</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>22456</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24562</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>34764</td>
<td>65</td>
</tr>
</tbody>
</table>
<h3 id="-full-join-">全连接（FULL JOIN）实例</h3>
<p>现在，我们希望列出所有的人，以及他们的定单，以及所有的定单，以及定购它们的人。</p>
<p>您可以使用下面的 SELECT 语句：</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo

FROM Persons

FULL JOIN Orders

ON Persons.Id_P=Orders.Id_P

ORDER BY Persons.LastName
</code></pre><p>结果集：</p>
<table>
<thead>
<tr>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>OrderNo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adams</td>
<td>John</td>
<td>22456</td>
</tr>
<tr>
<td>Adams</td>
<td>John</td>
<td>24562</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>77895</td>
</tr>
<tr>
<td>Carter</td>
<td>Thomas</td>
<td>44678</td>
</tr>
<tr>
<td>Bush</td>
<td>George</td>
</tr>
<tr>
<td>34764</td>
</tr>
</tbody>
</table>
<p>FULL JOIN 关键字会从左表 (Persons) 和右表 (Orders) 那里返回所有的行。如果”Persons” 中的行在表 “Orders” 中没有匹配，或者如果 “Orders” 中的行在表 “Persons”中没有匹配，这些行同样会列出。</p>
<hr>
<h2 id="sql-union">SQL Union</h2>
<h3 id="sql-union-">SQL UNION 操作符</h3>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的 SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT语句中的列的顺序必须相同。</p>
<h4 id="sql-union-">SQL UNION 语法</h4>
<pre><code>SELECT column_name(s) FROM table_name1

UNION

SELECT column_name(s) FROM table_name2
</code></pre><p><strong>注释：</strong>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p>
<h4 id="sql-union-all-">SQL UNION ALL 语法</h4>
<pre><code>SELECT column_name(s) FROM table_name1

UNION ALL

SELECT column_name(s) FROM table_name2
</code></pre><p>另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<h3 id="-">下面的例子中使用的原始表：</h3>
<h4 id="employees_china-">Employees_China:</h4>
<table>
<thead>
<tr>
<th><strong>E_ID</strong></th>
<th><strong>E_Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>Zhang, Hua</td>
</tr>
<tr>
<td>02</td>
<td>Wang, Wei</td>
</tr>
<tr>
<td>03</td>
<td>Carter, Thomas</td>
</tr>
<tr>
<td>04</td>
<td>Yang, Ming</td>
</tr>
</tbody>
</table>
<h4 id="employees_usa-">Employees_USA:</h4>
<table>
<thead>
<tr>
<th><strong>E_ID</strong></th>
<th><strong>E_Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>Adams, John</td>
</tr>
<tr>
<td>02</td>
<td>Bush, George</td>
</tr>
<tr>
<td>03</td>
<td>Carter, Thomas</td>
</tr>
<tr>
<td>04</td>
<td>Gates, Bill</td>
</tr>
</tbody>
</table>
<h3 id="-union-">使用 UNION 命令</h3>
<h4 id="-">实例</h4>
<p>列出所有在中国和美国的不同的雇员名：</p>
<pre><code>SELECT E_Name FROM Employees_China

UNION

SELECT E_Name FROM Employees_USA
</code></pre><h4 id="-">结果</h4>
<table>
<thead>
<tr>
<th><strong>E_Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Zhang, Hua</td>
</tr>
<tr>
<td>Wang, Wei</td>
</tr>
<tr>
<td>Carter, Thomas</td>
</tr>
<tr>
<td>Yang, Ming</td>
</tr>
<tr>
<td>Adams, John</td>
</tr>
<tr>
<td>Bush, George</td>
</tr>
<tr>
<td>Gates, Bill</td>
</tr>
</tbody>
</table>
<p><strong>注释：</strong>这个命令无法列出在中国和美国的所有雇员。在上面的例子中，我们有两个名字相同的雇员，他们当中只有一个人被列出来了。UNION<br>命令只会选取不同的值。</p>
<h3 id="union-all">UNION ALL</h3>
<p>UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。</p>
<pre><code>SQL Statement 1

UNION ALL

SQL Statement 2
</code></pre><h3 id="-union-all-">使用 UNION ALL 命令</h3>
<h4 id="-">实例：</h4>
<p>列出在中国和美国的所有的雇员：</p>
<pre><code>SELECT E_Name FROM Employees_China

UNION ALL

SELECT E_Name FROM Employees_USA
</code></pre><h4 id="-">结果</h4>
<table>
<thead>
<tr>
<th><strong>E_Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Zhang, Hua</td>
</tr>
<tr>
<td>Wang, Wei</td>
</tr>
<tr>
<td>Carter, Thomas</td>
</tr>
<tr>
<td>Yang, Ming</td>
</tr>
<tr>
<td>Adams, John</td>
</tr>
<tr>
<td>Bush, George</td>
</tr>
<tr>
<td>Carter, Thomas</td>
</tr>
<tr>
<td>Gates, Bill</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="sql-select-into">SQL Select Into</h2>
<p><strong>SQL SELECT INTO 语句可用于创建表的备份复件。</strong></p>
<h3 id="select-into-">SELECT INTO 语句</h3>
<p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p>
<p>SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。</p>
<h4 id="sql-select-into-">SQL SELECT INTO 语法</h4>
<p>您可以把所有的列插入新表：</p>
<pre><code>SELECT \*

INTO new_table_name [IN externaldatabase]

FROM old_tablename
</code></pre><p>或者只把希望的列插入新表：</p>
<pre><code>SELECT column_name(s)

INTO new_table_name [IN externaldatabase]

FROM old_tablename
</code></pre><h3 id="sql-select-into-">SQL SELECT INTO 实例 - 制作备份复件</h3>
<p>下面的例子会制作 “Persons” 表的备份复件：</p>
<pre><code>SELECT \*

INTO Persons_backup

FROM Persons
</code></pre><p>IN 子句可用于向另一个数据库中拷贝表：</p>
<pre><code>SELECT \*

INTO Persons IN &#39;Backup.mdb&#39;

FROM Persons
</code></pre><p>如果我们希望拷贝某些域，可以在 SELECT 语句后列出这些域：</p>
<pre><code>SELECT LastName,FirstName

INTO Persons_backup

FROM Persons
</code></pre><h3 id="sql-select-into-where-">SQL SELECT INTO 实例 - 带有 WHERE 子句</h3>
<p>我们也可以添加 WHERE 子句。</p>
<p>下面的例子通过从 “Persons” 表中提取居住在 “Beijing”的人的信息，创建了一个带有两个列的名为 “Persons_backup” 的表：</p>
<pre><code>SELECT LastName,Firstname

INTO Persons_backup

FROM Persons

WHERE City=&#39;Beijing&#39;
</code></pre><h3 id="sql-select-into-">SQL SELECT INTO 实例 - 被连接的表</h3>
<p>从一个以上的表中选取数据也是可以做到的。</p>
<p>下面的例子会创建一个名为 “Persons_Order_Backup” 的新表，其中包含了从 Persons 和Orders 两个表中取得的信息：</p>
<pre><code>SELECT Persons.LastName,Orders.OrderNo

INTO Persons_Order_Backup

FROM Persons

INNER JOIN Orders

ON Persons.Id_P=Orders.Id_P
</code></pre><hr>
<h2 id="sql-create-db">SQL Create DB</h2>
<h3 id="create-database-">CREATE DATABASE 语句</h3>
<p>CREATE DATABASE 用于创建数据库。</p>
<h4 id="sql-create-database-">SQL CREATE DATABASE 语法</h4>
<pre><code>CREATE DATABASE database_name
</code></pre><h3 id="sql-create-database-">SQL CREATE DATABASE 实例</h3>
<p>现在我们希望创建一个名为 “my_db” 的数据库。</p>
<p>我们使用下面的 CREATE DATABASE 语句：</p>
<pre><code>CREATE DATABASE my_db
</code></pre><p>可以通过 CREATE TABLE 来添加数据库表。</p>
<hr>
<h2 id="sql-create-table">SQL Create Table</h2>
<p><strong>CREATE TABLE 语句</strong></p>
<p>CREATE TABLE 语句用于创建数据库中的表。</p>
<h3 id="-sql-create-table-"><strong>SQL CREATE TABLE 语法</strong></h3>
<pre><code>CREATE TABLE 表名称

(

列名称1 数据类型,

列名称2 数据类型,

列名称3 数据类型,

....

)
</code></pre><p>数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了SQL中最常用的数据类型：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>integer(size) int(size) smallint(size) tinyint(size)</td>
<td>仅容纳整数。在括号内规定数字的最大位数。</td>
</tr>
<tr>
<td>decimal(size,d) numeric(size,d)</td>
<td>容纳带有小数的数字。 “size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>char(size)</td>
<td>容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。 在括号中规定字符串的长度。</td>
</tr>
<tr>
<td>varchar(size)</td>
<td>容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。 在括号中规定字符串的最大长度。</td>
</tr>
<tr>
<td>date(yyyymmdd)</td>
<td>容纳日期。</td>
</tr>
</tbody>
</table>
<h3 id="-sql-create-table-"><strong>SQL CREATE TABLE 实例</strong></h3>
<p>本例演示如何创建名为 “Person” 的表。</p>
<p>该表包含 5 个列，列名分别是：”Id_P”、”LastName”、”FirstName”、”Address” 以及”City”：</p>
<pre><code>CREATE TABLE Persons

(

Id_P int,

LastName varchar(255),

FirstName varchar(255),

Address varchar(255),

City varchar(255)

)
</code></pre><p>Id_P 列的数据类型是 int，包含整数。其余 4 列的数据类型是 varchar，最大长度为 255<br>个字符。</p>
<p>空的 “Persons” 表类似这样：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
</tr>
</tbody>
</table>
<p>可使用 INSERT INTO 语句向空表写入数据。</p>
<hr>
<h2 id="sql-constraints">SQL Constraints</h2>
<p><strong>SQL 约束</strong></p>
<p>约束用于限制加入表的数据的类型。</p>
<p>可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过<br>ALTER TABLE 语句）。</p>
<p>我们将主要探讨以下几种约束：</p>
<ul>
<li><p>NOT NULL</p>
</li><li><p>UNIQUE</p>
</li><li><p>PRIMARY KEY</p>
</li><li><p>FOREIGN KEY</p>
</li><li><p>CHECK</p>
</li><li><p>DEFAULT</p>
</li></ul>
<p><strong>注释：</strong>在下面的章节，我们会详细讲解每一种约束。</p>
<hr>
<h2 id="sql-not-null">SQL Not Null</h2>
<h3 id="sql-not-null-">SQL NOT NULL 约束</h3>
<p>NOT NULL 约束强制列不接受 NULL 值。</p>
<p><strong>NOT NULL</strong><br>约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p>
<p>下面的 SQL 语句强制 “Id_P” 列和 “LastName” 列不接受 NULL 值：</p>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255)

)
</code></pre><hr>
<h2 id="sql-unique">SQL Unique</h2>
<h3 id="sql-unique-">SQL UNIQUE 约束</h3>
<p>UNIQUE 约束唯一标识数据库表中的每条记录。</p>
<p>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>
<p>PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p>
<p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p>
<h3 id="sql-unique-constraint-on-create-table">SQL UNIQUE Constraint on CREATE TABLE</h3>
<p>下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 UNIQUE 约束：</p>
<h4 id="mysql-">MySQL:</h4>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255),

UNIQUE (Id_P)

)
</code></pre><h4 id="sql-server-oracle-ms-access-">SQL Server / Oracle / MS Access:</h4>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL UNIQUE,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255)

)
</code></pre><p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255),

CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)

)
</code></pre><h3 id="sql-unique-constraint-on-alter-table">SQL UNIQUE Constraint on ALTER TABLE</h3>
<p>当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Persons

ADD UNIQUE (Id_P)

如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：
</code></pre><h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Persons

ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)
</code></pre><h3 id="-unique-">撤销 UNIQUE 约束</h3>
<p>如需撤销 UNIQUE 约束，请使用下面的 SQL：</p>
<h4 id="mysql-">MySQL:</h4>
<pre><code>ALTER TABLE Persons

DROP INDEX uc_PersonID
</code></pre><h4 id="sql-server-oracle-ms-access-">SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Persons

DROP CONSTRAINT uc_PersonID
</code></pre><hr>
<h2 id="sql-primary-key">SQL Primary Key</h2>
<h3 id="sql-primary-key-">SQL PRIMARY KEY 约束</h3>
<p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p>
<p>主键必须包含唯一的值。</p>
<p>主键列不能包含 NULL 值。</p>
<p>每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<h3 id="sql-primary-key-constraint-on-create-table">SQL PRIMARY KEY Constraint on CREATE TABLE</h3>
<p>下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 PRIMARY KEY 约束：</p>
<h4 id="mysql-">MySQL:</h4>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255),

PRIMARY KEY (Id_P)

)
</code></pre><h4 id="sql-server-oracle-ms-access-">SQL Server / Oracle / MS Access:</h4>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL PRIMARY KEY,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255)

)
</code></pre><p>如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的SQL 语法：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL,

LastName varchar(255) NOT NULL,

FirstName varchar(255),

Address varchar(255),

City varchar(255),

CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)

)
</code></pre><h3 id="sql-primary-key-constraint-on-alter-table">SQL PRIMARY KEY Constraint on ALTER TABLE</h3>
<p>如果在表已存在的情况下为 “Id_P” 列创建 PRIMARY KEY 约束，请使用下面的 SQL：</p>
<h3 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h3>
<pre><code>ALTER TABLE Persons

ADD PRIMARY KEY (Id_P)
</code></pre><p>如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的SQL 语法：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Persons

ADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)
</code></pre><p><strong>注释：</strong>如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL值（在表首次创建时）。</p>
<h3 id="-primary-key-">撤销 PRIMARY KEY 约束</h3>
<p>如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：</p>
<h4 id="mysql-">MySQL:</h4>
<pre><code>ALTER TABLE Persons

DROP PRIMARY KEY
</code></pre><h4 id="sql-server-oracle-ms-access-">SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Persons

DROP CONSTRAINT pk_PersonID
</code></pre><hr>
<h2 id="sql-foreign-key">SQL Foreign Key</h2>
<h3 id="sql-foreign-key-">SQL FOREIGN KEY 约束</h3>
<p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p>
<p>让我们通过一个例子来解释外键。请看下面两个表：</p>
<p>“Persons” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_P</strong></th>
<th><strong>LastName</strong></th>
<th><strong>FirstName</strong></th>
<th><strong>Address</strong></th>
<th><strong>City</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Adams</td>
<td>John</td>
<td>Oxford Street</td>
<td>London</td>
</tr>
<tr>
<td>2</td>
<td>Bush</td>
<td>George</td>
<td>Fifth Avenue</td>
<td>New York</td>
</tr>
<tr>
<td>3</td>
<td>Carter</td>
<td>Thomas</td>
<td>Changan Street</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>“Orders” 表：</p>
<table>
<thead>
<tr>
<th><strong>Id_O</strong></th>
<th><strong>OrderNo</strong></th>
<th><strong>Id_P</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>77895</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>44678</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>22456</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24562</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>请注意，”Orders” 中的 “Id_P” 列指向 “Persons” 表中的 “Id_P” 列。</p>
<p>“Persons” 表中的 “Id_P” 列是 “Persons” 表中的 PRIMARY KEY。</p>
<p>“Orders” 表中的 “Id_P” 列是 “Orders” 表中的 FOREIGN KEY。</p>
<p>FOREIGN KEY 约束用于预防破坏表之间连接的动作。</p>
<p>FOREIGN KEY约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<h3 id="sql-foreign-key-constraint-on-create-table">SQL FOREIGN KEY Constraint on CREATE TABLE</h3>
<p>下面的 SQL 在 “Orders” 表创建时为 “Id_P” 列创建 FOREIGN KEY：</p>
<h4 id="mysql-">MySQL:</h4>
<pre><code>CREATE TABLE Orders

(

Id_O int NOT NULL,

OrderNo int NOT NULL,

Id_P int,

PRIMARY KEY (Id_O),

FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)

)
</code></pre><h4 id="sql-server-oracle-ms-access-">SQL Server / Oracle / MS Access:</h4>
<pre><code>CREATE TABLE Orders

(

Id_O int NOT NULL PRIMARY KEY,

OrderNo int NOT NULL,

Id_P int FOREIGN KEY REFERENCES Persons(Id_P)

)
</code></pre><p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的SQL 语法：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>CREATE TABLE Orders

(

Id_O int NOT NULL,

OrderNo int NOT NULL,

Id_P int,

PRIMARY KEY (Id_O),

CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)

REFERENCES Persons(Id_P)

)
</code></pre><h3 id="sql-foreign-key-constraint-on-alter-table">SQL FOREIGN KEY Constraint on ALTER TABLE</h3>
<p>如果在 “Orders” 表已存在的情况下为 “Id_P” 列创建 FOREIGN KEY 约束，请使用下面的SQL：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Orders

ADD FOREIGN KEY (Id_P)

REFERENCES Persons(Id_P)
</code></pre><p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的SQL 语法：</p>
<h4 id="mysql-sql-server-oracle-ms-access-">MySQL / SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Orders

ADD CONSTRAINT fk_PerOrders

FOREIGN KEY (Id_P)

REFERENCES Persons(Id_P)
</code></pre><h3 id="-foreign-key-">撤销 FOREIGN KEY 约束</h3>
<p>如需撤销 FOREIGN KEY 约束，请使用下面的 SQL：</p>
<h4 id="mysql-">MySQL:</h4>
<pre><code>ALTER TABLE Orders

DROP FOREIGN KEY fk_PerOrders
</code></pre><h4 id="sql-server-oracle-ms-access-">SQL Server / Oracle / MS Access:</h4>
<pre><code>ALTER TABLE Orders

DROP CONSTRAINT fk_PerOrders
</code></pre><hr>
<h2 id="sql-check">SQL Check</h2>
<h3 id="sql-check-">SQL CHECK 约束</h3>
<p>CHECK 约束用于限制列中的值的范围。</p>
<p>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p>
<p>如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</p>
<h4 id="sql-check-constraint-on-create-table">SQL CHECK Constraint on CREATE TABLE</h4>
<p>下面的 SQL 在 “Persons” 表创建时为 “Id_P” 列创建 CHECK 约束。CHECK 约束规定”Id_P” 列必须只包含大于 0 的整数。</p>
<ul>
<li>My SQL:<br>```<br>CREATE TABLE Persons</li></ul>
<p>(</p>
<p>Id_P int NOT NULL,</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255),</p>
<p>CHECK (Id_P>0)</p>
<p>)</p>
<pre><code>+ SQL Server / Oracle / MS Access:
</code></pre><p>CREATE TABLE Persons</p>
<p>(</p>
<p>Id_P int NOT NULL CHECK (Id_P>0),</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255)</p>
<p>)```</p>
<p>如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法：</p>
<ul>
<li>MySQL / SQL Server / Oracle / MS Access:<br>```<br>CREATE TABLE Persons</li></ul>
<p>(</p>
<p>Id_P int NOT NULL,</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255),</p>
<p>CONSTRAINT chk_Person CHECK (Id_P>0 AND City=’Sandnes’)</p>
<p>)</p>
<pre><code>#### SQL CHECK Constraint on ALTER TABLE

如果在表已存在的情况下为 &quot;Id_P&quot; 列创建 CHECK 约束，请使用下面的 SQL：

+ MySQL / SQL Server / Oracle / MS Access:
</code></pre><p>ALTER TABLE Persons</p>
<p>ADD CHECK (Id_P>0)</p>
<pre><code>如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法：

+ MySQL / SQL Server / Oracle / MS Access:
</code></pre><p>ALTER TABLE Persons</p>
<p>ADD CONSTRAINT chk_Person CHECK (Id_P>0 AND City=’Sandnes’)</p>
<pre><code>### 撤销 CHECK 约束

如需撤销 CHECK 约束，请使用下面的 SQL：

+ SQL Server / Oracle / MS Access:

ALTER TABLE Persons

DROP CONSTRAINT chk_Person

+ MySQL:
</code></pre><p>ALTER TABLE Persons</p>
<p>DROP CHECK chk_Person</p>
<pre><code>

---

## SQL Default

### SQL DEFAULT 约束

DEFAULT 约束用于向列中插入默认值。

如果没有规定其他的值，那么会将默认值添加到所有的新记录。

#### SQL DEFAULT Constraint on CREATE TABLE

下面的 SQL 在 &quot;Persons&quot; 表创建时为 &quot;City&quot; 列创建 DEFAULT 约束：

+ My SQL / SQL Server / Oracle / MS Access:
</code></pre><p>CREATE TABLE Persons</p>
<p>(</p>
<p>Id_P int NOT NULL,</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255) DEFAULT ‘Sandnes’</p>
<p>)</p>
<pre><code>
通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：
</code></pre><p>CREATE TABLE Orders</p>
<p>(</p>
<p>Id_O int NOT NULL,</p>
<p>OrderNo int NOT NULL,</p>
<p>Id_P int,</p>
<p>OrderDate date DEFAULT GETDATE()</p>
<p>)</p>
<pre><code>


#### SQL DEFAULT Constraint on ALTER TABLE

如果在表已存在的情况下为 &quot;City&quot; 列创建 DEFAULT 约束，请使用下面的 SQL：


+ MySQL:
</code></pre><p>ALTER TABLE Persons</p>
<p>ALTER City SET DEFAULT ‘SANDNES’</p>
<pre><code>
+ SQL Server / Oracle / MS Access:
</code></pre><p>ALTER TABLE Persons</p>
<p>ALTER COLUMN City SET DEFAULT ‘SANDNES’</p>
<pre><code>### 撤销 DEFAULT 约束

如需撤销 DEFAULT 约束，请使用下面的 SQL：

+ MySQL:
</code></pre><p>ALTER TABLE Persons</p>
<p>ALTER City DROP DEFAULT</p>
<pre><code>
+ SQL Server / Oracle / MS Access:
</code></pre><p>ALTER TABLE Persons</p>
<p>ALTER COLUMN City DROP DEFAULT</p>
<pre><code>




---

## SQL Create Index

**CREATE INDEX 语句用于在表中创建索引。**

**在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。**

### 索引

您可以在表中创建索引，以便更加快速高效地查询数据。

用户无法看到索引，它们只能被用来加速搜索/查询。

**注释：**更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。

#### SQL CREATE INDEX 语法

在表上创建一个简单的索引。允许使用重复的值：
</code></pre><p>CREATE INDEX index_name</p>
<p>ON table_name (column_name)</p>
<pre><code>**注释：**&quot;column_name&quot; 规定需要索引的列。

#### SQL CREATE UNIQUE INDEX 语法

在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。
</code></pre><p>CREATE UNIQUE INDEX index_name</p>
<p>ON table_name (column_name)</p>
<pre><code>### CREATE INDEX 实例

本例会创建一个简单的索引，名为 &quot;PersonIndex&quot;，在 Person 表的 LastName 列：
</code></pre><p>CREATE INDEX PersonIndex</p>
<p>ON Person (LastName)</p>
<pre><code>如果您希望以*降序*索引某个列中的值，您可以在列名称之后添加保留字 *DESC*：
</code></pre><p>CREATE INDEX PersonIndex</p>
<p>ON Person (LastName DESC)</p>
<pre><code>假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：
</code></pre><p>CREATE INDEX PersonIndex</p>
<p>ON Person (LastName, FirstName)</p>
<pre><code>


---

## SQL Drop

**通过使用 DROP 语句，可以轻松地删除索引、表和数据库。**

### SQL DROP INDEX 语句

我们可以使用 DROP INDEX 命令删除表格中的索引。

用于 **Microsoft SQLJet (以及 Microsoft Access)** 的语法:
</code></pre><p>DROP INDEX index_name ON table_name</p>
<pre><code>用于 **MS SQL Server** 的语法:
</code></pre><p>DROP INDEX table_name.index_name</p>
<pre><code>用于 **IBM DB2 和 Oracle** 语法:
</code></pre><p>DROP INDEX index_name</p>
<pre><code>用于 **MySQL** 的语法:
</code></pre><p>ALTER TABLE table_name DROP INDEX index_name</p>
<pre><code>### SQL DROP TABLE 语句

DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）：
</code></pre><p>DROP TABLE 表名称</p>
<pre><code>
### SQL DROP DATABASE 语句
</code></pre><p>DROP DATABASE 语句用于删除数据库：</p>
<p>DROP DATABASE 数据库名称</p>
<pre><code>### SQL TRUNCATE TABLE 语句

如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？

请使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）：
</code></pre><p>TRUNCATE TABLE 表名称</p>
<pre><code>





---

## SQL Alter

### ALTER TABLE 语句

ALTER TABLE 语句用于在已有的表中添加、修改或删除列。

#### SQL ALTER TABLE 语法

如需在表中添加列，请使用下列语法:
</code></pre><p>ALTER TABLE table_name</p>
<p>ADD column_name datatype</p>
<pre><code>要删除表中的列，请使用下列语法：
</code></pre><p>ALTER TABLE table_name</p>
<p>DROP COLUMN column_name</p>
<pre><code>**注释：**某些数据库系统不允许这种在数据库表中删除列的方式 (DROP COLUMN column_name)。

要改变表中列的数据类型，请使用下列语法：
</code></pre><p>ALTER TABLE table_name</p>
<p>ALTER COLUMN column_name datatype</p>
<pre><code>### 原始的表 (用在例子中的)：

Persons 表:

| **Id** | **LastName** | **FirstName** | **Address**    | **City** |
|--------|--------------|---------------|----------------|----------|
| 1      | Adams        | John          | Oxford Street  | London   |
| 2      | Bush         | George        | Fifth Avenue   | New York |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |

### SQL ALTER TABLE 实例

现在，我们希望在表 &quot;Persons&quot; 中添加一个名为 &quot;Birthday&quot; 的新列。

我们使用下列 SQL 语句：
</code></pre><p>ALTER TABLE Persons</p>
<p>ADD Birthday date</p>
<pre><code>请注意，新列 &quot;Birthday&quot; 的类型是date，可以存放日期。数据类型规定列中可以存放的数据的类型。

新的 &quot;Persons&quot; 表类似这样：

| **Id** | **LastName** | **FirstName** | **Address**    | **City** | **Birthday** |
|--------|--------------|---------------|----------------|----------|--------------|
| 1      | Adams        | John          | Oxford Street  | London   |        /      |
| 2      | Bush         | George        | Fifth Avenue   | New York |       /       |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |        /      |

### 改变数据类型实例

现在我们希望改变 &quot;Persons&quot; 表中 &quot;Birthday&quot; 列的数据类型。

我们使用下列 SQL 语句：
</code></pre><p>ALTER TABLE Persons</p>
<p>ALTER COLUMN Birthday year</p>
<pre><code>请注意，&quot;Birthday&quot; 列的数据类型是 year，可以存放 2 位或 4 位格式的年份。

### DROP COLUMN 实例

接下来，我们删除 &quot;Person&quot; 表中的 &quot;Birthday&quot; 列：
</code></pre><p>ALTER TABLE Person</p>
<p>DROP COLUMN Birthday</p>
<pre><code>Persons 表会成为这样:

| **Id** | **LastName** | **FirstName** | **Address**    | **City** |
|--------|--------------|---------------|----------------|----------|
| 1      | Adams        | John          | Oxford Street  | London   |
| 2      | Bush         | George        | Fifth Avenue   | New York |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |





---

## SQL Increment

**Auto-increment 会在新记录插入表中时生成一个唯一的数字。**

### AUTO INCREMENT 字段

我们通常希望在每次插入新记录时，自动地创建主键字段的值。

我们可以在表中创建一个 auto-increment 字段。

### 用于 MySQL 的语法

下列 SQL 语句把 &quot;Persons&quot; 表中的 &quot;P_Id&quot; 列定义为 auto-increment 主键：
</code></pre><p>CREATE TABLE Persons</p>
<p>(</p>
<p>P_Id int NOT NULL AUTO_INCREMENT,</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255),</p>
<p>PRIMARY KEY (P_Id)</p>
<p>)</p>
<pre><code>MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务。

默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。

要让 AUTO_INCREMENT 序列以其他的值起始，请使用下列 SQL 语法：
</code></pre><p>ALTER TABLE Persons AUTO_INCREMENT=100</p>
<pre><code>要在 &quot;Persons&quot; 表中插入新记录，我们不必为 &quot;P_Id&quot;列规定值（会自动添加一个唯一的值）：
</code></pre><p>INSERT INTO Persons (FirstName,LastName)</p>
<p>VALUES (‘Bill’,’Gates’)</p>
<pre><code>上面的 SQL 语句会在 &quot;Persons&quot; 表中插入一条新记录。&quot;P_Id&quot;会被赋予一个唯一的值。&quot;FirstName&quot; 会被设置为 &quot;Bill&quot;，&quot;LastName&quot; 列会被设置为&quot;Gates&quot;。

### 用于 SQL Server 的语法

下列 SQL 语句把 &quot;Persons&quot; 表中的 &quot;P_Id&quot; 列定义为 auto-increment 主键：
</code></pre><p>CREATE TABLE Persons</p>
<p>(</p>
<p>P_Id int PRIMARY KEY IDENTITY,</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255)</p>
<p>)</p>
<pre><code>MS SQL 使用 IDENTITY 关键字来执行 auto-increment 任务。

默认地，IDENTITY 的开始值是 1，每条新记录递增 1。

要规定 &quot;P_Id&quot; 列以 20 起始且递增 10，请把 identity 改为 IDENTITY(20,10)

要在 &quot;Persons&quot; 表中插入新记录，我们不必为 &quot;P_Id&quot;列规定值（会自动添加一个唯一的值）：
</code></pre><p>INSERT INTO Persons (FirstName,LastName)</p>
<p>VALUES (‘Bill’,’Gates’)</p>
<pre><code>上面的 SQL 语句会在 &quot;Persons&quot; 表中插入一条新记录。&quot;P_Id&quot;会被赋予一个唯一的值。&quot;FirstName&quot; 会被设置为 &quot;Bill&quot;，&quot;LastName&quot; 列会被设置为&quot;Gates&quot;。

### 用于 Access 的语法

下列 SQL 语句把 &quot;Persons&quot; 表中的 &quot;P_Id&quot; 列定义为 auto-increment 主键：
</code></pre><p>CREATE TABLE Persons</p>
<p>(</p>
<p>P_Id int PRIMARY KEY AUTOINCREMENT,</p>
<p>LastName varchar(255) NOT NULL,</p>
<p>FirstName varchar(255),</p>
<p>Address varchar(255),</p>
<p>City varchar(255)</p>
<p>)</p>
<pre><code>MS Access 使用 AUTOINCREMENT 关键字来执行 auto-increment 任务。

默认地，AUTOINCREMENT 的开始值是 1，每条新记录递增 1。

要规定 &quot;P_Id&quot; 列以 20 起始且递增 10，请把 autoincrement 改为AUTOINCREMENT(20,10)

要在 &quot;Persons&quot; 表中插入新记录，我们不必为 &quot;P_Id&quot;列规定值（会自动添加一个唯一的值）：
</code></pre><p>INSERT INTO Persons (FirstName,LastName)</p>
<p>VALUES (‘Bill’,’Gates’)</p>
<pre><code>上面的 SQL 语句会在 &quot;Persons&quot; 表中插入一条新记录。&quot;P_Id&quot;会被赋予一个唯一的值。&quot;FirstName&quot; 会被设置为 &quot;Bill&quot;，&quot;LastName&quot; 列会被设置为&quot;Gates&quot;。

### 用于 Oracle 的语法

在 Oracle 中，代码稍微复杂一点。

您必须通过 sequence 对创建 auto-increment 字段（该对象生成数字序列）。

请使用下面的 CREATE SEQUENCE 语法：
</code></pre><p>CREATE SEQUENCE seq_person</p>
<p>MINVALUE 1</p>
<p>START WITH 1</p>
<p>INCREMENT BY 1</p>
<p>CACHE 10</p>
<pre><code>上面的代码创建名为 seq_person 的序列对象，它以 1 起始且以 1 递增。该对象缓存 10个值以提高性能。CACHE 选项规定了为了提高访问速度要存储多少个序列值。

要在 &quot;Persons&quot; 表中插入新记录，我们必须使用 nextval 函数（该函数从 seq_person序列中取回下一个值）：
</code></pre><p>INSERT INTO Persons (P_Id,FirstName,LastName)</p>
<p>VALUES (seq_person.nextval,’Lars’,’Monsen’)</p>
<pre><code>上面的 SQL 语句会在 &quot;Persons&quot; 表中插入一条新记录。&quot;P_Id&quot; 的赋值是来自 seq_person序列的下一个数字。&quot;FirstName&quot; 会被设置为 &quot;Bill&quot;，&quot;LastName&quot; 列会被设置为&quot;Gates&quot;。






---

## SQL View

**视图是可视化的表。**

**本章讲解如何创建、更新和删除视图。**

### SQL CREATE VIEW 语句

#### 什么是视图？

在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。

视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。

**注释：**数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。

#### SQL CREATE VIEW 语法
</code></pre><p>CREATE VIEW view_name AS</p>
<p>SELECT column_name(s)</p>
<p>FROM table_name</p>
<p>WHERE condition</p>
<pre><code>**注释：**视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL语句来重建数据。

### SQL CREATE VIEW 实例

可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join
等等，我们可以向用户精确地提交我们希望提交的数据。

样本数据库 Northwind 拥有一些被默认安装的视图。视图 &quot;Current Product List&quot; 会从Products 表列出所有正在使用的产品。这个视图使用下列 SQL 创建：
</code></pre><p>CREATE VIEW [Current Product List] AS</p>
<p>SELECT ProductID,ProductName</p>
<p>FROM Products</p>
<p>WHERE Discontinued=No</p>
<pre><code>我们可以查询上面这个视图：
</code></pre><p>SELECT * FROM [Current Product List]</p>
<pre><code>Northwind 样本数据库的另一个视图会选取 Products表中所有单位价格高于平均单位价格的产品：
</code></pre><p>CREATE VIEW [Products Above Average Price] AS</p>
<p>SELECT ProductName,UnitPrice</p>
<p>FROM Products</p>
<p>WHERE UnitPrice>(SELECT AVG(UnitPrice) FROM Products)</p>
<pre><code>我们可以像这样查询上面这个视图：
</code></pre><p>SELECT * FROM [Products Above Average Price]</p>
<pre><code>另一个来自 Northwind 数据库的视图实例会计算在 1997年每个种类的销售总数。请注意，这个视图会从另一个名为 &quot;Product Sales for 1997&quot;的视图那里选取数据：
</code></pre><p>CREATE VIEW [Category Sales For 1997] AS</p>
<p>SELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySales</p>
<p>FROM [Product Sales for 1997]</p>
<p>GROUP BY CategoryName</p>
<pre><code>我们可以像这样查询上面这个视图：
</code></pre><p>SELECT * FROM [Category Sales For 1997]</p>
<pre><code>我们也可以向查询添加条件。现在，我们仅仅需要查看 &quot;Beverages&quot; 类的全部销量：
</code></pre><p>SELECT * FROM [Category Sales For 1997]</p>
<p>WHERE CategoryName=’Beverages’</p>
<pre><code>### SQL 更新视图

您可以使用下面的语法来更新视图：
</code></pre><p>SQL CREATE OR REPLACE VIEW Syntax</p>
<p>CREATE OR REPLACE VIEW view_name AS</p>
<p>SELECT column_name(s)</p>
<p>FROM table_name</p>
<p>WHERE condition</p>
<pre><code>现在，我们希望向 &quot;Current Product List&quot; 视图添加 &quot;Category&quot; 列。我们将通过下列SQL 更新视图：
</code></pre><p>CREATE VIEW [Current Product List] AS</p>
<p>SELECT ProductID,ProductName,Category</p>
<p>FROM Products</p>
<p>WHERE Discontinued=No</p>
<pre><code>### SQL 撤销视图

您可以通过 DROP VIEW 命令来删除视图。
</code></pre><p>SQL DROP VIEW Syntax</p>
<p>DROP VIEW view_name</p>
<pre><code>



---

## SQL Date

### **SQL 日期**

当我们处理日期时，最难的任务恐怕是确保所插入的日期的格式，与数据库中日期列的格式相匹配。

只要数据包含的只是日期部分，运行查询就不会出问题。但是，如果涉及时间，情况就有点复杂了。

在讨论日期查询的复杂性之前，我们先来看看最重要的内建日期处理函数。

### **MySQL Date 函数**

下面的表格列出了 MySQL 中最重要的内建日期函数：

| **函数**                                                              | **描述**                            |
|-----------------------------------------------------------------------|-------------------------------------|
| [NOW()](https://www.w3school.com.cn/sql/func_now.asp)                 | 返回当前的日期和时间                |
| [CURDATE()](https://www.w3school.com.cn/sql/func_curdate.asp)         | 返回当前的日期                      |
| [CURTIME()](https://www.w3school.com.cn/sql/func_curtime.asp)         | 返回当前的时间                      |
| [DATE()](https://www.w3school.com.cn/sql/func_date.asp)               | 提取日期或日期/时间表达式的日期部分 |
| [EXTRACT()](https://www.w3school.com.cn/sql/func_extract.asp)         | 返回日期/时间按的单独部分           |
| [DATE_ADD()](https://www.w3school.com.cn/sql/func_date_add.asp)       | 给日期添加指定的时间间隔            |
| [DATE_SUB()](https://www.w3school.com.cn/sql/func_date_sub.asp)       | 从日期减去指定的时间间隔            |
| [DATEDIFF()](https://www.w3school.com.cn/sql/func_datediff_mysql.asp) | 返回两个日期之间的天数              |
| [DATE_FORMAT()](https://www.w3school.com.cn/sql/func_date_format.asp) | 用不同的格式显示日期/时间           |

### **SQL Server Date 函数**

下面的表格列出了 SQL Server 中最重要的内建日期函数：

| **函数**                                                        | **描述**                         |
|-----------------------------------------------------------------|----------------------------------|
| [GETDATE()](https://www.w3school.com.cn/sql/func_getdate.asp)   | 返回当前日期和时间               |
| [DATEPART()](https://www.w3school.com.cn/sql/func_datepart.asp) | 返回日期/时间的单独部分          |
| [DATEADD()](https://www.w3school.com.cn/sql/func_dateadd.asp)   | 在日期中添加或减去指定的时间间隔 |
| [DATEDIFF()](https://www.w3school.com.cn/sql/func_datediff.asp) | 返回两个日期之间的时间           |
| [CONVERT()](https://www.w3school.com.cn/sql/func_convert.asp)   | 用不同的格式显示日期/时间        |

### **SQL Date 数据类型**

MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：

-   DATE - 格式 YYYY-MM-DD

-   DATETIME - 格式: `YYYY-MM-DD HH:MM:SS`

-   TIMESTAMP - 格式: `YYYY-MM-DD HH:MM:SS`

-   YEAR - 格式 YYYY 或 YY

SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值：

-   DATE - 格式 YYYY-MM-DD

-   DATETIME - 格式: `YYYY-MM-DD HH:MM:SS`

-   SMALLDATETIME - 格式: `YYYY-MM-DD HH:MM:SS`

-   TIMESTAMP - 格式: 唯一的数字

### **SQL 日期处理**

如果不涉及时间部分，那么我们可以轻松地比较两个日期！

假设我们有下面这个 &quot;Orders&quot; 表：

| **OrderId** | **ProductName** | **OrderDate** |
|-------------|-----------------|---------------|
| 1           | computer        | 2008-12-26    |
| 2           | printer         | 2008-12-26    |
| 3           | electrograph    | 2008-11-12    |
| 4           | telephone       | 2008-10-19    |

现在，我们希望从上表中选取 OrderDate 为 &quot;2008-12-26&quot; 的记录。

我们使用如下 SELECT 语句：
</code></pre><p>SELECT * FROM Orders WHERE OrderDate=’2008-12-26’</p>
<pre><code>结果集：

| **OrderId** | **ProductName** | **OrderDate** |
|-------------|-----------------|---------------|
| 1           | computer        | 2008-12-26    |
| 3           | electrograph    | 2008-12-26    |

现在假设 &quot;Orders&quot; 类似这样（请注意 &quot;OrderDate&quot; 列中的时间部分）：

| **OrderId** | **ProductName** | **OrderDate**       |
|-------------|-----------------|---------------------|
| 1           | computer        | `2008-12-26 16:23:55` |
| 2           | printer         | `2008-12-26 10:45:26` |
| 3           | electrograph    | `2008-11-12 14:12:08` |
| 4           | telephone       | `2008-10-19 12:56:10` |

如果我们使用上面的 SELECT 语句：
</code></pre><p>SELECT * FROM Orders WHERE OrderDate=’2008-12-26’</p>
<pre><code>那么我们得不到结果。这是由于该查询不含有时间部分的日期。

**提示：**如果您希望使查询简单且更易维护，那么请不要在日期中使用时间部分！





---

## SQL Nulls

**NULL 值是遗漏的未知数据。**

**默认地，表的列可以存放 NULL 值。**

**本章讲解 IS NULL 和 IS NOT NULL 操作符。**

### SQL NULL 值

如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以NULL 值保存。

NULL 值的处理方式与其他值不同。

NULL 用作未知的或不适用的值的占位符。

**注释：**无法比较 NULL 和 0；它们是不等价的。

#### SQL 的 NULL 值处理

请看下面的 &quot;Persons&quot; 表：

| **Id** | **LastName** | **FirstName** | **Address**  | **City** |
|--------|------------|------------|------------|----------|
| 1      | Adams        | John          |        /      | London   |
| 2      | Bush         | George        | Fifth Avenue | New York |
| 3      | Carter       | Thomas        |       /       | Beijing  |

假如 &quot;Persons&quot; 表中的 &quot;Address&quot; 列是可选的。这意味着如果在 &quot;Address&quot;列插入一条不带值的记录，&quot;Address&quot; 列会使用 NULL 值保存。

那么我们如何测试 NULL 值呢？

无法使用比较运算符来测试 NULL 值，比如 =, \&lt;, 或者 \&lt;\&gt;。

我们必须使用 IS NULL 和 IS NOT NULL 操作符。

#### SQL IS NULL

我们如何仅仅选取在 &quot;Address&quot; 列中带有 NULL 值的记录呢？

我们必须使用 IS NULL 操作符：
</code></pre><p>SELECT LastName,FirstName,Address FROM Persons</p>
<p>WHERE Address IS NULL</p>
<pre><code>结果集：

| **LastName** | **FirstName** | **Address** |
|--------------|---------------|-------------|
| Adams        | John          |             |
| Carter       | Thomas        |             |

**提示：**请始终使用 IS NULL 来查找 NULL 值。

#### SQL IS NOT NULL

我们如何选取在 &quot;Address&quot; 列中不带有 NULL 值的记录呢？

我们必须使用 IS NOT NULL 操作符：
</code></pre><p>SELECT LastName,FirstName,Address FROM Persons</p>
<p>WHERE Address IS NOT NULL</p>
<pre><code>结果集：

| **LastName** | **FirstName** | **Address**  |
|--------------|---------------|--------------|
| Bush         | George        | Fifth Avenue |

在下一节中，我们了解 ISNULL()、NVL()、IFNULL() 和 COALESCE() 函数。




---

## SQL isnull()

### SQL ISNULL()、NVL()、IFNULL() 和 COALESCE() 函数

请看下面的 &quot;Products&quot; 表：

| **P_Id** | **ProductName** | **UnitPrice** | **UnitsInStock** | **UnitsOnOrder** |
|----------|-----------------|---------------|------------------|------------------|
| 1        | computer        | 699           | 25               | 15               |
| 2        | printer         | 365           | 36               |                  |
| 3        | telephone       | 280           | 159              | 57               |

假如 &quot;UnitsOnOrder&quot; 是可选的，而且可以包含 NULL 值。

我们使用如下 SELECT 语句：
</code></pre><p>SELECT ProductName,UnitPrice*(UnitsInStock+UnitsOnOrder)</p>
<p>FROM Products</p>
<pre><code>在上面的例子中，如果有 &quot;UnitsOnOrder&quot; 值是 NULL，那么结果是 NULL。

微软的 ISNULL() 函数用于规定如何处理 NULL 值。

NVL(), IFNULL() 和 COALESCE() 函数也可以达到相同的结果。

在这里，我们希望 NULL 值为 0。

下面，如果 &quot;UnitsOnOrder&quot; 是 NULL，则不利于计算，因此如果值是 NULL 则 ISNULL()返回 0。

#### SQL Server / MS Access
</code></pre><p>SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))</p>
<p>FROM Products</p>
<pre><code>#### Oracle

Oracle 没有 ISNULL() 函数。不过，我们可以使用 NVL() 函数达到相同的结果：
</code></pre><p>SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))</p>
<p>FROM Products</p>
<pre><code>#### MySQL

MySQL 也拥有类似 ISNULL() 的函数。不过它的工作方式与微软的 ISNULL()函数有点不同。

在 MySQL 中，我们可以使用 IFNULL() 函数，就像这样：
</code></pre><p>SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))</p>
<p>FROM Products</p>
<pre><code>或者我们可以使用 COALESCE() 函数，就像这样：
</code></pre><p>SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))</p>
<p>FROM Products</p>
<pre><code>



---

## SQL 数据类型

**Microsoft Access、MySQL 以及 SQL Server 所使用的数据类型和范围。**

### Microsoft Access 数据类型

| **数据类型**  | **描述** | **存储** |
|---------|----------|----------|
| Text| 用于文本或文本与数字的组合。最多 255 个字符。 |  /  |
| Memo | Memo 用于更大数量的文本。最多存储 65,536 个字符。 注释：无法对 memo 字段进行排序。不过它们是可搜索的。 | / |
| Byte | 允许 0 到 255 的数字。 | 1 字节 |
| Integer | 允许介于 -32,768 到 32,767 之间的数字。 | 2 字节 |
| Long | 允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字 | 4 字节 |
| Single | 单精度浮点。处理大多数小数。 | 4 字节 |
| Double | 双精度浮点。处理大多数小数。 | 8 字节 |
| Currency | 用于货币。支持 15 位的元，外加 4 位小数。 提示：您可以选择使用哪个国家的货币。 | 8 字节 |
| AutoNumber | AutoNumber 字段自动为每条记录分配数字，通常从 1 开始。 | 4 字节 |
| Date/Time | 用于日期和时间 | 8 字节 |
| Yes/No | 逻辑字段，可以显示为 Yes/No、True/False 或 On/Off。 在代码中，使用常量 True 和 False （等价于 1 和 0） 注释：Yes/No 字段中不允许 Null 值 | 1 比特 |
| Ole Object | 可以存储图片、音频、视频或其他 BLOBs (Binary Large OBjects) | 最多 1GB |
| Hyperlink | 包含指向其他文件的链接，包括网页。 | / |
| Lookup Wizard | 允许你创建一个可从下列列表中进行选择的选项列表。 | 4 字节 |



### MySQL 数据类型

在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。

#### Text 类型：

| **数据类型** | **描述** |
|------|-------|
| CHAR(size) | 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 |
| VARCHAR(size) | 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。 注释：如果值的长度大于 255，则被转换为 TEXT 类型。 |
| TINYTEXT | 存放最大长度为 255 个字符的字符串。 |
| TEXT | 存放最大长度为 65,535 个字符的字符串。 |
| BLOB | 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。 |
| MEDIUMTEXT | 存放最大长度为 16,777,215 个字符的字符串。 |
| MEDIUMBLOB | 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。 |
| LONGTEXT | 存放最大长度为 4,294,967,295 个字符的字符串。 |
| LONGBLOB | 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 |
| ENUM(x,y,z,etc.) | 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。 注释：这些值是按照你输入的顺序存储的。 可以按照此格式输入可能的值：ENUM(&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) |
| SET  | 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 |

#### Number 类型：

| **数据类型** | **描述** |
|----|----|
| TINYINT(size)   | \-128 到 127 常规。0 到 255 无符号\*。在括号中规定最大位数。 |
| SMALLINT(size)  | \-32768 到 32767 常规。0 到 65535 无符号\*。在括号中规定最大位数。 |
| MEDIUMINT(size) | \-8388608 到 8388607 普通。0 to 16777215 无符号\*。在括号中规定最大位数。 |
| INT(size) | \-2147483648 到 2147483647 常规。0 到 4294967295 无符号\*。在括号中规定最大位数。 |
| BIGINT(size) | \-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号\*。在括号中规定最大位数。 |
| FLOAT(size,d)   | 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 |
| DOUBLE(size,d)  | 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 |
| DECIMAL(size,d) | 作为字符串存储的 DOUBLE 类型，允许固定的小数点。 |

\* 这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。

#### Date 类型：

| **数据类型** | **描述**  |
|-------|--------|
| DATE()       | 日期。格式：YYYY-MM-DD 注释：支持的范围是从 &#39;1000-01-01&#39; 到 &#39;9999-12-31&#39; |
| DATETIME()   | \*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 &#39;1000-01-01 00:00:00&#39; 到 &#39;9999-12-31 23:59:59&#39; |
| TIMESTAMP()  | \*时间戳。TIMESTAMP 值使用 Unix 纪元(&#39;1970-01-01 00:00:00&#39; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 &#39;1970-01-01 00:00:01&#39; UTC 到 &#39;2038-01-09 03:14:07&#39; UTC |
| TIME() | 时间。格式：HH:MM:SS 注释：支持的范围是从 &#39;-838:59:59&#39; 到 &#39;838:59:59&#39; |
| YEAR() | 2 位或 4 位格式的年。 注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 |

\* 即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。



### SQL Server 数据类型

#### Character 字符串：

| **数据类型** | **描述**                                      | **存储** |
|--------------|-----------------------------------------------|----------|
| char(n)      | 固定长度的字符串。最多 8,000 个字符。         | n        |
| varchar(n)   | 可变长度的字符串。最多 8,000 个字符。         |    /     |
| varchar(max) | 可变长度的字符串。最多 1,073,741,824 个字符。 |    /      |
| text         | 可变长度的字符串。最多 2GB 字符数据。         |     /     |

#### Unicode 字符串：

| **数据类型**  | **描述**                                           | **存储** |
|---------------|-----------------------------------------|----------|
| nchar(n)      | 固定长度的 Unicode 数据。最多 4,000 个字符。       |    /      |
| nvarchar(n)   | 可变长度的 Unicode 数据。最多 4,000 个字符。       |     /     |
| nvarchar(max) | 可变长度的 Unicode 数据。最多 536,870,912 个字符。 |     /     |
| ntext         | 可变长度的 Unicode 数据。最多 2GB 字符数据。       |     /     |

#### Binary 类型：

| **数据类型**   | **描述**                                | **存储** |
|----------------|-----------------------------------------|----------|
| bit            | 允许 0、1 或 NULL                       |   /    |
| binary(n)      | 固定长度的二进制数据。最多 8,000 字节。 |    /    |
| varbinary(n)   | 可变长度的二进制数据。最多 8,000 字节。 |    /    |
| varbinary(max) | 可变长度的二进制数据。最多 2GB 字节。   |   /     |
| image          | 可变长度的二进制数据。最多 2GB。        |  /      |

#### Number 类型：

| **数据类型** | **描述** | **存储** |
|-----|------|-----|
| tinyint      | 允许从 0 到 255 的所有数字。 | 1 字节 |
| smallint     | 允许从 -32,768 到 32,767 的所有数字。 | 2 字节 |
| int          | 允许从 -2,147,483,648 到 2,147,483,647 的所有数字。 | 4 字节 |
| bigint       | 允许介于 -9,223,372,036,854,775,808 和 9,223,372,036,854,775,807 之间的所有数字。 | 8 字节 |
| decimal(p,s) | 固定精度和比例的数字。允许从 -10\^38 +1 到 10\^38 -1 之间的数字。 p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。 s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 | 5-17 字节 |
| numeric(p,s) | 固定精度和比例的数字。允许从 -10\^38 +1 到 10\^38 -1 之间的数字。 p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。 s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 | 5-17 字节 |
| smallmoney   | 介于 -214,748.3648 和 214,748.3647 之间的货币数据。 | 4 字节 |
| money        | 介于 -922,337,203,685,477.5808 和 922,337,203,685,477.5807 之间的货币数据。 | 8 字节 |
| float(n)     | 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。 参数 n 指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 | 4 或 8 字节 |
| real         | 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 | 4 字节 |

#### Date 类型：

| **数据类型** | **描述** | **存储** |
|-----|-----|-----|
| datetime | 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 | 8 bytes  |
| datetime2 | 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 | 6-8 bytes |
| smalldatetime | 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 | 4 bytes |
| date | 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 | 3 bytes |
| time | 仅存储时间。精度为 100 纳秒。 | 3-5 bytes |
| datetimeoffset | 与 datetime2 相同，外加时区偏移。 | 8-10 bytes |
| timestamp | 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 | / |

#### 其他数据类型：

| **数据类型** | **描述** |
|------------------|----------------|
| sql_variant      | 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 |
| uniqueidentifier | 存储全局标识符 (GUID)。 |
| xml              | 存储 XML 格式化数据。最多 2GB。 |
| cursor           | 存储对用于数据库操作的指针的引用。 |
| table            | 存储结果集，供稍后处理。 |

---

## SQL 服务器

**现代的 SQL 服务器构建在 RDBMS 之上。**

### DBMS - 数据库管理系统（Database Management System）

数据库管理系统是一种可以访问数据库中数据的计算机程序。

DBMS 使我们有能力在数据库中提取、修改或者存贮信息。

不同的 DBMS 提供不同的函数供查询、提交以及修改数据。

### RDBMS - 关系数据库管理系统（Relational Database Management System）

关系数据库管理系统 (RDBMS)也是一种数据库管理系统，其数据库是根据数据间的关系来组织和访问数据的。

20 世纪 70 年代初，IBM 公司发明了 RDBMS。

RDBMS 是 SQL 的基础，也是所有现代数据库系统诸如 Oracle、SQL Server、IBM DB2、Sybase、MySQL 以及 Microsoft Access 的基础。


---

# **SQL 函数**

## SQL functions

**SQL 拥有很多可用于计数和计算的内建函数。**

### **函数的语法**

内建 SQL 函数的语法是：
</code></pre><p>SELECT function(列) FROM 表</p>
<pre><code>### **函数的类型**

在 SQL 中，基本的函数类型和种类有若干种。函数的基本类型是：

-   Aggregate 函数

-   Scalar 函数

### **合计函数（Aggregate functions）**

Aggregate 函数的操作面向一系列的值，并返回一个单一的值。

**注释：**如果在 SELECT 语句的项目列表中的众多其它表达式中使用 SELECT 语句，则这个 SELECT 必须使用 GROUP BY 语句！

#### **&quot;Persons&quot; table (在大部分的例子中使用过)**

| **Name**       | **Age** |
|----------------|---------|
| Adams, John    | 38      |
| Bush, George   | 33      |
| Carter, Thomas | 28      |

#### **MS Access 中的合计函数**

| **函数**                                                            | **描述**                         |
|---------------------------------------------------------------------|----------------------------------|
| [AVG(column)](https://www.w3school.com.cn/sql/sql_func_avg.asp)     | 返回某列的平均值                 |
| [COUNT(column)](https://www.w3school.com.cn/sql/sql_func_count.asp) | 返回某列的行数（不包括 NULL 值） |
| [COUNT(\*)](https://www.w3school.com.cn/sql/sql_func_count_ast.asp) | 返回被选行数                     |
| FIRST(column)                                                       | 返回在指定的域中第一个记录的值   |
| LAST(column)                                                        | 返回在指定的域中最后一个记录的值 |
| [MAX(column)](https://www.w3school.com.cn/sql/sql_func_max.asp)     | 返回某列的最高值                 |
| [MIN(column)](https://www.w3school.com.cn/sql/sql_func_min.asp)     | 返回某列的最低值                 |
| STDEV(column)                                                       | /                                |
| STDEVP(column)                                                      | /                                |
| [SUM(column)](https://www.w3school.com.cn/sql/sql_func_sum.asp)     | 返回某列的总和                   |
| VAR(column)                                                         | /                                |
| VARP(column)                                                        | /                                |

#### **在 SQL Server 中的合计函数**

| **函数** | **描述** |
|----|----|
| [AVG(column)](https://www.w3school.com.cn/sql/sql_func_avg.asp) | 返回某列的平均值 |
| BINARY_CHECKSUM | / |
| CHECKSUM | / |
| CHECKSUM_AGG | / |
| [COUNT(column)](https://www.w3school.com.cn/sql/sql_func_count.asp) | 返回某列的行数（不包括NULL值） |
| [COUNT(\*)](https://www.w3school.com.cn/sql/sql_func_count_ast.asp) | 返回被选行数 |
| [COUNT(DISTINCT column)](https://www.w3school.com.cn/sql/sql_func_count_distinct.asp) | 返回相异结果的数目 |
| [FIRST(column)](https://www.w3school.com.cn/sql/sql_func_first.asp) | 返回在指定的域中第一个记录的值（SQLServer2000 不支持） |
| [LAST(column)](https://www.w3school.com.cn/sql/sql_func_last.asp) | 返回在指定的域中最后一个记录的值（SQLServer2000 不支持） |
| [MAX(column)](https://www.w3school.com.cn/sql/sql_func_max.asp) | 返回某列的最高值 |
| [MIN(column)](https://www.w3school.com.cn/sql/sql_func_min.asp) | 返回某列的最低值 |
| STDEV(column) | / |
| STDEVP(column) | / |
| [SUM(column)](https://www.w3school.com.cn/sql/sql_func_sum.asp) | 返回某列的总和 |
| VAR(column) | / |
| VARP(column) | / |

#### **Scalar 函数**

Scalar 函数的操作面向某个单一的值，并返回基于输入值的一个单一的值。

#### **MS Access 中的 Scalar 函数**

| **函数**                | **描述**                               |
|-------------------------|----------------------------------------|
| UCASE(c)                | 将某个域转换为大写                     |
| LCASE(c)                | 将某个域转换为小写                     |
| MID(c,start[,end])      | 从某个文本域提取字符                   |
| LEN(c)                  | 返回某个文本域的长度                   |
| INSTR(c,char)           | 返回在某个文本域中指定字符的数值位置   |
| LEFT(c,number_of_char)  | 返回某个被请求的文本域的左侧部分       |
| RIGHT(c,number_of_char) | 返回某个被请求的文本域的右侧部分       |
| ROUND(c,decimals)       | 对某个数值域进行指定小数位数的四舍五入 |
| MOD(x,y)                | 返回除法操作的余数                     |
| NOW()                   | 返回当前的系统日期                     |
| FORMAT(c,format)        | 改变某个域的显示方式                   |
| DATEDIFF(d,date1,date2) | 用于执行日期计算                       |






---

## SQL avg()

### 定义和用法

AVG 函数返回数值列的平均值。NULL 值不包括在计算中。

#### SQL AVG() 语法
</code></pre><p>SELECT AVG(column_name) FROM table_name</p>
<pre><code>### SQL AVG() 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

#### 例子 1

现在，我们希望计算 &quot;OrderPrice&quot; 字段的平均值。

我们使用如下 SQL 语句：
</code></pre><p>SELECT AVG(OrderPrice) AS OrderAverage FROM Orders</p>
<pre><code>结果集类似这样：

| **OrderAverage** |
|------------------|
| 950              |

#### 例子 2

现在，我们希望找到 OrderPrice 值高于 OrderPrice 平均值的客户。

我们使用如下 SQL 语句：
</code></pre><p>SELECT Customer FROM Orders</p>
<p>WHERE OrderPrice>(SELECT AVG(OrderPrice) FROM Orders)</p>
<pre><code>结果集类似这样：

| **Customer** |
|--------------|
| Bush         |
| Carter       |
| Adams        |






---

## SQL count()

**COUNT() 函数返回匹配指定条件的行数。**

### SQL COUNT() 语法

#### SQL COUNT(column_name) 语法

COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：
</code></pre><p>SELECT COUNT(column_name) FROM table_name</p>
<pre><code>#### SQL COUNT(\*) 语法

COUNT(\*) 函数返回表中的记录数：
</code></pre><p>SELECT COUNT(*) FROM table_name</p>
<pre><code>### SQL COUNT(DISTINCT column_name) 语法

COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：
</code></pre><p>SELECT COUNT(DISTINCT column_name) FROM table_name</p>
<pre><code>**注释：**COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于Microsoft Access。

### SQL COUNT(column_name) 实例

我们拥有下列 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望计算客户 &quot;Carter&quot; 的订单数。

我们使用如下 SQL 语句：
</code></pre><p>SELECT COUNT(Customer) AS CustomerNilsen FROM Orders</p>
<p>WHERE Customer=’Carter’</p>
<pre><code>以上 SQL 语句的结果是 2，因为客户 Carter 共有 2 个订单：

| **CustomerNilsen** |
|--------------------|
| 2                  |

### SQL COUNT(\*) 实例

如果我们省略 WHERE 子句，比如这样：
</code></pre><p>SELECT COUNT(*) AS NumberOfOrders FROM Orders</p>
<pre><code>结果集类似这样：

| **NumberOfOrders** |
|--------------------|
| 6                  |

这是表中的总行数。

### SQL COUNT(DISTINCT column_name) 实例

现在，我们希望计算 &quot;Orders&quot; 表中不同客户的数目。

我们使用如下 SQL 语句：
</code></pre><p>SELECT COUNT(DISTINCT Customer) AS NumberOfCustomers FROM Orders</p>
<pre><code>结果集类似这样：

| **NumberOfCustomers** |
|-----------------------|
| 3                     |

这是 &quot;Orders&quot; 表中不同客户（Bush, Carter 和 Adams）的数目。






---

## SQL first()

### FIRST() 函数

FIRST() 函数返回指定的字段中第一个记录的值。

**提示：**可使用 ORDER BY 语句对记录进行排序。

#### SQL FIRST() 语法
</code></pre><p>SELECT FIRST(column_name) FROM table_name</p>
<pre><code>### SQL FIRST() 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找 &quot;OrderPrice&quot; 列的第一个值。

我们使用如下 SQL 语句：
</code></pre><p>SELECT FIRST(OrderPrice) AS FirstOrderPrice FROM Orders</p>
<pre><code>结果集类似这样：

| **FirstOrderPrice** |
|---------------------|
| 1000                |





---

## SQL last()

### LAST() 函数

LAST() 函数返回指定的字段中最后一个记录的值。

**提示：**可使用 ORDER BY 语句对记录进行排序。

#### SQL LAST() 语法
</code></pre><p>SELECT LAST(column_name) FROM table_name</p>
<pre><code>### SQL LAST() 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找 &quot;OrderPrice&quot; 列的最后一个值。

我们使用如下 SQL 语句：
</code></pre><p>SELECT LAST(OrderPrice) AS LastOrderPrice FROM Orders</p>
<pre><code>结果集类似这样：

| **LastOrderPrice** |
|--------------------|
| 100                |






---

## SQL max()

### MAX() 函数

MAX 函数返回一列中的最大值。NULL 值不包括在计算中。

#### SQL MAX() 语法
</code></pre><p>SELECT MAX(column_name) FROM table_name</p>
<pre><code>**注释：**MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。

### SQL MAX() 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找 &quot;OrderPrice&quot; 列的最大值。

我们使用如下 SQL 语句：
</code></pre><p>SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders</p>
<pre><code>结果集类似这样：

| **LargestOrderPrice** |
|-----------------------|
| 2000                  |






---

## SQL min()

### MIN() 函数

MIN 函数返回一列中的最小值。NULL 值不包括在计算中。

#### SQL MIN() 语法
</code></pre><p>SELECT MIN(column_name) FROM table_name</p>
<pre><code>**注释：**MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。

### SQL MIN() 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找 &quot;OrderPrice&quot; 列的最小值。

我们使用如下 SQL 语句：
</code></pre><p>SELECT MIN(OrderPrice) AS SmallestOrderPrice FROM Orders</p>
<pre><code>结果集类似这样：

| **SmallestOrderPrice** |
|------------------------|
| 100                    |







---

## SQL sum()

### SUM() 函数

SUM 函数返回数值列的总数（总额）。

#### SQL SUM() 语法
</code></pre><p>SELECT SUM(column_name) FROM table_name</p>
<pre><code>### SQL SUM() 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找 &quot;OrderPrice&quot; 字段的总数。

我们使用如下 SQL 语句：
</code></pre><p>SELECT SUM(OrderPrice) AS OrderTotal FROM Orders</p>
<pre><code>结果集类似这样：

| **OrderTotal** |
|----------------|
| 5700           |






---

## SQL Group By

**合计函数 (比如 SUM) 常常需要添加 GROUP BY 语句。**

### GROUP BY 语句

GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。

#### SQL GROUP BY 语法
</code></pre><p>SELECT column_name, aggregate_function(column_name)</p>
<p>FROM table_name</p>
<p>WHERE column_name operator value</p>
<p>GROUP BY column_name</p>
<pre><code>### SQL GROUP BY 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找每个客户的总金额（总订单）。

我们想要使用 GROUP BY 语句对客户进行组合。

我们使用下列 SQL 语句：
</code></pre><p>SELECT Customer,SUM(OrderPrice) FROM Orders</p>
<p>GROUP BY Customer</p>
<pre><code>结果集类似这样：

| **Customer** | **SUM(OrderPrice)** |
|--------------|---------------------|
| Bush         | 2000                |
| Carter       | 1700                |
| Adams        | 2000                |

很棒吧，对不对？

让我们看一下如果省略 GROUP BY 会出现什么情况：
</code></pre><p>SELECT Customer,SUM(OrderPrice) FROM Orders</p>
<pre><code>结果集类似这样：

| **Customer** | **SUM(OrderPrice)** |
|--------------|---------------------|
| Bush         | 5700                |
| Carter       | 5700                |
| Bush         | 5700                |
| Bush         | 5700                |
| Adams        | 5700                |
| Carter       | 5700                |

上面的结果集不是我们需要的。

那么为什么不能使用上面这条 SELECT 语句呢？解释如下：上面的 SELECT 语句指定了两列（Customer 和 SUM(OrderPrice)）。&quot;SUM(OrderPrice)&quot;返回一个单独的值（&quot;OrderPrice&quot; 列的总计），而 &quot;Customer&quot; 返回 6 个值（每个值对应&quot;Orders&quot; 表中的每一行）。因此，我们得不到正确的结果。不过，您已经看到了，GROUP BY 语句解决了这个问题。

### GROUP BY 一个以上的列

我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：
</code></pre><p>SELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders</p>
<p>GROUP BY Customer,OrderDate</p>
<pre><code>





---

## SQL Having

### HAVING 子句

在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。

#### SQL HAVING 语法
</code></pre><p>SELECT column_name, aggregate_function(column_name)</p>
<p>FROM table_name</p>
<p>WHERE column_name operator value</p>
<p>GROUP BY column_name</p>
<p>HAVING aggregate_function(column_name) operator value</p>
<pre><code>### SQL HAVING 实例

我们拥有下面这个 &quot;Orders&quot; 表：

| **O_Id** | **OrderDate** | **OrderPrice** | **Customer** |
|----------|---------------|----------------|--------------|
| 1        | 2008/12/29    | 1000           | Bush         |
| 2        | 2008/11/23    | 1600           | Carter       |
| 3        | 2008/10/05    | 700            | Bush         |
| 4        | 2008/09/28    | 300            | Bush         |
| 5        | 2008/08/06    | 2000           | Adams        |
| 6        | 2008/07/21    | 100            | Carter       |

现在，我们希望查找订单总金额少于 2000 的客户。

我们使用如下 SQL 语句：
</code></pre><p>SELECT Customer,SUM(OrderPrice) FROM Orders</p>
<p>GROUP BY Customer</p>
<p>HAVING SUM(OrderPrice)\&lt;2000</p>
<pre><code>结果集类似：

| **Customer** | **SUM(OrderPrice)** |
|--------------|---------------------|
| Carter       | 1700                |

现在我们希望查找客户 &quot;Bush&quot; 或 &quot;Adams&quot; 拥有超过 1500 的订单总金额。

我们在 SQL 语句中增加了一个普通的 WHERE 子句：
</code></pre><p>SELECT Customer,SUM(OrderPrice) FROM Orders</p>
<p>WHERE Customer=’Bush’ OR Customer=’Adams’</p>
<p>GROUP BY Customer</p>
<p>HAVING SUM(OrderPrice)>1500</p>
<pre><code>结果集：

| **Customer** | **SUM(OrderPrice)** |
|--------------|---------------------|
| Bush         | 2000                |
| Adams        | 2000                |





---

## SQL ucase()

### UCASE() 函数

UCASE 函数把字段的值转换为大写。

#### SQL UCASE() 语法
</code></pre><p>SELECT UCASE(column_name) FROM table_name</p>
<pre><code>### SQL UCASE() 实例

我们拥有下面这个 &quot;Persons&quot; 表：

| **Id** | **LastName** | **FirstName** | **Address**    | **City** |
|--------|--------------|---------------|----------------|----------|
| 1      | Adams        | John          | Oxford Street  | London   |
| 2      | Bush         | George        | Fifth Avenue   | New York |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |

现在，我们希望选取 &quot;LastName&quot; 和 &quot;FirstName&quot; 列的内容，然后把 &quot;LastName&quot;
列转换为大写。

我们使用如下 SQL 语句：
</code></pre><p>SELECT UCASE(LastName) as LastName,FirstName FROM Persons</p>
<pre><code>结果集类似这样：

| **LastName** | **FirstName** |
|--------------|---------------|
| ADAMS        | John          |
| BUSH         | George        |
| CARTER       | Thomas        |





---

## SQL lcase()

### LCASE() 函数

LCASE 函数把字段的值转换为小写。

#### SQL LCASE() 语法
</code></pre><p>SELECT LCASE(column_name) FROM table_name</p>
<pre><code>### SQL LCASE() 实例

我们拥有下面这个 &quot;Persons&quot; 表：

| **Id** | **LastName** | **FirstName** | **Address**    | **City** |
|--------|--------------|---------------|----------------|----------|
| 1      | Adams        | John          | Oxford Street  | London   |
| 2      | Bush         | George        | Fifth Avenue   | New York |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |

现在，我们希望选取 &quot;LastName&quot; 和 &quot;FirstName&quot; 列的内容，然后把 &quot;LastName&quot;列转换为小写。

我们使用如下 SQL 语句：
</code></pre><p>SELECT LCASE(LastName) as LastName,FirstName FROM Persons</p>
<pre><code>结果集类似这样：

| **LastName** | **FirstName** |
|--------------|---------------|
| adams        | John          |
| bush         | George        |
| carter       | Thomas        |





---

## SQL mid()

### MID() 函数

MID 函数用于从文本字段中提取字符。

#### SQL MID() 语法
</code></pre><p>SELECT MID(column_name,start[,length]) FROM table_name</p>
<pre><code>| **参数**    | **描述**                                                    |
|-------------|-------------------------------------------------------------|
| column_name | 必需。要提取字符的字段。                                    |
| start       | 必需。规定开始位置（起始值是 1）。                          |
| length      | 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。 |

### SQL MID() 实例

我们拥有下面这个 &quot;Persons&quot; 表：

| **Id** | **LastName** | **FirstName** | **Address**    | **City** |
|--------|--------------|---------------|----------------|----------|
| 1      | Adams        | John          | Oxford Street  | London   |
| 2      | Bush         | George        | Fifth Avenue   | New York |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |

现在，我们希望从 &quot;City&quot; 列中提取前 3 个字符。

我们使用如下 SQL 语句：
</code></pre><p>SELECT MID(City,1,3) as SmallCity FROM Persons</p>
<pre><code>结果集类似这样：

| **SmallCity** |
|---------------|
| Lon           |
| New           |
| Bei           |





---

## SQL len()

### LEN() 函数

LEN 函数返回文本字段中值的长度。

#### SQL LEN() 语法
</code></pre><p>SELECT LEN(column_name) FROM table_name</p>
<pre><code>### SQL LEN() 实例

我们拥有下面这个 &quot;Persons&quot; 表：

| **Id** | **LastName** | **FirstName** | **Address**    | **City** |
|--------|--------------|---------------|----------------|----------|
| 1      | Adams        | John          | Oxford Street  | London   |
| 2      | Bush         | George        | Fifth Avenue   | New York |
| 3      | Carter       | Thomas        | Changan Street | Beijing  |

现在，我们希望取得 &quot;City&quot; 列中值的长度。

我们使用如下 SQL 语句：
</code></pre><p>SELECT LEN(City) as LengthOfCity FROM Persons</p>
<pre><code>结果集类似这样：

| **LengthOfCity** |
|------------------|
| 6                |
| 8                |
| 7                |





---

## SQL round()

### ROUND() 函数

ROUND 函数用于把数值字段舍入为指定的小数位数。

#### SQL ROUND() 语法
</code></pre><p>SELECT ROUND(column_name,decimals) FROM table_name</p>
<pre><code>| **参数**    | **描述**                     |
|-------------|------------------------------|
| column_name | 必需。要舍入的字段。         |
| decimals    | 必需。规定要返回的小数位数。 |

### SQL ROUND() 实例

我们拥有下面这个 &quot;Products&quot; 表：

| **Prod_Id** | **ProductName** | **Unit** | **UnitPrice** |
|-------------|-----------------|----------|---------------|
| 1           | gold            | 1000 g   | 32.35         |
| 2           | silver          | 1000 g   | 11.56         |
| 3           | copper          | 1000 g   | 6.85          |

现在，我们希望把名称和价格舍入为最接近的整数。

我们使用如下 SQL 语句：
</code></pre><p>SELECT ProductName, ROUND(UnitPrice,0) as UnitPrice FROM Products</p>
<pre><code>结果集类似这样：

| **ProductName** | **UnitPrice** |
|-----------------|---------------|
| gold            | 32            |
| silver          | 12            |
| copper          | 7             |






---

## SQL now()

### NOW() 函数

NOW 函数返回当前的日期和时间。

**提示：**如果您在使用 Sql Server 数据库，请使用 getdate() 函数来获得当前的日期时间。

#### SQL NOW() 语法
</code></pre><p>SELECT NOW() FROM table_name</p>
<pre><code>### SQL NOW() 实例

我们拥有下面这个 &quot;Products&quot; 表：

| **Prod_Id** | **ProductName** | **Unit** | **UnitPrice** |
|-------------|-----------------|----------|---------------|
| 1           | gold            | 1000 g   | 32.35         |
| 2           | silver          | 1000 g   | 11.56         |
| 3           | copper          | 1000 g   | 6.85          |

现在，我们希望显示当天的日期所对应的名称和价格。

我们使用如下 SQL 语句：
</code></pre><p>SELECT ProductName, UnitPrice, Now() as PerDate FROM Products</p>
<pre><code>结果集类似这样：

| **ProductName** | **UnitPrice** | **PerDate**            |
|-----------------|---------------|------------------------|
| gold            | 32.35         | 12/29/2008 11:36:05 AM |
| silver          | 11.56         | 12/29/2008 11:36:05 AM |
| copper          | 6.85          | 12/29/2008 11:36:05 AM |






---

## SQL format()

### FORMAT() 函数

FORMAT 函数用于对字段的显示进行格式化。

#### SQL FORMAT() 语法
</code></pre><p>SELECT FORMAT(column_name,format) FROM table_name</p>
<pre><code>| **参数**    | **描述**               |
|-------------|------------------------|
| column_name | 必需。要格式化的字段。 |
| format      | 必需。规定格式。       |

### SQL FORMAT() 实例

我们拥有下面这个 &quot;Products&quot; 表：

| **Prod_Id** | **ProductName** | **Unit** | **UnitPrice** |
|-------------|-----------------|----------|---------------|
| 1           | gold            | 1000 g   | 32.35         |
| 2           | silver          | 1000 g   | 11.56         |
| 3           | copper          | 1000 g   | 6.85          |

现在，我们希望显示每天日期所对应的名称和价格（日期的显示格式是 &quot;YYYY-MM-DD&quot;）。

我们使用如下 SQL 语句：
</code></pre><p>SELECT ProductName, UnitPrice, FORMAT(Now(),’YYYY-MM-DD’) as PerDate</p>
<p>FROM Products</p>
<pre><code>结果集类似这样：

| **ProductName** | **UnitPrice** | **PerDate** |
|-----------------|---------------|-------------|
| gold            | 32.35         | 12/29/2008  |
| silver          | 11.56         | 12/29/2008  |
| copper          | 6.85          | 12/29/2008  |






---

# **SQL 总结**

## SQL 快速参考

来自 W3School 的 SQL 快速参考。可以打印它，以备日常使用。

| ID | 语句 | 语法 |
| :---- | :---- | :---- |
| 1 | AND / OR | **SELECT** column_name(s) **FROM** table_name **WHERE** condition **AND/OR** condition |
| 2 | ALTER TABLE (add column) | **ALTER TABLE** table_name **ADD** column_name datatype |
| 3 | ALTER TABLE (drop column) | **ALTER TABLE** table_name **DROP COLUMN** column_name |
| 4 | AS (alias for column) | **SELECT** column_name **AS** column_alias **FROM** table_name |
| 5 | AS (alias for table) | **SELECT** column_name **FROM** table_name **AS** table_alias |
| 6 | BETWEEN | **SELECT** column_name(s) **FROM** table_name **WHERE** column_name **BETWEEN** value1 AND value2 |
| 7 | CREATE DATABASE | **CREATE DATABASE** database_name |
| 8 | CREATE INDEX | **CREATE INDEX** index_name **ON** table_name (column_name) |
| 9 | CREATE TABLE | **CREATE TABLE** table_name(column_name1 data_type,column_name2 data_type,.......) |
| 10 | CREATE UNIQUE INDEX | **CREATE UNIQUE INDEX** index_name **ON** table_name (column_name) |
| 11 | CREATE VIEW | **CREATE VIEW** view_name **ASSELECT** column_name(s) **FROM** table_name **WHERE** condition |
| 12 | DELETE FROM | **DELETE FROM** table_name (Note: Deletes the entire table!!)or **DELETE FROM** table_name **WHERE** condition |
| 13 | DROP DATABASE | **DROP DATABASE** database_name |
| 14 | DROP INDEX | **DROP INDEX** table_name.index_name |
| 15 | DROP TABLE | **DROP TABLE** table_name |
| 16 | GROUP BY | **SELECT** column_name1,**SUM**(column_name2) **FROM** table_name **GROUP BY** column_name1 |
| 17 | HAVING | **SELECT** column_name1,**SUM**(column_name2) **FROM** table_name **GROUP BY** column_name1 **HAVING SUM**(column_name2) condition value |
| 18 | IN | **SELECT** column_name(s) **FROM** table_name **WHERE** column_name **IN** (value1,value2,..) |
| 19 | INSERT INTO | **INSERT INTO** table_name **VALUES** (value1, value2,....)or **INSERT INTO** table_name(column_name1, column_name2,...) **VALUES** (value1, value2,....) |
| 20 | LIKE | **SELECT** column_name(s) **FROM** table_name **WHERE** column_name **LIKE** pattern |
| 21 | ORDER BY | **SELECT** column_name(s) **FROM** table_name **ORDER BY** column_name [**ASC/DESC**] |
| 22 | SELECT | **SELECT** column_name(s) **FROM** table_name |
| 23 | SELECT * | **SELECT * FROM** table_name |
| 24 | SELECT DISTINCT | **SELECT DISTINCT** column_name(s) **FROM** table_name |
| 25 | SELECT INTO(used to create backup copies of tables) | **SELECT * INTO** new_table_name **FROM** original_table_name or **SELECT** column_name(s) **INTO** new_table_name **FROM** original_table_name |
| 26 | TRUNCATE TABLE(deletes only the data inside the table) | **TRUNCATE TABLE** table_name |
| 27 | UPDATE | **UPDATE** table_name **SET** column_name=new_value [, column_name=new_value] **WHERE** column_name=some_value |
| 28 | WHERE | **SELECT** column_name(s) **FROM** table_name **WHERE** condition |


**HTML代码展示**
</code></pre><p><table><br>    <tr><br>      <th>语句</th><br>      <th>语法</th><br>    </tr><br>    <tr><br>      <td>AND / OR</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name<br><br>        WHERE condition<br><br>        AND|OR condition</td><br>    </tr><br>    <tr><br>      <td>ALTER TABLE (add column)</td><br>      <td>ALTER TABLE table_name <br><br>        ADD column_name datatype</td><br>    </tr><br>    <tr><br>      <td>ALTER TABLE (drop column)</td><br>      <td>ALTER TABLE table_name <br><br>        DROP COLUMN column_name</td><br>    </tr><br>    <tr><br>      <td>AS (alias for column)</td><br>      <td>SELECT column_name AS column_alias<br><br>        FROM table_name</td><br>    </tr><br>    <tr><br>      <td>AS (alias for table)</td><br>      <td>SELECT column_name<br><br>        FROM table_name&nbsp; AS table_alias</td><br>    </tr><br>    <tr><br>      <td>BETWEEN</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name<br><br>        WHERE column_name<br><br>        BETWEEN value1 AND value2</td><br>    </tr><br>    <tr><br>      <td>CREATE DATABASE</td><br>      <td>CREATE DATABASE database_name</td><br>    </tr><br>    <tr><br>      <td>CREATE INDEX</td><br>      <td>CREATE INDEX index_name<br><br>        ON table_name (column_name)</td><br>    </tr><br>    <tr><br>      <td>CREATE TABLE</td><br>      <td>CREATE TABLE table_name<br><br>        (<br><br>        column_name1 data_type,<br><br>        column_name2 data_type,<br><br>        …….<br><br>        )</td><br>    </tr><br>    <tr><br>      <td>CREATE UNIQUE INDEX</td><br>      <td>CREATE UNIQUE INDEX index_name<br><br>        ON table_name (column_name)</td><br>    </tr><br>    <tr><br>      <td>CREATE VIEW</td><br>      <td>CREATE VIEW view_name AS<br><br>        SELECT column_name(s)<br><br>        FROM table_name<br><br>        WHERE condition</td><br>    </tr><br>    <tr><br>      <td>DELETE FROM</td><br>      <td>DELETE FROM table_name <br><br>        (<b>Note: </b>Deletes the entire table!!)<p><i>or</i></p><br>        <p>DELETE FROM table_name<br><br>        WHERE condition</p></td><br>    </tr><br>    <tr><br>      <td>DROP DATABASE</td><br>      <td>DROP DATABASE database_name</td><br>    </tr><br>    <tr><br>      <td>DROP INDEX</td><br>      <td>DROP INDEX table_name.index_name</td><br>    </tr><br>    <tr><br>      <td>DROP TABLE</td><br>      <td>DROP TABLE table_name</td><br>    </tr><br>    <tr><br>      <td>GROUP BY</td><br>      <td>SELECT column_name1,SUM(column_name2)<br><br>        FROM table_name<br><br>        GROUP BY column_name1</td><br>    </tr><br>    <tr><br>      <td>HAVING</td><br>      <td>SELECT column_name1,SUM(column_name2)<br><br>        FROM table_name<br><br>        GROUP BY column_name1<br><br>        HAVING SUM(column_name2) condition value</td><br>    </tr><br>    <tr><br>      <td>IN</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name<br><br>        WHERE column_name<br><br>        IN (value1,value2,..)</td><br>    </tr><br>    <tr><br>      <td>INSERT INTO</td><br>      <td>INSERT INTO table_name<br><br>        VALUES (value1, value2,….)<p><i>or</i></p><br>        <p>INSERT INTO table_name<br><br>        (column_name1, column_name2,…)<br><br>        VALUES (value1, value2,….)</p></td><br>    </tr><br>    <tr><br>      <td>LIKE</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name<br><br>        WHERE column_name<br><br>        LIKE pattern</td><br>    </tr><br>    <tr><br>      <td>ORDER BY</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name<br><br>        ORDER BY column_name [ASC|DESC]</td><br>    </tr><br>    <tr><br>      <td>SELECT</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name</td><br>    </tr><br>    <tr><br>      <td>SELECT <em></td><br>      <td>SELECT </em><br><br>        FROM table_name</td><br>    </tr><br>    <tr><br>      <td>SELECT DISTINCT</td><br>      <td>SELECT DISTINCT column_name(s)<br><br>        FROM table_name</td><br>    </tr><br>    <tr><br>      <td>SELECT INTO<br><br>        (used to create backup copies of<br>        tables)</td><br>      <td>SELECT *<br><br>        INTO new_table_name<br><br>        FROM original_table_name<p><i>or</i></p><br>        <p>SELECT column_name(s)<br><br>        INTO new_table_name<br><br>        FROM original_table_name</p></td><br>    </tr><br>    <tr><br>      <td>TRUNCATE TABLE<br><br>        (deletes only the data inside<br>        the table)</td><br>      <td>TRUNCATE TABLE table_name</td><br>    </tr><br>    <tr><br>      <td>UPDATE</td><br>      <td>UPDATE table_name<br><br>        SET column_name=new_value<br><br>        [, column_name=new_value]<br><br>        WHERE column_name=some_value</td><br>    </tr><br>    <tr><br>      <td>WHERE</td><br>      <td>SELECT column_name(s)<br><br>        FROM table_name<br><br>        WHERE condition</td><br>    </tr><br></table><br>```</p>
<hr>
<h2 id="sql-">SQL 教程总结</h2>
<p><strong>SQL 概要</strong></p>
<p>本教程已经向您讲解了用来访问和处理数据库系统的标准计算机语言。</p>
<p>我们已经学习了如何使用 SQL 在数据库中执行查询、获取数据、插入新的记录、删除记录以及更新记录。</p>
<p>SQL 是一种与数据库程序协同工作的标准语言，这些数据库程序包括 MS Access、DB2、Informix、MS SQL Server、Oracle、MySQL、Sybase 等等。</p>
<p><strong>我们已经学习了 SQL，下一步学习什么呢？</strong></p>
<p>下一步应该学习 ADO。</p>
<p>ADO 是一种从网站访问数据库中数据的编程接口。</p>
<p>ADO 使用 SQL 来查询数据库中的数据。</p>
<p>如果您需要学习更多关于 ADO 的知识，请访问我们的《<a href="https://www.w3school.com.cn/ado/index.asp" title="ADO 教程">ADO 教程</a>》。</p>
<hr>
<h1 id="mysql-">MySQL 教程</h1>
<h2 id="mysql-">MySQL 教程</h2>
<h3 id="-"><strong>什么是数据库？</strong></h3>
<p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，</p>
<p>每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。</p>
<p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p>
<p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>RDBMS即关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li><p>1.数据以表格的形式出现</p>
</li><li><p>2.每行为各种记录名称</p>
</li><li><p>3.每列为记录名称所对应的数据域</p>
</li><li><p>4.许多的行和列组成一张表单</p>
</li><li><p>5.若干的表单组成database</p>
</li></ul>
<h3 id="-rdbms-"><strong>RDBMS 术语</strong></h3>
<p>在我们开始学习MySQL 数据库前，让我们先了解下RDBMS的一些术语：</p>
<ul>
<li><p><strong>数据库:</strong> 数据库是一些关联表的集合。.</p>
</li><li><p><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p>
</li><li><p><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p>
</li><li><p><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p>
</li><li><p><strong>冗余</strong>：存储两倍数据，冗余可以使系统速度更快。</p>
</li><li><p><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</p>
</li><li><p><strong>外键：</strong>外键用于关联两个表。</p>
</li><li><p><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</p>
</li><li><p><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</p>
</li><li><p><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p>
</li></ul>
<h3 id="-mysql-"><strong>Mysql数据库</strong></h3>
<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<ul>
<li><p>Mysql是开源的，所以你不需要支付额外的费用。</p>
</li><li><p>Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</p>
</li><li><p>MySQL使用标准的SQL数据语言形式。</p>
</li><li><p>Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。</p>
</li><li><p>Mysql对PHP有很好的支持，PHP是目前最流行的Web开发语言。</p>
</li><li><p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p>
</li><li><p>Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。</p>
</li></ul>
<hr>
<h2 id="mysql-">MySQL 安装</h2>
<p>所有平台的Mysql下载地址为： <a href="http://www.mysql.com/downloads">MySQL 下载</a>. 挑选你需要的 <em>MySQL Community Server</em> 版本及对应的平台。</p>
<h3 id="-linux-unix-mysql-"><strong>Linux/UNIX上安装Mysql</strong></h3>
<p>Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址：</p>
<ul>
<li><strong>MySQL</strong> - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。</li><li><strong>MySQL-client</strong> - MySQL 客户端程序，用于连接并操作Mysql服务器。</li><li><strong>MySQL-devel</strong> - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。</li><li><strong>MySQL-shared</strong> - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。</li><li><strong>MySQL-bench</strong> - MySQL数据库服务器的基准和性能测试工具。</li></ul>
<p>以下安装Mysql RMP的实例是在SuSE Linux系统上进行，当然该安装步骤也适合应用于其他支持RPM的Linux系统，如:Centos。</p>
<p>安装步骤如下：</p>
<p>使用root用户登陆你的Linux系统。</p>
<p>下载Mysql RPM包，下载地址为：<a href="http://www.mysql.com/downloads">MySQL 下载</a>。</p>
<p>通过以下命令执行Mysql安装，rpm包为你下载的rpm包：</p>
<pre><code>[root@host]# rpm -i MySQL-5.0.9-0.i386.rpm
</code></pre><p>以上安装mysql服务器的过程会创建mysql用户，并创建一个mysql配置文件my.cnf。</p>
<p>你可以在/usr/bin和/usr/sbin中找到所有与MySQL相关的二进制文件。所有数据表和数据库将在/var/lib/mysql目录中创建。</p>
<p>以下是一些mysql可选包的安装过程，你可以根据自己的需要来安装：</p>
<pre><code>[root@host]# rpm -i MySQL-client-5.0.9-0.i386.rpm
[root@host]# rpm -i MySQL-devel-5.0.9-0.i386.rpm
[root@host]# rpm -i MySQL-shared-5.0.9-0.i386.rpm
[root@host]# rpm -i MySQL-bench-5.0.9-0.i386.rpm
</code></pre><h3 id="-window-mysql-"><strong>Window上安装Mysql</strong></h3>
<p>Window上安装Mysql相对来说会较为简单，你只需要载 <a href="http://www.mysql.com/downloads">MySQL 下载</a>中下载window版本的mysql安装包，并解压安装包。</p>
<p>双击 setup.exe 文件，接下来你只需要安装默认的配置点击”next”即可，默认情况下安装信息会在C:\mysql目录中。</p>
<p>接下来你可以通过”开始” =》在搜索框中输入 “ cmd” 命令 =》 在命令提示符上切换到 C:\mysql\bin 目录，并输入一下命令：</p>
<pre><code>mysqld.exe --console
</code></pre><p>如果安装成功以上命令将输出一些mysql启动及InnoDB信息。</p>
<h3 id="-mysql-"><strong>验证Mysql安装</strong></h3>
<p>在成功安装Mysql后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证Mysql是否工作正常。</p>
<p>使用 mysqladmin 工具来获取服务器状态：</p>
<p>使用 mysqladmin 命令俩检查服务器的版本,在linux上该二进制文件位于 /usr/bin on linux ，在window上该二进制文件位于C:\mysql\bin 。</p>
<pre><code>[root@host]# mysqladmin --version
</code></pre><p>linux上该命令将输出以下结果，该结果基于你的系统信息：</p>
<pre><code>mysqladmin  Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386
</code></pre><p>如果以上命令执行后未输入任何信息，说明你的Mysql未安装成功。</p>
<h3 id="-mysql-client-mysql-sql-"><strong>使用 MySQL Client(Mysql客户端) 执行简单的SQL命令</strong></h3>
<p>你可以在 MySQL Client(Mysql客户端) 使用 mysql 命令连接到Mysql服务器上，默认情况下Mysql服务器的密码为空，所以本实例不需要输入密码。</p>
<p>命令如下：</p>
<pre><code>[root@host]# mysql
</code></pre><p>以上命令执行后会输出 mysql&gt;提示符，这说明你已经成功连接到Mysql服务器上，你可以在 mysql&gt; 提示符执行SQL命令：</p>
<pre><code>mysql&gt; SHOWDATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
+----------+
2 rows in set (0.13 sec)
</code></pre><h3 id="-mysql-"><strong>Mysql安装后需要做的</strong></h3>
<p>Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码：</p>
<pre><code>[root@host]# mysqladmin -u root password &quot;new_password&quot;;
</code></pre><p>现在你可以通过以下命令来连接到Mysql服务器：</p>
<pre><code>[root@host]# mysql -u root -p
Enter password:*******
</code></pre><p><strong>注意：</strong>在输入密码时，密码是不会显示了，你正确输入即可。</p>
<h3 id="-linux-mysql-"><strong>Linux系统启动时启动 MySQL</strong></h3>
<p>如果你需要在Linux系统启动时启动 MySQL 服务器，你需要在 /etc/rc.local 文件中添加以下命令：</p>
<pre><code>/etc/init.d/mysqld start
</code></pre><p>同样，你需要将 mysqld 二进制文件添加到 /etc/init.d/ 目录中。</p>
<hr>
<h2 id="mysql-">MySQL 管理与配置</h2>
<h3 id="-mysql-"><strong>启动及关闭 MySQL 服务器</strong></h3>
<p>首先，我们需要通过以下命令来检查MySQL服务器是否启动：</p>
<pre><code>ps -ef | grep mysqld
</code></pre><p>如果MySql已经启动，以上命令将输出mysql进程列表， 如果mysql未启动，你可以使用以下命令来启动mysql服务器:</p>
<pre><code>root@host# cd /usr/bin
./mysqld_safe &amp;
</code></pre><p>如果你想关闭目前运行的 MySQL 服务器, 你可以执行以下命令:</p>
<pre><code>root@host# cd /usr/bin
./mysqladmin -u root -p shutdown
Enter password: ******
</code></pre><h3 id="-mysql-"><strong>MySQL 用户设置</strong></h3>
<p>如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。</p>
<p>以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：</p>
<pre><code>root@host# mysql -u root -p
Enter password:*******
mysql&gt; use mysql;
Database changed

mysql&gt; INSERTINTOuser 
          (host, user, password, 
           select_priv, insert_priv, update_priv) 
           VALUES (&#39;localhost&#39;, &#39;guest&#39;, 
           PASSWORD(&#39;guest123&#39;), &#39;Y&#39;, &#39;Y&#39;, &#39;Y&#39;);
Query OK, 1 row affected (0.20 sec)

mysql&gt; FLUSHPRIVILEGES;
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT host, user, passwordFROMuserWHEREuser = &#39;guest&#39;;
+-----------+---------+------------------+
| host      | user    | password         |
+-----------+---------+------------------+
| localhost | guest | 6f8c114b58f2ce9e |
+-----------+---------+------------------+
1 row in set (0.00 sec)
</code></pre><p>在添加用户时，请注意使用MySQL提供的 PASSWORD() 函数来对密码进行加密。 你可以在以上实例看到用户密码加密后为： 6f8c114b58f2ce9e.</p>
<p><strong>注意：</strong>在注意需要执行 FLUSH PRIVILEGES 语句。 这个命令执行后会重新载入授权表。 如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。</p>
<p>你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下：</p>
<ul>
<li>Select_priv</li><li>Insert_priv</li><li>Update_priv</li><li>Delete_priv</li><li>Create_priv</li><li>Drop_priv</li><li>Reload_priv</li><li>Shutdown_priv</li><li>Process_priv</li><li>File_priv</li><li>Grant_priv</li><li>References_priv</li><li>Index_priv</li><li>Alter_priv</li></ul>
<p>另外一种添加用户的方法为通过SQL的 GRANT 命令，你下命令会给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 。</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use mysql;
Database changed

mysql&gt; GRANTSELECT,INSERT,UPDATE,DELETE,CREATE,DROP
    -&gt; ON TUTORIALS.*
    -&gt; TO&#39;zara&#39;@&#39;localhost&#39;
    -&gt; IDENTIFIEDBY&#39;zara123&#39;;
</code></pre><p>以上命令会在mysql数据库中的user表创建一条用户信息记录。</p>
<p><strong>注意:</strong> MySQL 的SQL语句以分号 (;) 作为结束标识。</p>
<h3 id="-etc-my-cnf-"><strong>/etc/my.cnf 文件配置</strong></h3>
<p>一般情况下，你不需要修改该配置文件，该文件默认配置如下：</p>
<pre><code>[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

[mysql.server]
user=mysql
basedir=/var/lib

[safe_mysqld]
err-log=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
</code></pre><p>在配置文件中，你可以指定不同的错误日志文件存放的目录，一般你不需要改动这些配置。</p>
<h3 id="-mysql-"><strong>管理MySQL的命令</strong></h3>
<p>以下列出了使用Mysql数据库过程中常用的命令：</p>
<ul>
<li><strong>USE <em>数据库名</em></strong> :选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</li><li><strong>SHOW DATABASES: </strong>列出 MySQL 数据库管理系统的数据库列表。</li><li><strong>SHOW TABLES:</strong> 显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</li><li><strong>SHOW COLUMNS FROM <em>数据表</em>:</strong> 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</li><li><strong>SHOW INDEX FROM <em>数据表</em>:</strong> 显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</li><li><strong>SHOW TABLE STATUS LIKE <em>数据表</em>\G:</strong> 该命令将输出Mysql数据库管理系统的性能及统计信息。</li></ul>
<hr>
<h2 id="mysql-php-">MySQL PHP 语法</h2>
<p>MySQL 可应用于多种语言，包括 PERL, C, C++, JAVA 和 PHP。 在这些语言中，Mysql在PHP的web开发中是应用最广泛。</p>
<p>在本教程中我们大部分实例都采用了PHP语言。</p>
<p>PHP提供了多种方式来访问和操作Mysql数据库记录。PHP Mysql函数格式如下：</p>
<pre><code>mysql_function(value,value,...);
</code></pre><p>以上格式中 function部分描述了mysql函数的功能，如</p>
<pre><code>mysqli_connect($connect);
mysqli_query($connect,&quot;SQL statement&quot;);
mysql_fetch_array()
mysql_connect(),mysql_close()
</code></pre><p>以下实例展示了PHP调用mysql函数的语法：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;PHP with MySQL&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$retval = mysql_function(value, [value,...]);
   if( !$retval )
   {
       die ( &quot;Error: a related error message&quot; );
   }
   // Otherwise MySQL  or PHP Statements?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>从下一章开始，我们将学习到更多的MySQL功能函数。</p>
<hr>
<h2 id="mysql-">MySQL 连接</h2>
<h3 id="-mysql-"><strong>使用mysql二进制方式连接</strong></h3>
<p>您可以使用MySQL二进制方式进入到mysql命令提示符下来连接MySQL数据库。</p>
<p>实例</p>
<p>以下是从命令行中连接mysql服务器的简单实例：</p>
<pre><code>[root@host]# mysql -u root -p
Enter password:******
</code></pre><p>在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。</p>
<p>以上命令执行后，登录成功输出结果如下:</p>
<pre><code>Welcome to the MySQL monitor.  Commands endwith ; or \g.
Your MySQL connection id is 2854760 to server version: 5.0.9

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39;to clear the buffer.
</code></pre><p>在以上实例中，我们使用了root用户登录到mysql服务器，当然你也可以使用其他mysql用户登录。</p>
<p>如果用户权限足够，任何用户都可以在mysql的命令提示窗口中进行SQL操作。</p>
<p>退出 mysql&gt; 命令提示窗口可以使用 exit 命令，如下所示：</p>
<pre><code>mysql&gt; exit
Bye
</code></pre><h3 id="-php-mysql-"><strong>使用 PHP 脚本连接 MySQL</strong></h3>
<p>PHP 提供了 mysql_connect() 函数来连接数据库。</p>
<p>该函数有5个参数，在成功链接到MySQL后返回连接标识，失败返回 FALSE 。</p>
<p>语法</p>
<pre><code>connection mysql_connect(server,user,passwd,new_link,client_flag);
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>server</td>
<td>可选。规定要连接的服务器。 可以包括端口号，例如 “hostname:port”，或者到本地套接字的路径，例如对于 localhost 的 “:/path/to/socket”。 如果 PHP 指令 mysql.default_host 未定义（默认情况），则默认值是 ‘localhost:3306’。</td>
</tr>
<tr>
<td>user</td>
<td>可选。用户名。默认值是服务器进程所有者的用户名。</td>
</tr>
<tr>
<td>passwd</td>
<td>可选。密码。默认值是空密码。</td>
</tr>
<tr>
<td>new_link</td>
<td>可选。如果用同样的参数第二次调用 mysql_connect()，将不会建立新连接，而将返回已经打开的连接标识。参数 new_link 改变此行为并使 mysql_connect() 总是打开新的连接，甚至当 mysql_connect() 曾在前面被用同样的参数调用过。</td>
</tr>
<tr>
<td>client_flag</td>
<td>可选。client_flags 参数可以是以下常量的组合：</td>
</tr>
<tr>
<td>①</td>
<td>- MYSQL_CLIENT_SSL - 使用 SSL 加密</td>
</tr>
<tr>
<td>②</td>
<td>- MYSQL_CLIENT_COMPRESS - 使用压缩协议</td>
</tr>
<tr>
<td>③</td>
<td>- MYSQL_CLIENT_IGNORE_SPACE - 允许函数名后的间隔</td>
</tr>
<tr>
<td>④</td>
<td>- MYSQL_CLIENT_INTERACTIVE - 允许关闭连接之前的交互超时非活动时间</td>
</tr>
</tbody>
</table>
<p>你可以使用PHP的 mysql_close() 函数来断开与MySQL数据库的链接。</p>
<p>该函数只有一个参数为mysql_connect()函数创建连接成功后返回的 MySQL 连接标识符。</p>
<p>语法</p>
<pre><code>bool mysql_close ( resource $link_identifier );
</code></pre><p>本函数关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。</p>
<p><strong>提示：</strong>通常不需要使用 mysql_close()，因为已打开的非持久连接会在脚本执行完毕后自动关闭。</p>
<p><strong>注释：</strong>mysql_close() 不会关闭由 mysql_pconnect() 建立的持久连接。</p>
<p>实例</p>
<p>你可以尝试以下实例来连接到你的 MySQL 服务器:</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Connecting MySQL Server&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$dbhost = &#39;localhost:3306&#39;;  //mysql服务器主机地址$dbuser = &#39;guest&#39;;      //mysql用户名$dbpass = &#39;guest123&#39;;//mysql用户名密码$conn = mysql_connect($dbhost, $dbuser, $dbpass);
   if(! $conn )
   {
     die(&#39;Could not connect: &#39; . mysql_error());
   }
   echo&#39;Connected successfully&#39;;
   mysql_close($conn);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><hr>
<h2 id="mysql-">MySQL 创建数据库</h2>
<h3 id="-mysqladmin-"><strong>使用 mysqladmin 创建数据库</strong></h3>
<p>使用普通用户，你可能需要特定的权限来创建或者删除 MySQL 数据库。</p>
<p>所以我们这边使用root用户登录，root用户拥有最高权限，可以使用 mysql mysqladmin 命令来创建数据库。</p>
<p>实例</p>
<p>以下命令简单的演示了创建数据库的过程，数据名为 TUTORIALS:</p>
<pre><code>[root@host]# mysqladmin -u root -p create TUTORIALS
Enter password:******
</code></pre><p>以上命令执行成功后会创建 MySQL 数据库 TUTORIALS。</p>
<h3 id="-php-"><strong>使用 PHP脚本 创建数据库</strong></h3>
<p>PHP使用 mysql_query 函数来创建或者删除 MySQL 数据库。</p>
<p>该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。</p>
<h4 id="-">语法</h4>
<pre><code>bool mysql_query( sql, connection );
</code></pre><p>参数描述</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sql</td>
<td>必需。规定要发送的 SQL 查询。注释：查询字符串不应以分号结束。</td>
</tr>
<tr>
<td>connection</td>
<td>可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接。</td>
</tr>
</tbody>
</table>
<p>实例</p>
<p>以下实例演示了使用PHP来创建一个数据库：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Creating MySQL Database&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
echo&#39;Connected successfully&lt;br /&gt;&#39;;
$sql = &#39;CREATE DATABASE TUTORIALS&#39;;
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not create database: &#39; . mysql_error());
}
echo&quot;Database TUTORIALS created successfully\n&quot;;
mysql_close($conn);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><hr>
<h2 id="mysql-">MySQL 删除数据库</h2>
<h3 id="-mysqladmin-"><strong>使用 mysqladmin 删除数据库</strong></h3>
<p>使用普通用户登陆mysql服务器，你可能需要特定的权限来创建或者删除 MySQL 数据库。</p>
<p>所以我们这边使用root用户登录，root用户拥有最高权限，可以使用 mysql mysqladmin 命令来创建数据库。</p>
<p>在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。</p>
<p>以下实例删除数据库TUTORIALS(该数据库在前一章节已创建)：</p>
<pre><code>[root@host]# mysqladmin -u root -p drop TUTORIALS
Enter password:******
</code></pre><p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库：</p>
<pre><code>Dropping the database is potentially a very bad thing to do.
Anydata stored in the database will be destroyed.

Do you really want todrop the &#39;TUTORIALS&#39;database [y/N] y
Database&quot;TUTORIALS&quot; dropped
</code></pre><h3 id="-php-">使用PHP脚本删除数据库</h3>
<p>PHP使用 mysql_query 函数来创建或者删除 MySQL 数据库。</p>
<p>该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。</p>
<p>语法</p>
<pre><code>bool mysql_query( sql, connection );
</code></pre><p>参数描述</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sql</td>
<td>必需。规定要发送的 SQL 查询。注释：查询字符串不应以分号结束。</td>
</tr>
<tr>
<td>connection</td>
<td>可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接。</td>
</tr>
</tbody>
</table>
<p>实例</p>
<p>以下实例演示了使用PHP mysql_query函数来删除数据库：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Deleting MySQL Database&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;连接失败: &#39; . mysql_error());
}
echo&#39;连接成功&lt;br /&gt;&#39;;
$sql = &#39;DROP DATABASE TUTORIALS&#39;;
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;删除数据库失败: &#39; . mysql_error());
}
echo&quot;数据库 TUTORIALS 删除成功\n&quot;;
mysql_close($conn);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>注意：</strong> 在使用PHP脚本删除数据库时，不会出现确认是否删除信息，会直接删除指定数据库，所以你在删除数据库时要特别小心。</p>
<hr>
<h2 id="mysql-">MySQL 选择数据库</h2>
<p>在你连接到 MySQL 数据库后，可能有多个可以操作的数据库，所以你需要选择你要操作的数据库。</p>
<h3 id="-mysql-"><strong>从命令提示窗口中选择MySQL数据库</strong></h3>
<p>在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。你可以使用SQL命令来选择指定的数据库。</p>
<p>实例</p>
<p>以下实例选取了数据库 TUTORIALS:</p>
<pre><code>[root@host]# mysql -u root -p
Enter password:******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt;
</code></pre><p>执行以上命令后，你就已经成功选择了 TUTORIALS 数据库，在后续的操作中都会在 TUTORIALS 数据库中执行。</p>
<p><strong>注意:</strong>所有的数据库名，表名，表字段都是区分大小写的。所以你在使用SQL命令时需要输入正确的名称。</p>
<h3 id="-php-mysql-"><strong>使用PHP脚本选择MySQL数据库</strong></h3>
<p>PHP 提供了函数 mysql_select_db 来选取一个数据库。函数在执行成功后返回 TRUE ，否则返回 FALSE 。</p>
<p>语法</p>
<pre><code>bool mysql_select_db( db_name, connection );
</code></pre><p>参数描述db_name必需。规定要选择的数据库。connection可选。规定 MySQL 连接。如果未指定，则使用上一个连接。<br>实例</p>
<p>以下实例展示了如何使用 mysql_select_db 函数来选取一个数据库：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Selecting MySQL Database&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;guest&#39;;
$dbpass = &#39;guest123&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
echo&#39;Connected successfully&#39;;
mysql_select_db( &#39;TUTORIALS&#39; );
mysql_close($conn);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><hr>
<h2 id="mysql-">MySQL 数据类型</h2>
<p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</p>
<p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h3 id="-"><strong>数值类型</strong></h3>
<p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 字节</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">(-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">“单精度浮点数值”</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">(1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">“双精度浮点数值”</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<h3 id="-"><strong>日期和时间类型</strong></h3>
<p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0-65535 字节</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0-65 535字节</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0-65 535字节</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215字节</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215字节</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LOGNGBLOB</td>
<td style="text-align:left">0-4 294 967 295字节</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295字节</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<h3 id="-"><strong>字符串类型</strong></h3>
<p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小(字节)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>-838:59:59&#39;/&#39;838:59:59</code></td>
<td style="text-align:left">HH<img src="https://assets-cdn.github.com/images/icons/emoji/MM.png" alt=":MM:" title=":MM:" class="emoji" align="absmiddle" height="20" width="20">SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left"><code>1000-01-01 00:00:00/9999-12-31 23:59:59</code></td>
<td style="text-align:left"><code>YYYY-MM-DD HH:MM:SS</code></td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">8</td>
<td style="text-align:left"><code>1970-01-01 00:00:00/2037 年某时</code></td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。</p>
<p>有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。</p>
<hr>
<h2 id="mysql-">MySQL 创建数据表</h2>
<p>创建MySQL数据表需要以下信息：</p>
<ul>
<li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul>
<p>语法</p>
<p>以下为创建MySQL数据表的SQL通用语法：</p>
<pre><code>CREATETABLE table_name (column_name column_type);
</code></pre><p>以下例子中我们将在 TUTORIALS 数据库中创建数据表tutorials_tbl：</p>
<pre><code>createtable tutorials_tbl(
   tutorial_id INTNOTNULL AUTO_INCREMENT,
   tutorial_title VARCHAR(100) NOTNULL,
   tutorial_author VARCHAR(40) NOTNULL,
   submission_date DATE,
   PRIMARYKEY ( tutorial_id )
);
</code></pre><p>实例解析：</p>
<ul>
<li>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</li><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li></ul>
<h3 id="-"><strong>通过命令提示符创建表</strong></h3>
<p>通过 mysql&gt; 命令窗口可以很简单的创建MySQL数据表。你可以使用 SQL 语句 <strong>CREATE TABLE</strong> 来创建数据表。</p>
<p>实例</p>
<p>以下为创建数据表 tutorials_tbl 实例:</p>
<pre><code>root@host# mysql -u root -p
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; CREATETABLE tutorials_tbl(
   -&gt; tutorial_id INTNOTNULL AUTO_INCREMENT,
   -&gt; tutorial_title VARCHAR(100) NOTNULL,
   -&gt; tutorial_author VARCHAR(40) NOTNULL,
   -&gt; submission_date DATE,
   -&gt; PRIMARYKEY ( tutorial_id )
   -&gt; );
Query OK, 0 rows affected (0.16 sec)
mysql&gt;
</code></pre><p><strong>注意：</strong>MySQL命令终止符为分号 (;) 。</p>
<h3 id="-php-"><strong>使用PHP脚本创建数据表</strong></h3>
<p>你可以使用PHP的 mysql_query() 函数来创建已存在数据库的数据表。</p>
<p>该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。</p>
<p>语法</p>
<pre><code>bool mysql_query( sql, connection );
</code></pre><p>参数描述sql必需。规定要发送的 SQL 查询。注释：查询字符串不应以分号结束。connection可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接。</p>
<p>实例</p>
<p>以下实例使用了PHP脚本来创建数据表：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Creating MySQL Tables&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
echo&#39;Connected successfully&lt;br /&gt;&#39;;
$sql = &quot;CREATE TABLE tutorials_tbl( &quot;.
       &quot;tutorial_id INT NOT NULL AUTO_INCREMENT, &quot;.
       &quot;tutorial_title VARCHAR(100) NOT NULL, &quot;.
       &quot;tutorial_author VARCHAR(40) NOT NULL, &quot;.
       &quot;submission_date DATE, &quot;.
       &quot;PRIMARY KEY ( tutorial_id )); &quot;;
mysql_select_db( &#39;TUTORIALS&#39; );
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not create table: &#39; . mysql_error());
}
echo&quot;Table created successfully\n&quot;;
mysql_close($conn);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><hr>
<h2 id="mysql-">MySQL 删除数据表</h2>
<p>MySQL中删除数据表是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。</p>
<p>语法</p>
<p>以下为删除MySQL数据表的通用语法：</p>
<pre><code>DROPTABLE table_name ;
</code></pre><h3 id="-"><strong>在命令提示窗口中删除数据表</strong></h3>
<p>在mysql&gt;命令提示窗口中删除数据表SQL语句为<strong> DROP TABLE </strong>：</p>
<p>实例</p>
<p>以下实例删除了数据表tutorials_tbl:</p>
<pre><code>root@host# mysql -u root -p
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; DROPTABLE tutorials_tbl
Query OK, 0rows affected (0.8 sec)
mysql&gt;
</code></pre><h3 id="-php-"><strong>使用PHP脚本删除数据表</strong></h3>
<p>PHP使用 mysql_query 函数来删除 MySQL 数据表。</p>
<p>该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。</p>
<p>语法</p>
<pre><code>bool mysql_query( sql, connection );
</code></pre><p>参数描述sql必需。规定要发送的 SQL 查询。注释：查询字符串不应以分号结束。connection可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接。</p>
<p>实例</p>
<p>以下实例使用了PHP脚本删除数据表tutorials_tbl:</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Creating MySQL Tables&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
echo&#39;Connected successfully&lt;br /&gt;&#39;;
$sql = &quot;DROP TABLE tutorials_tbl&quot;;
mysql_select_db( &#39;TUTORIALS&#39; );
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not delete table: &#39; . mysql_error());
}
echo&quot;Table deleted successfully\n&quot;;
mysql_close($conn);
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><hr>
<h2 id="mysql-">MySQL 插入数据</h2>
<p>MySQL 表中使用<strong> INSERT INTO </strong>SQL语句来插入数据。</p>
<p>你可以通过 mysql&gt; 命令提示窗口中向数据表中插入数据，或者通过PHP脚本来插入数据。</p>
<p>语法</p>
<p>以下为向MySQL数据表插入数据通用的<strong> INSERT INTO </strong>SQL语法：</p>
<pre><code>INSERTINTO table_name ( field1, field2,...fieldN )
                       VALUES
                       ( value1, value2,...valueN );
</code></pre><p>如果数据是字符型，必须使用单引号或者双引号，如：”value”。</p>
<h3 id="-"><strong>通过命令提示窗口插入数据</strong></h3>
<p>以下我们将使用 SQL <strong>INSERT INTO </strong>语句向 MySQL 数据表 tutorials_tbl 插入数据</p>
<p>实例</p>
<p>以下实例中我们将想 tutorials_tbl 表插入三条数据:</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; INSERTINTO tutorials_tbl 
     -&gt;(tutorial_title, tutorial_author, submission_date)
     -&gt;VALUES
     -&gt;(&quot;Learn PHP&quot;, &quot;John Poul&quot;, NOW());
Query OK, 1 row affected (0.01 sec)
mysql&gt; INSERTINTO tutorials_tbl
     -&gt;(tutorial_title, tutorial_author, submission_date)
     -&gt;VALUES
     -&gt;(&quot;Learn MySQL&quot;, &quot;Abdul S&quot;, NOW());
Query OK, 1 row affected (0.01 sec)
mysql&gt; INSERTINTO tutorials_tbl
     -&gt;(tutorial_title, tutorial_author, submission_date)
     -&gt;VALUES
     -&gt;(&quot;JAVA Tutorial&quot;, &quot;Sanjay&quot;, &#39;2007-05-06&#39;);
Query OK, 1 row affected (0.01 sec)
mysql&gt;
</code></pre><p><strong>注意：</strong> 使用箭头标记(-&gt;)不是SQL语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写SQL语句，SQL语句的命令结束符为分号（;）。</p>
<p>在以上实例中，我们并没有提供 tutorial_id 的数据，因为该字段我们在创建表的时候已经设置它为 AUTO_INCREMENT(自动增加) 属性。 所以，该字段会自动递增而不需要我们去设置。实例中 NOW() 是一个 MySQL 函数，该函数返回日期和时间。</p>
<h3 id="-php-"><strong>使用PHP脚本插入数据</strong></h3>
<p>你可以使用PHP 的 mysql_query() 函数来执行 <strong>SQL INSERT INTO</strong>命令来插入数据。</p>
<p>该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。</p>
<p>语法</p>
<pre><code>bool mysql_query( sql, connection );
</code></pre><p>参数描述sql必需。规定要发送的 SQL 查询。注释：查询字符串不应以分号结束。connection可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接。</p>
<p>实例</p>
<p>以下实例中程序接收用户输入的三个字段数据，并插入数据表中：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Add New Record in MySQL Database&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?phpif(isset($_POST[&#39;add&#39;]))
{
$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}

if(! get_magic_quotes_gpc() )
{
   $tutorial_title = addslashes ($_POST[&#39;tutorial_title&#39;]);
   $tutorial_author = addslashes ($_POST[&#39;tutorial_author&#39;]);
}
else
{
   $tutorial_title = $_POST[&#39;tutorial_title&#39;];
   $tutorial_author = $_POST[&#39;tutorial_author&#39;];
}
$submission_date = $_POST[&#39;submission_date&#39;];

$sql = &quot;INSERT INTO tutorials_tbl &quot;.
       &quot;(tutorial_title,tutorial_author, submission_date) &quot;.
       &quot;VALUES &quot;.
       &quot;(&#39;$tutorial_title&#39;,&#39;$tutorial_author&#39;,&#39;$submission_date&#39;)&quot;;
mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not enter data: &#39; . mysql_error());
}
echo&quot;Entered data successfully\n&quot;;
mysql_close($conn);
}
else
{
?&gt;
&lt;form method=&quot;post&quot; action=&quot;&lt;?php $_PHP_SELF ?&gt;&quot;&gt;
&lt;table width=&quot;600&quot; border=&quot;0&quot; cellspacing=&quot;1&quot; cellpadding=&quot;2&quot;&gt;
&lt;tr&gt;
&lt;td width=&quot;250&quot;&gt;Tutorial Title&lt;/td&gt;
&lt;td&gt;
&lt;input name=&quot;tutorial_title&quot; type=&quot;text&quot; id=&quot;tutorial_title&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;250&quot;&gt;Tutorial Author&lt;/td&gt;
&lt;td&gt;
&lt;input name=&quot;tutorial_author&quot; type=&quot;text&quot; id=&quot;tutorial_author&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;250&quot;&gt;Submission Date [ yyyy-mm-dd ]&lt;/td&gt;
&lt;td&gt;
&lt;input name=&quot;submission_date&quot; type=&quot;text&quot; id=&quot;submission_date&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;250&quot;&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;250&quot;&gt; &lt;/td&gt;
&lt;td&gt;
&lt;input name=&quot;add&quot; type=&quot;submit&quot; id=&quot;add&quot; value=&quot;Add Tutorial&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
&lt;?php
}
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>在我们接收用户提交的数据时，为了数据的安全性我们需要使用 get_magic_quotes_gpc() 函数来判断特殊字符的转义是否已经开启。如果这个选项为off（未开启），返回0，那么我们就必须调用addslashes 这个函数来为字符串增加转义。</p>
<p>你也可以添加其他检查数据的方法，比如邮箱格式验证，电话号码验证，是否为整数验证等。</p>
<hr>
<h2 id="mysql-">MySQL 查询数据</h2>
<p>MySQL 数据库使用SQL SELECT语句来查询数据。</p>
<p>你可以通过 mysql&gt; 命令提示窗口中在数据库中查询数据，或者通过PHP脚本来查询数据。</p>
<p>语法</p>
<p>以下为在MySQL数据库中查询数据通用的 SELECT 语法：</p>
<pre><code>SELECT field1, field2,...fieldN table_name1, table_name2...
[WHERE Clause]
[OFFSET M ][LIMIT N]
</code></pre><ul>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li><li>SELECT 命令可以读取一条或者多条记录。</li><li>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li><li>你可以使用 WHERE 语句来包含任何条件。</li><li>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li><li>你可以使用 LIMIT 属性来设定返回的记录数。</li></ul>
<h3 id="-"><strong>通过命令提示符获取数据</strong></h3>
<p>以下实例我们将通过 SQL SELECT 命令来获取 MySQL 数据表 tutorials_tbl 的数据：</p>
<p>实例</p>
<p>以下实例将返回数据表tutorials_tbl的所有记录:</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT * from tutorials_tbl 
+-------------+----------------+-----------------+-----------------+
| tutorial_id | tutorial_title | tutorial_author | submission_date |
+-------------+----------------+-----------------+-----------------+
|           1 | Learn PHP      | John Poul       | 2007-05-21      |
|           2 | Learn MySQL    | Abdul S         | 2007-05-21      |
|           3 | JAVA Tutorial  | Sanjay          | 2007-05-21      |
+-------------+----------------+-----------------+-----------------+3rowsinset (0.01 sec)

mysql&gt;
</code></pre><h3 id="-php-"><strong>使用PHP脚本来获取数据</strong></h3>
<p>使用PHP函数的mysql_query()及SQL SELECT命令来获取数据。</p>
<p>该函数用于执行SQL命令，然后通过 PHP 函数 mysql_fetch_array() 来使用或输出所有查询的数据。</p>
<p>mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。</p>
<p>以下实例为从数据表 tutorials_tbl 中读取所有记录。</p>
<p>实例</p>
<p>尝试以下实例来显示数据表 tutorials_tbl 的所有记录。</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_ASSOC))
{
    echo&quot;Tutorial ID :{$row[&#39;tutorial_id&#39;]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[&#39;tutorial_title&#39;]} &lt;br&gt; &quot;.
         &quot;Author: {$row[&#39;tutorial_author&#39;]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[&#39;submission_date&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><p>以上实例中，读取的每行记录赋值给变量$row，然后再打印出每个值。</p>
<p><strong>注意：</strong>记住如果你需要在字符串中使用变量，请将变量置于花括号。</p>
<p>在上面的例子中，PHP mysql_fetch_array()函数第二个参数为MYSQL_ASSOC， 设置该参数查询结果返回关联数组，你可以使用字段名称来作为数组的索引。</p>
<p>PHP提供了另外一个函数mysql_fetch_assoc(), 该函数从结果集中取得一行作为关联数组。 返回根据从结果集取得的行生成的关联数组，如果没有更多行，则返回 false。</p>
<p>实例</p>
<p>尝试以下实例，该实例使用了mysql_fetch_assoc()函数来输出数据表tutorial_tbl的所有记录：</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_assoc($retval))
{
    echo&quot;Tutorial ID :{$row[&#39;tutorial_id&#39;]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[&#39;tutorial_title&#39;]} &lt;br&gt; &quot;.
         &quot;Author: {$row[&#39;tutorial_author&#39;]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[&#39;submission_date&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><p>你也可以使用常量 MYSQL_NUM 作为PHP mysql_fetch_array()函数的第二个参数，返回数字数组。</p>
<p>实例</p>
<p>以下实例使用MYSQL_NUM参数显示数据表tutorials_tbl的所有记录:</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_NUM))
{
    echo&quot;Tutorial ID :{$row[0]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[1]} &lt;br&gt; &quot;.
         &quot;Author: {$row[2]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[3]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
}
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><p>以上三个实例输出结果都一样。</p>
<h3 id="-"><strong>内存释放</strong></h3>
<p>在我们执行完SELECT语句后，释放游标内存是一个很好的习惯。 。可以通过PHP函数mysql_free_result()来实现内存的释放。</p>
<p>以下实例演示了该函数的使用方法。</p>
<p>实例</p>
<p>尝试以下实例:</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_NUM))
{
    echo&quot;Tutorial ID :{$row[0]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[1]} &lt;br&gt; &quot;.
         &quot;Author: {$row[2]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[3]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
}
mysql_free_result($retval);
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-where-">MySQL where 子句</h2>
<p>我们知道从MySQL表中使用SQL SELECT 语句来读取数据。</p>
<p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p>
<p>语法</p>
<p>以下是SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：</p>
<pre><code>SELECT field1, field2,...fieldN FROM table_name1, table_name2...
[WHERE condition1 [AND [OR]] condition2.....
</code></pre><ul>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li><li>你可以在WHERE子句中指定任何条件。</li><li>你可以使用AND或者OR指定一个或多个条件。</li><li>WHERE子句也可以运用于SQL的 DELETE 或者 UPDATE 命令。</li><li>WHERE 子句类似于程序语言中的if条件，根据 MySQL 表中的字段值来读取指定的数据。</li></ul>
<p>以下为操作符列表，可用于 WHERE 子句中。</p>
<p>下表中实例假定 A为10 B为20</p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等号，检测两个值是否相等，如果相等返回true</td>
<td>(A = B) 返回false。</td>
</tr>
<tr>
<td>\&lt;>, !=</td>
<td>不等于，检测两个值是否相等，如果不相等返回true</td>
<td>(A != B) 返回 true。</td>
</tr>
<tr>
<td>></td>
<td>大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td>
<td>(A > B) 返回false。</td>
</tr>
<tr>
<td>\&lt;</td>
<td>小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td>
<td>(A \&lt; B) 返回 true。</td>
</tr>
<tr>
<td>>=</td>
<td>大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td>
<td>(A >= B) 返回false。</td>
</tr>
<tr>
<td>\&lt;=</td>
<td>小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td>
<td>(A \&lt;= B) 返回 true。</td>
</tr>
</tbody>
</table>
<p>如果我们想再MySQL数据表中读取指定的数据，WHERE 子句是非常有用的。</p>
<p>使用主键来作为 WHERE 子句的条件查询是非常快速的。</p>
<p>如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。</p>
<h3 id="-"><strong>从命令提示符中读取数据</strong></h3>
<p>我们将在SQL SELECT语句使用WHERE子句来读取MySQL数据表 tutorials_tbl 中的数据：</p>
<p>实例</p>
<p>以下实例将读取 tutorials_tbl 表中 tutorial_author 字段值为 Sanjay 的所有记录：</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT * from tutorials_tbl WHERE tutorial_author=&#39;Sanjay&#39;;
+-------------+----------------+-----------------+-----------------+
| tutorial_id | tutorial_title | tutorial_author | submission_date |
+-------------+----------------+-----------------+-----------------+
|           3 | JAVA Tutorial  | Sanjay          | 2007-05-21      |
+-------------+----------------+-----------------+-----------------+
1 rows in set (0.01 sec)

mysql&gt;
</code></pre><p>除非你使用 LIKE 来比较字符串，否则MySQL的WHERE子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定WHERE子句的字符串比较是区分大小写的。</p>
<p>如下实例</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT * from tutorials_tbl \
          WHEREBINARY tutorial_author=&#39;sanjay&#39;;
Empty set (0.02 sec)

mysql&gt;
</code></pre><h3 id="-php-"><strong>使用PHP脚本读取数据</strong></h3>
<p>你可以使用PHP函数的mysql_query()及相同的SQL SELECT 带上 WHERE 子句的命令来获取数据。</p>
<p>该函数用于执行SQL命令，然后通过 PHP 函数 mysql_fetch_array() 来输出所有查询的数据。</p>
<p>实例</p>
<p>以下实例将从 tutorials_tbl 表中返回使用 tutorial_author 字段值为 Sanjay 的记录：</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl
        WHERE tutorial_author=&quot;Sanjay&quot;&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_ASSOC))
{
    echo&quot;Tutorial ID :{$row[&#39;tutorial_id&#39;]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[&#39;tutorial_title&#39;]} &lt;br&gt; &quot;.
         &quot;Author: {$row[&#39;tutorial_author&#39;]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[&#39;submission_date&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-update-">MySQL UPDATE 查询</h2>
<p>如果我们需要修改或更新MySQL中的数据，我们可以使用 SQL UPDATE 命令来操作。.</p>
<p>语法</p>
<p>以下是 UPDATE 命令修改 MySQL 数据表数据的通用SQL语法：</p>
<pre><code>UPDATE table_name SET field1=new-value1, field2=new-value2
[WHERE Clause]
</code></pre><ul>
<li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul>
<p>当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。</p>
<p>通过命令提示符更新数据</p>
<p>以下我们将在 SQL UPDATE 命令使用 WHERE子句来更新tutorials_tbl表中指定的数据：</p>
<p>实例</p>
<p>以下实例将更新数据表中 tutorial_id 为 3 的 tutorial_title 字段值：</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; UPDATE tutorials_tbl 
    -&gt; SET tutorial_title=&#39;Learning JAVA&#39; 
    -&gt; WHERE tutorial_id=3;
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt;
</code></pre><h3 id="-php-"><strong>使用PHP脚本更新数据</strong></h3>
<p>PHP中使用函数mysql_query()来执行SQL语句，你可以在SQL UPDATE语句中使用或者不适用WHERE子句。</p>
<p>该函数与在mysql&gt;命令提示符中执行SQL语句的效果是一样的。</p>
<p>实例</p>
<p>以下实例将更新 tutorial_id 为3的 tutorial_title 字段的数据。</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;UPDATE tutorials_tbl
        SET tutorial_title=&quot;Learning JAVA&quot;
        WHERE tutorial_id=3&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not update data: &#39; . mysql_error());
}
echo&quot;Updated data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-delete-">MySQL DELETE 语句</h2>
<p>你可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。</p>
<p>你可以在mysql&gt;命令提示符或PHP脚本中执行该命令。</p>
<p>语法</p>
<p>以下是SQL DELETE 语句从MySQL数据表中删除数据的通用语法：</p>
<pre><code>DELETEFROM table_name [WHERE Clause]
</code></pre><ul>
<li>如果没有指定 WHERE 子句，MySQL表中的所有记录将被删除。</li><li>你可以在 WHERE 子句中指定任何条件</li><li>您可以在单个表中一次性删除记录。</li></ul>
<p>当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。</p>
<h3 id="-"><strong>从命令行中删除数据</strong></h3>
<p>这里我们将在 SQL DELETE 命令中使用 WHERE 子句来删除MySQL数据表tutorials_tbl所选的数据。</p>
<p>实例</p>
<p>以下实例将删除 tutorial_tbl 表中 tutorial_id 为3 的记录：</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; DELETEFROM tutorials_tbl WHERE tutorial_id=3;
Query OK, 1 row affected (0.23 sec)

mysql&gt;
</code></pre><h3 id="-php-"><strong>使用 PHP 脚本删除数据</strong></h3>
<p>PHP使用 mysql_query() 函数来执行SQL语句， 你可以在SQL DELETE命令中使用或不使用 WHERE 子句。</p>
<p>该函数与 mysql&gt;命令符执行SQL命令的效果是一样的。</p>
<p>实例</p>
<p>以下PHP实例将删除tutorial_tbl表中tutorial_id为3的记录:</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;DELETE FROM tutorials_tbl
        WHERE tutorial_id=3&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not delete data: &#39; . mysql_error());
}
echo&quot;Deleted data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-like-">MySQL LIKE 子句</h2>
<p>我们知道在MySQL中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。</p>
<p>WHERE 子句中可以使用等号 (=) 来设定获取数据的条件，如 “tutorial_author = ‘Sanjay’”。</p>
<p>但是有时候我们需要获取 tutorial_author 字段含有 “jay” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p>
<p>SQL LIKE 子句中使用百分号(%)字符来表示任意字符，类似于UNIX或正则表达式中的星号 (*)。</p>
<p>如果没有使用百分号(%), LIKE 子句与等号（=）的效果是一样的。</p>
<p>语法</p>
<p>以下是SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：</p>
<pre><code>SELECT field1, field2,...fieldN table_name1, table_name2...
WHERE field1 LIKE condition1 [AND [OR]] filed2 = &#39;somevalue&#39;
</code></pre><ul>
<li>你可以在WHERE子句中指定任何条件。</li><li>你可以在WHERE子句中使用LIKE子句。</li><li>你可以使用LIKE子句代替等号(=)。</li><li>LIKE 通常与 % 一同使用，类似于一个元字符的搜索。</li><li>你可以使用AND或者OR指定一个或多个条件。</li><li>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</li></ul>
<h2 id="-"> </h2>
<h3 id="-like-"><strong>在命令提示符中使用 LIKE 子句</strong></h3>
<p>以下我们将在 SQL SELECT 命令中使用 WHERE…LIKE 子句来从MySQL数据表 tutorials_tbl 中读取数据。</p>
<p>实例</p>
<p>以下是我们将tutorials_tbl表中获取tutorial_author字段中以”jay”为结尾的的所有记录：</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT * from tutorials_tbl 
    -&gt; WHERE tutorial_author LIKE&#39;%jay&#39;;
+-------------+----------------+-----------------+-----------------+
| tutorial_id | tutorial_title | tutorial_author | submission_date |
+-------------+----------------+-----------------+-----------------+
|           3 | JAVA Tutorial  | Sanjay          | 2007-05-21      |
+-------------+----------------+-----------------+-----------------+
1 rows in set (0.01 sec)

mysql&gt;
</code></pre><h3 id="-php-like-"><strong>在PHP脚本中使用 LIKE 子句</strong></h3>
<p>你可以使用PHP函数的mysql_query()及相同的SQL SELECT 带上 WHERE…LIKE 子句的命令来获取数据。</p>
<p>该函数用于执行SQL命令，然后通过 PHP 函数 mysql_fetch_array() 来输出所有查询的数据。</p>
<p>但是如果是DELETE或者UPDATE中使用 WHERE…LIKE 子句的SQL语句，则无需使用mysql_fetch_array() 函数。</p>
<p>实例</p>
<p>以下是我们使用PHP脚本在tutorials_tbl表中读取tutorial_author字段中以”jay”为结尾的的所有记录：</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl
        WHERE tutorial_author LIKE &quot;%jay%&quot;&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_ASSOC))
{
    echo&quot;Tutorial ID :{$row[&#39;tutorial_id&#39;]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[&#39;tutorial_title&#39;]} &lt;br&gt; &quot;.
         &quot;Author: {$row[&#39;tutorial_author&#39;]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[&#39;submission_date&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-order-by">mysql order by</h2>
<p>我们知道从MySQL表中使用SQL SELECT 语句来读取数据。</p>
<p>如果我们需要对读取的数据进行排序，我们就可以使用MySQL的 ORDER BY 子句来设定你想按哪个字段哪中方式来进行排序，再返回搜索结果。</p>
<h3 id="-">语法</h3>
<p>以下是SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：</p>
<pre><code>SELECT field1, field2,...fieldN table_name1, table_name2...
ORDERBY field1, [field2...] [ASC [DESC]]
</code></pre><ul>
<li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li><li>你可以设定多个字段来排序。</li><li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升排列。</li><li>你可以添加 WHERE…LIKE 子句来设置条件。</li></ul>
<h3 id="-order-by-"><strong>在命令提示符中使用 ORDER BY 子句</strong></h3>
<p>以下将在 SQL SELECT 语句中使用 ORDER BY 子句来读取MySQL 数据表 tutorials_tbl 中的数据：</p>
<p>实例</p>
<p>尝试以下实例，结果将按升序排列</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT * from tutorials_tbl ORDERBY tutorial_author ASC
+-------------+----------------+-----------------+-----------------+
| tutorial_id | tutorial_title | tutorial_author | submission_date |
+-------------+----------------+-----------------+-----------------+
|           2 | Learn MySQL    | Abdul S         | 2007-05-24      |
|           1 | Learn PHP      | John Poul       | 2007-05-24      |
|           3 | JAVA Tutorial  | Sanjay          | 2007-05-06      |
+-------------+----------------+-----------------+-----------------+3rowsinset (0.42 sec)

mysql&gt;
</code></pre><p>读取 tutorials_tbl 表中所有数据并按 tutorial_author 字段的升序排列。</p>
<h3 id="-php-order-by-"><strong>在PHP脚本中使用 ORDER BY 子句</strong></h3>
<p>你可以使用PHP函数的mysql_query()及相同的SQL SELECT 带上 ORDER BY 子句的命令来获取数据。 该函数用于执行SQL命令，然后通过 PHP 函数 mysql_fetch_array() 来输出所有查询的数据。</p>
<p>实例</p>
<p>尝试以下实例，查询后的数据按 tutorial_author 字段的降序排列后返回。</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT tutorial_id, tutorial_title, 
               tutorial_author, submission_date
        FROM tutorials_tbl
        ORDER BY  tutorial_author DESC&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_ASSOC))
{
    echo&quot;Tutorial ID :{$row[&#39;tutorial_id&#39;]}  &lt;br&gt; &quot;.
         &quot;Title: {$row[&#39;tutorial_title&#39;]} &lt;br&gt; &quot;.
         &quot;Author: {$row[&#39;tutorial_author&#39;]} &lt;br&gt; &quot;.
         &quot;Submission Date : {$row[&#39;submission_date&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-join-">Mysql Join的使用</h2>
<p>在前几章节中，我们已经学会了如果在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</p>
<p>本章节我们将向大家介绍如何使用MySQL 的 JOIN 在两个或多个表中查询数据。</p>
<p>你可以在SELECT, UPDATE 和 DELETE 语句中使用Mysql 的 join 来联合多表查询。</p>
<p>以下我们将演示MySQL LEFT JOIN 和 JOIN 的使用的不同之处。</p>
<h3 id="-join-"><strong>在命令提示符中使用JOIN</strong></h3>
<p>我们在TUTORIALS数据库中有两张表 tcount_tbl 和 tutorials_tbl。两张数据表数据如下：</p>
<p>实例</p>
<p>尝试以下实例：</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT * FROM tcount_tbl;
+-----------------+----------------+
| tutorial_author | tutorial_count |
+-----------------+----------------+
| mahran          |             20 |
| mahnaz          |           NULL |
| Jen             |           NULL |
| Gill            |             20 |
| John Poul       |              1 |
| Sanjay          |              1 |
+-----------------+----------------+
6 rows in set (0.01 sec)
mysql&gt; SELECT * from tutorials_tbl;
+-------------+----------------+-----------------+-----------------+
| tutorial_id | tutorial_title | tutorial_author | submission_date |
+-------------+----------------+-----------------+-----------------+
|           1 | Learn PHP      | John Poul       | 2007-05-24      |
|           2 | Learn MySQL    | Abdul S         | 2007-05-24      |
|           3 | JAVA Tutorial  | Sanjay          | 2007-05-06      |
+-------------+----------------+-----------------+-----------------+
3 rows in set (0.00 sec)
mysql&gt;
</code></pre><p>接下来我们就使用MySQL的JOIN来连接以上两张表来读取tutorials_tbl表中所有tutorial_author字段在tcount_tbl表对应的tutorial_count字段值：</p>
<pre><code>mysql&gt; SELECT a.tutorial_id, a.tutorial_author, b.tutorial_count
    -&gt; FROM tutorials_tbl a, tcount_tbl b
    -&gt; WHERE a.tutorial_author = b.tutorial_author;
+-------------+-----------------+----------------+
| tutorial_id | tutorial_author | tutorial_count |
+-------------+-----------------+----------------+
|           1 | John Poul       |              1 |
|           3 | Sanjay          |              1 |
+-------------+-----------------+----------------+
2 rows in set (0.01 sec)
mysql&gt;
</code></pre><h3 id="-php-join-"><strong>在PHP脚本中使用JOIN</strong></h3>
<p>PHP 中使用mysql_query()函数来执行SQL语句，你可以使用以上的相同的SQL语句作为mysql_query()函数的参数。</p>
<p>尝试如下实例:</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
$sql = &#39;SELECT a.tutorial_id, a.tutorial_author, b.tutorial_count
        FROM tutorials_tbl a, tcount_tbl b
        WHERE a.tutorial_author = b.tutorial_author&#39;;

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_ASSOC))
{
    echo&quot;Author:{$row[&#39;tutorial_author&#39;]}  &lt;br&gt; &quot;.
         &quot;Count: {$row[&#39;tutorial_count&#39;]} &lt;br&gt; &quot;.
         &quot;Tutorial ID: {$row[&#39;tutorial_id&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><h3 id="-mysql-left-join-"><strong>MySQL LEFT JOIN</strong></h3>
<p>MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p>
<p>实例</p>
<p>尝试以下实例，理解MySQL LEFT JOIN的应用：</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; SELECT a.tutorial_id, a.tutorial_author, b.tutorial_count
    -&gt; FROM tutorials_tbl a LEFTJOIN tcount_tbl b
    -&gt; ON a.tutorial_author = b.tutorial_author;
+-------------+-----------------+----------------+
| tutorial_id | tutorial_author | tutorial_count |
+-------------+-----------------+----------------+
|           1 | John Poul       |              1 |
|           2 | Abdul S         |           NULL |
|           3 | Sanjay          |              1 |
+-------------+-----------------+----------------+
3 rows in set (0.02 sec)
</code></pre><p>以上实例中使用了LEFT JOIN，该语句会读取左边的数据表tutorials_tbl的所有选取的字段数据，即便在右侧表tcount_tbl中没有对应的tutorial_author字段值。</p>
<hr>
<h2 id="mysql-null-">MySQL NULL 值处理</h2>
<p>我们已经知道MySQL使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。</p>
<p>为了处理这种情况，MySQL提供了三大运算符:</p>
<ul>
<li><strong>IS NULL:</strong> 当列的值是NULL,此运算符返回true。</li><li><strong>IS NOT NULL:</strong> 当列的值不为NULL, 运算符返回true。</li><li><strong>&lt;=&gt;:</strong> 比较操作符（不同于=运算符），当比较的的两个值为NULL时返回true。</li></ul>
<p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p>
<p>在MySQL中，NULL值与任何其它值的比较（即使是NULL）永远返回false，即 NULL = NULL 返回false 。</p>
<p>MySQL中处理NULL使用IS NULL和IS NOT NULL运算符。</p>
<h3 id="-null-"><strong>在命令提示符中使用 NULL 值</strong></h3>
<p>以下实例中假设数据库 TUTORIALS 中的表 tcount_tbl 含有两列 tutorial_author 和 tutorial_count, tutorial_count 中设置插入NULL值。</p>
<p>实例</p>
<p>尝试以下实例:</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; createtable tcount_tbl
    -&gt; (
    -&gt; tutorial_author varchar(40) NOTNULL,
    -&gt; tutorial_count  INT
    -&gt; );
Query OK, 0 rows affected (0.05 sec)
mysql&gt; INSERTINTO tcount_tbl
    -&gt; (tutorial_author, tutorial_count) values (&#39;mahran&#39;, 20);
mysql&gt; INSERTINTO tcount_tbl
    -&gt; (tutorial_author, tutorial_count) values (&#39;mahnaz&#39;, NULL);
mysql&gt; INSERTINTO tcount_tbl
    -&gt; (tutorial_author, tutorial_count) values (&#39;Jen&#39;, NULL);
mysql&gt; INSERTINTO tcount_tbl
    -&gt; (tutorial_author, tutorial_count) values (&#39;Gill&#39;, 20);

mysql&gt; SELECT * from tcount_tbl;
+-----------------+----------------+
| tutorial_author | tutorial_count |
+-----------------+----------------+
| mahran          |             20 |
| mahnaz          |           NULL |
| Jen             |           NULL |
| Gill            |             20 |
+-----------------+----------------+
4 rows in set (0.00 sec)

mysql&gt;
</code></pre><p>以下实例中你可以看到 = 和 != 运算符是不起作用的：</p>
<pre><code>mysql&gt; SELECT * FROM tcount_tbl WHERE tutorial_count = NULL;
Empty set (0.00 sec)
mysql&gt; SELECT * FROM tcount_tbl WHERE tutorial_count != NULL;
Empty set (0.01 sec)
</code></pre><p>查找数据表中 tutorial_count 列是否为 NULL，必须使用IS NULL和IS NOT NULL，如下实例：</p>
<pre><code>mysql&gt; SELECT * FROM tcount_tbl 
    -&gt; WHERE tutorial_count ISNULL;
+-----------------+----------------+
| tutorial_author | tutorial_count |
+-----------------+----------------+
| mahnaz          |           NULL |
| Jen             |           NULL |
+-----------------+----------------+
2 rows in set (0.00 sec)
mysql&gt; SELECT * from tcount_tbl 
    -&gt; WHERE tutorial_count ISNOTNULL;
+-----------------+----------------+
| tutorial_author | tutorial_count |
+-----------------+----------------+
| mahran          |             20 |
| Gill            |             20 |
+-----------------+----------------+
2 rows in set (0.00 sec)
</code></pre><h3 id="-php-null-"><strong>使用PHP脚本处理 NULL 值</strong></h3>
<p>PHP脚本中你可以在 if…else 语句来处理变量是否为空，并生成相应的条件语句。</p>
<p>以下实例中PHP设置了$tutorial_count变量，然后使用该变量与数据表中的 tutorial_count 字段进行比较：</p>
<pre><code>&lt;?php$dbhost = &#39;localhost:3036&#39;;
$dbuser = &#39;root&#39;;
$dbpass = &#39;rootpassword&#39;;
$conn = mysql_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die(&#39;Could not connect: &#39; . mysql_error());
}
if( isset($tutorial_count ))
{
   $sql = &#39;SELECT tutorial_author, tutorial_count
           FROM  tcount_tbl
           WHERE tutorial_count = $tutorial_count&#39;;
}
else
{
   $sql = &#39;SELECT tutorial_author, tutorial_count
           FROM  tcount_tbl
           WHERE tutorial_count IS $tutorial_count&#39;;
}

mysql_select_db(&#39;TUTORIALS&#39;);
$retval = mysql_query( $sql, $conn );
if(! $retval )
{
  die(&#39;Could not get data: &#39; . mysql_error());
}
while($row = mysql_fetch_array($retval, MYSQL_ASSOC))
{
    echo&quot;Author:{$row[&#39;tutorial_author&#39;]}  &lt;br&gt; &quot;.
         &quot;Count: {$row[&#39;tutorial_count&#39;]} &lt;br&gt; &quot;.
         &quot;--------------------------------&lt;br&gt;&quot;;
} 
echo&quot;Fetched data successfully\n&quot;;
mysql_close($conn);
?&gt;
</code></pre><hr>
<h2 id="mysql-">MySQL 正则表达式</h2>
<p>在前面的章节我们已经了解到MySQL可以通过 <strong>LIKE </strong>来进行模糊匹配。</p>
<p>MySQL 同样也支持其他正则表达式的匹配， MySQL中使用 REGEXP 操作符来进行正则表达式匹配。</p>
<p>如果您了解PHP或Perl，那么操作起来就非常简单，因为MySQL的正则表达式匹配与这些脚本的类似。</p>
<p>下表中的正则模式可应用于 REGEXP 操作符中。</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>\^</td>
<td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，\^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td>\$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，\$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td>
</tr>
<tr>
<td>[…]</td>
<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td>[\^…]</td>
<td>负值字符集合。匹配未包含的任意字符。例如， ‘[\^abc]’ 可以匹配 “plain” 中的’p’。</td>
</tr>
<tr>
<td>p1\,p2\,p3</td>
<td>匹配 p1 或 p2 或 p3。例如，’z\food’ 能匹配 “z” 或 “food”。’(z\f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n \&lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody>
</table>
<p>实例</p>
<p>了解以上的正则需求后，我们就可以更加自己的需求来编写带有正则表达式的SQL语句。以下我们将列出几个小实例(表名：person_tbl )来加深我们的理解：</p>
<p>查找name字段中以’st’为开头的所有数据：</p>
<pre><code>mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP&#39;^st&#39;;
</code></pre><p>查找name字段中以’ok’为结尾的所有数据：</p>
<pre><code>mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP&#39;ok$&#39;;
</code></pre><p>查找name字段中包含’mar’字符串的所有数据：</p>
<pre><code>mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP&#39;mar&#39;;
</code></pre><p>查找name字段中以元音字符开头且以’ok’字符串结尾的所有数据：</p>
<pre><code>mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP&#39;^[aeiou]|ok$&#39;;
</code></pre><hr>
<h2 id="mysql-">MySQL 事务</h2>
<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<ul>
<li>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务</li><li>事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行</li><li>事务用来管理insert,update,delete语句</li></ul>
<p>一般来说，事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）</p>
<ul>
<li>1、<strong>事务的原子性：</strong>一组事务，要么成功；要么撤回。</li><li>2、<strong>稳定性</strong> ： 有非法数据（外键约束之类），事务撤回。</li><li>3、<strong>隔离性：</strong>事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。</li><li>4、<strong>可靠性：</strong>软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit选项 决定什么时候吧事务保存到日志里。</li></ul>
<h3 id="-mysql-">在Mysql控制台使用事务来操作</h3>
<p>1，开始一个事务</p>
<pre><code>starttransaction
</code></pre><p>2, 做保存点</p>
<pre><code>save point 保存点名称
</code></pre><p>3, 操作</p>
<p>4，可以回滚，可以提交，没有问题，就提交，有问题就回滚。</p>
<p>PHP中使用事务实例</p>
<pre><code>&lt;?php$handler=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;password&quot;);
mysql_select_db(&quot;task&quot;);
mysql_query(&quot;SET AUTOCOMMIT=0&quot;);//设置为不自动提交，因为MYSQL默认立即执行
mysql_query(&quot;BEGIN&quot;);//开始事务定义if(!mysql_query(&quot;insert into trans (id) values(&#39;2&#39;)&quot;))
{
mysql_query(&quot;ROOLBACK&quot;);//判断当执行失败时回滚
}
if(!mysql_query(&quot;insert into trans (id) values(&#39;4&#39;)&quot;))
{
mysql_query(&quot;ROOLBACK&quot;);//判断执行失败回滚
}
mysql_query(&quot;COMMIT&quot;);//执行事务
mysql_close($handler);
?&gt;
</code></pre><hr>
<h2 id="mysql-alter-">MySQL ALTER命令</h2>
<p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p>
<p>开始本章教程前让我们先创建一张表，表名为：testalter_tbl。</p>
<pre><code>root@host# mysql -u root -p password;
Enter password:*******
mysql&gt; use TUTORIALS;
Database changed
mysql&gt; createtable testalter_tbl
    -&gt; (
    -&gt; i INT,
    -&gt; c CHAR(1)
    -&gt; );
Query OK, 0 rows affected (0.05 sec)
mysql&gt; SHOWCOLUMNSFROM testalter_tbl;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| i     | int(11) | YES  |     | NULL    |       |
| c     | char(1) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre><h3 id="-"><strong>删除，添加或修改表字段</strong></h3>
<p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl  DROP i;
</code></pre><p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p>
<p>MySQL 中使用 ADD 子句来想数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl ADD i INT;
</code></pre><p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p>
<pre><code>mysql&gt; SHOWCOLUMNSFROM testalter_tbl;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| c     | char(1) | YES  |     | NULL    |       |
| i     | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p>
<p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p>
<pre><code>ALTERTABLE testalter_tbl DROP i;ALTERTABLE testalter_tbl ADD i INTFIRST;ALTERTABLE testalter_tbl DROP i;ALTERTABLE testalter_tbl ADD i INTAFTER c;
</code></pre><p>FIRST 和 AFTER 关键字只占用于 ADD 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p>
<h3 id="-"><strong>修改字段类型及名称</strong></h3>
<p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p>
<p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl MODIFY c CHAR(10);
</code></pre><p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段的类型及名称。尝试如下实例：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl CHANGE i j BIGINT;
mysql&gt; ALTERTABLE testalter_tbl CHANGE j j INT;
</code></pre><h3 id="-alter-table-null-"><strong>ALTER TABLE 对 Null 值和默认值的影响</strong></h3>
<p>当你修改字段时，你可以指定是否包含只或者是否设置默认值。</p>
<p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl 
    -&gt; MODIFY j BIGINTNOTNULLDEFAULT100;
</code></pre><p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p>
<h3 id="-"><strong>修改字段默认值</strong></h3>
<p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl ALTER i SETDEFAULT1000;
mysql&gt; SHOWCOLUMNSFROM testalter_tbl;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| c     | char(1) | YES  |     | NULL    |       |
| i     | int(11) | YES  |     | 1000    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre><p>你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl ALTER i DROPDEFAULT;
mysql&gt; SHOWCOLUMNSFROM testalter_tbl;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| c     | char(1) | YES  |     | NULL    |       |
| i     | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
Changing a Table Type:
</code></pre><p>修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 testalter_tbl 的类型修改为 MYISAM ：</p>
<p><strong>注意：</strong>查看数据表类型可以使用 SHOW TABLE STATUS 语句。</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl TYPE = MYISAM;
mysql&gt;  SHOWTABLESTATUSLIKE&#39;testalter_tbl&#39;\G
*************************** 1.row ****************
           Name: testalter_tbl
           Type: MyISAM
     Row_format: Fixed
           Rows: 0
 Avg_row_length: 0
    Data_length: 0
Max_data_length: 25769803775
   Index_length: 1024
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2007-06-0308:04:36
    Update_time: 2007-06-0308:04:36
     Check_time: NULL
 Create_options:
        Comment:
1rowinset (0.00 sec)
</code></pre><h3 id="-"><strong>修改表名</strong></h3>
<p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p>
<p>尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl RENAMETO alter_tbl;
</code></pre><p>ALTER 命令还可以用来创建及删除MySQL数据表的索引，该功能我们会在接下来的章节中介绍。</p>
<hr>
<h2 id="mysql-">MySQL 索引</h2>
<p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>
<p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p>
<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<p>建立索引会占用磁盘空间的索引文件。</p>
<h3 id="-"><strong>普通索引</strong></h3>
<p>创建索引</p>
<p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<pre><code>CREATEINDEX indexName ON mytable(username(length));
</code></pre><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<p>修改表结构</p>
<pre><code>ALTER mytable ADDINDEX [indexName] ON (username(length)) 
</code></pre><p>创建表的时候直接指定</p>
<pre><code>CREATETABLE mytable(  
ID INTNOTNULL,   
username VARCHAR(16) NOTNULL,  
INDEX [indexName] (username(length))  
);
</code></pre><p>删除索引的语法</p>
<pre><code>DROPINDEX [indexName] ON mytable;
</code></pre><h3 id="-"><strong>唯一索引</strong></h3>
<p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<p>创建索引</p>
<pre><code>CREATEUNIQUEINDEX indexName ON mytable(username(length)) 
</code></pre><p>修改表结构</p>
<pre><code>ALTER mytable ADDUNIQUE [indexName] ON (username(length)) 
</code></pre><p>创建表的时候直接指定</p>
<pre><code>CREATETABLE mytable(  
ID INTNOTNULL,   
username VARCHAR(16) NOTNULL,  
UNIQUE [indexName] (username(length))  
);
</code></pre><h3 id="-alter-"><strong>使用ALTER 命令添加和删除索引</strong></h3>
<p>有四种方式来添加数据表的索引：</p>
<ul>
<li><strong>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</strong> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</li><li><strong>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):</strong>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul>
<p>以下实例为在表中添加索引。</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl ADDINDEX (c);
</code></pre><p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl DROPINDEX (c);
</code></pre><h3 id="-alter-"><strong>使用 ALTER 命令添加和删除主键</strong></h3>
<p>主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl MODIFY i INTNOTNULL;
mysql&gt; ALTERTABLE testalter_tbl ADDPRIMARYKEY (i);
</code></pre><p>你也可以使用 ALTER 命令删除主键：</p>
<pre><code>mysql&gt; ALTERTABLE testalter_tbl DROPPRIMARYKEY;
</code></pre><p>删除指定时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h3 id="-"><strong>显示索引信息</strong></h3>
<p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:</p>
<pre><code>mysql&gt; SHOWINDEXFROM table_name\G
........
</code></pre><hr>
<h2 id="mysql-">MySQL 临时表</h2>
<p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</p>
<p>临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p>
<p>MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那没当PHP脚本执行完成后，该临时表也会自动销毁。</p>
<p>如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。</p>
<p>实例</p>
<p>以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数。</p>
<pre><code>mysql&gt; CREATETEMPORARYTABLE SalesSummary (
    -&gt; product_name VARCHAR(50) NOTNULL
    -&gt; , total_sales DECIMAL(12,2) NOTNULLDEFAULT0.00
    -&gt; , avg_unit_price DECIMAL(7,2) NOTNULLDEFAULT0.00
    -&gt; , total_units_sold INT UNSIGNED NOTNULLDEFAULT0
);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERTINTO SalesSummary
    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)
    -&gt; VALUES
    -&gt; (&#39;cucumber&#39;, 100.25, 90, 2);

mysql&gt; SELECT * FROM SalesSummary;
+--------------+-------------+----------------+------------------+
| product_name | total_sales | avg_unit_price | total_units_sold |
+--------------+-------------+----------------+------------------+
| cucumber     |      100.25 |          90.00 |                2 |
+--------------+-------------+----------------+------------------+
1 row in set (0.00 sec)
</code></pre><p>当你使用 <strong>SHOW TABLES</strong>命令显示数据表列表时，你将无法看到 SalesSummary表。</p>
<p>如果你退出当前MySQL会话，再使用 <strong>SELECT</strong>命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p>
<h3 id="-mysql-"><strong>删除MySQL 临时表</strong></h3>
<p>默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用<strong> DROP TABLE </strong>命令来手动删除临时表。</p>
<p>以下是手动删除临时表的实例：</p>
<pre><code>mysql&gt; CREATETEMPORARYTABLE SalesSummary (
    -&gt; product_name VARCHAR(50) NOTNULL
    -&gt; , total_sales DECIMAL(12,2) NOTNULLDEFAULT0.00
    -&gt; , avg_unit_price DECIMAL(7,2) NOTNULLDEFAULT0.00
    -&gt; , total_units_sold INT UNSIGNED NOTNULLDEFAULT0
);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERTINTO SalesSummary
    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)
    -&gt; VALUES
    -&gt; (&#39;cucumber&#39;, 100.25, 90, 2);

mysql&gt; SELECT * FROM SalesSummary;
+--------------+-------------+----------------+------------------+
| product_name | total_sales | avg_unit_price | total_units_sold |
+--------------+-------------+----------------+------------------+
| cucumber     |      100.25 |          90.00 |                2 |
+--------------+-------------+----------------+------------------+
1 row in set (0.00 sec)
mysql&gt; DROPTABLE SalesSummary;
mysql&gt;  SELECT * FROM SalesSummary;
ERROR 1146: Table &#39;TUTORIALS.SalesSummary&#39; doesn&#39;t exist
</code></pre><hr>
<h2 id="mysql-">MySQL 复制表</h2>
<p>如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用<strong>CREATE TABLE … SELECT </strong>命令，是无法实现的。</p>
<p>本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下：</p>
<ul>
<li>使用 <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等。</li><li>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</li><li>如果你想复制表的内容，你就可以使用<strong> INSERT INTO … SELECT </strong>语句来实现。</li></ul>
<p>实例</p>
<p>尝试以下实例来复制表 tutorials_tbl 。</p>
<p>步骤一：</p>
<p>获取数据表的完整结构。</p>
<pre><code>mysql&gt; SHOWCREATETABLE tutorials_tbl \G;
*************************** 1. row ***************************
       Table: tutorials_tbl
CreateTable: CREATETABLE`tutorials_tbl` (
  `tutorial_id`int(11) NOTNULL auto_increment,
  `tutorial_title`varchar(100) NOTNULLdefault&#39;&#39;,
  `tutorial_author`varchar(40) NOTNULLdefault&#39;&#39;,
  `submission_date`datedefaultNULL,
  PRIMARYKEY  (`tutorial_id`),
  UNIQUEKEY`AUTHOR_INDEX` (`tutorial_author`)
) TYPE=MyISAM
1rowinset (0.00 sec)

ERROR:
Noquery specified
</code></pre><p>步骤二：</p>
<p>修改SQL语句的数据表名，并执行SQL语句。</p>
<pre><code>mysql&gt; CREATETABLE`clone_tbl` (
  -&gt; `tutorial_id`int(11) NOTNULL auto_increment,
  -&gt; `tutorial_title`varchar(100) NOTNULLdefault&#39;&#39;,
  -&gt; `tutorial_author`varchar(40) NOTNULLdefault&#39;&#39;,
  -&gt; `submission_date`datedefaultNULL,
  -&gt; PRIMARYKEY  (`tutorial_id`),
  -&gt; UNIQUEKEY`AUTHOR_INDEX` (`tutorial_author`)
-&gt; ) TYPE=MyISAM;
Query OK, 0 rows affected (1.80 sec)
</code></pre><p>步骤三：</p>
<p>执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用<strong> INSERT INTO… SELECT </strong>语句来实现。</p>
<pre><code>mysql&gt; INSERTINTO clone_tbl (tutorial_id,
    -&gt;                        tutorial_title,
    -&gt;                        tutorial_author,
    -&gt;                        submission_date)
    -&gt; SELECT tutorial_id,tutorial_title,
    -&gt;        tutorial_author,submission_date
    -&gt; FROM tutorials_tbl;
Query OK, 3 rows affected (0.07 sec)
Records: 3  Duplicates: 0  Warnings: 0
</code></pre><p>执行以上步骤后，你将完整的复制表，包括表结构及表数据。</p>
<hr>
<h2 id="-mysql-">查看MySQL 元数据</h2>
<p>你可能想知道MySQL以下三种信息：</p>
<ul>
<li><strong>查询结果信息：</strong> SELECT, UPDATE 或 DELETE语句影响的记录数。</li><li><strong>数据库和数据表的信息：</strong> 包含了数据库及数据表的结构信息。</li><li><strong>MySQL服务器信息：</strong> 包含了数据库服务器的当前状态，版本号等。</li></ul>
<p>在MySQL的命令提示符中，我们可以很容易的获取以上服务器信息。 但如果使用Perl或PHP等脚本语言，你就需要调用特定的接口函数来获取。 接下来我们会详细介绍。</p>
<h3 id="-"><strong>获取查询语句影响的记录数</strong></h3>
<p>PERL 实例</p>
<p>在 DBI 脚本中， 语句影响的记录数通过函数 do( ) 或 execute( )返回：</p>
<pre><code># 方法 1# 使用do( ) 执行  $query my$count = $dbh-&gt;do ($query);
# 如果发生错误会输出 0printf&quot;%d rows were affected\n&quot;, (defined ($count) ? $count : 0);

# 方法 2# 使用prepare( ) 及 execute( ) 执行  $query my$sth = $dbh-&gt;prepare ($query);
my$count = $sth-&gt;execute ( );
printf&quot;%d rows were affected\n&quot;, (defined ($count) ? $count : 0);
</code></pre><p>PHP 实例</p>
<p>在PHP中，你可以使用 mysql_affected_rows( ) 函数来获取查询语句影响的记录数。</p>
<pre><code>$result_id = mysql_query ($query, $conn_id);
# 如果查询失败返回 $count = ($result_id ? mysql_affected_rows ($conn_id) : 0);
print (&quot;$count rows were affected\n&quot;);
</code></pre><h3 id="-"><strong>数据库和数据表列表</strong></h3>
<p>你可以很容易的在MySQL服务器中获取数据库和数据表列表。 如果你没有足够的权限，结果将返回 null。</p>
<p>你也可以使用 SHOW TABLES 或 SHOW DATABASES 语句来获取数据库和数据表列表。</p>
<p>PERL 实例</p>
<pre><code># 获取当前数据库中所有可用的表。my@tables = $dbh-&gt;tables ( );
foreach$table (@tables ){
   print&quot;Table Name $table\n&quot;;
}
</code></pre><p>PHP 实例</p>
<pre><code>&lt;?php$con = mysql_connect(&quot;localhost&quot;, &quot;userid&quot;, &quot;password&quot;);
if (!$con)
{
  die(&#39;Could not connect: &#39; . mysql_error());
}

$db_list = mysql_list_dbs($con);

while ($db = mysql_fetch_object($db_list))
{
  echo$db-&gt;Database . &quot;&lt;br /&gt;&quot;;
}
mysql_close($con);
?&gt;
</code></pre><h3 id="-"><strong>获取服务器元数据</strong></h3>
<p>以下命令语句可以在MySQL的命令提示符使用，也可以在脚本中 使用，如PHP脚本。</p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT VERSION( )</td>
<td>服务器版本信息</td>
</tr>
<tr>
<td>SELECT DATABASE( )</td>
<td>当前数据库名 (或者返回空)</td>
</tr>
<tr>
<td>SELECT USER( )</td>
<td>当前用户名</td>
</tr>
<tr>
<td>SHOW STATUS</td>
<td>服务器状态</td>
</tr>
<tr>
<td>SHOW VARIABLES</td>
<td>服务器配置变量</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="mysql-auto_increment">MySQL 序列 AUTO_INCREMENT</h2>
<p>MySQL序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</p>
<p>本章我们将介绍如何使用MySQL的序列。</p>
<h3 id="-auto_increment-"><strong>使用AUTO_INCREMENT</strong></h3>
<p>MySQL中最简单使用序列的方法就是使用 MySQL AUTO_INCREMENT 来定义列。</p>
<p>实例</p>
<p>以下实例中创建了数据表insect， insect中id无需指定值可实现自动增长。</p>
<pre><code>mysql&gt; CREATETABLE insect
    -&gt; (
    -&gt; id INT UNSIGNED NOTNULL AUTO_INCREMENT,
    -&gt; PRIMARYKEY (id),
    -&gt; name VARCHAR(30) NOTNULL, # type of insect
    -&gt; dateDATENOTNULL, # date collected
    -&gt; origin VARCHAR(30) NOTNULL # where collected
);
Query OK, 0 rows affected (0.02 sec)
mysql&gt; INSERTINTO insect (id,name,date,origin) VALUES
    -&gt; (NULL,&#39;housefly&#39;,&#39;2001-09-10&#39;,&#39;kitchen&#39;),
    -&gt; (NULL,&#39;millipede&#39;,&#39;2001-09-10&#39;,&#39;driveway&#39;),
    -&gt; (NULL,&#39;grasshopper&#39;,&#39;2001-09-10&#39;,&#39;front yard&#39;);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0
mysql&gt; SELECT * FROM insect ORDERBY id;
+----+-------------+------------+------------+
| id | name        | date       | origin     |
+----+-------------+------------+------------+
|  1 | housefly    | 2001-09-10 | kitchen    |
|  2 | millipede   | 2001-09-10 | driveway   |
|  3 | grasshopper | 2001-09-10 | front yard |
+----+-------------+------------+------------+
3 rows in set (0.00 sec)
</code></pre><h3 id="-auto_increment-"><strong>获取AUTO_INCREMENT值</strong></h3>
<p>在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。</p>
<p>在PHP或PERL脚本中也提供了相应的函数来获取最后的插入表中的自增列的值。</p>
<p>PERL实例</p>
<p>使用 mysql_insertid 属性来获取 AUTO_INCREMENT 的值。 实例如下：</p>
<pre><code>$dbh-&gt;do (&quot;INSERT INTO insect (name,date,origin)
VALUES(&#39;moth&#39;,&#39;2001-09-14&#39;,&#39;windowsill&#39;)&quot;);
my $seq = $dbh-&gt;{mysql_insertid};
</code></pre><p>PHP实例</p>
<p>PHP 通过 mysql_insert_id ()函数来获取执行的插入SQL语句中 AUTO_INCREMENT列的值。</p>
<pre><code>mysql_query (&quot;INSERTINTO insect (name,date,origin)
VALUES(&#39;moth&#39;,&#39;2001-09-14&#39;,&#39;windowsill&#39;)&quot;, $conn_id);
$seq = mysql_insert_id ($conn_id);
</code></pre><h3 id="-"><strong>重置序列</strong></h3>
<p>如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示：</p>
<pre><code>mysql&gt; ALTERTABLE insect DROP id;
mysql&gt; ALTERTABLE insect
    -&gt; ADD id INT UNSIGNED NOTNULL AUTO_INCREMENT FIRST,
    -&gt; ADDPRIMARYKEY (id);
</code></pre><h3 id="-"><strong>设置序列的开始值</strong></h3>
<p>一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现：</p>
<pre><code>mysql&gt; CREATETABLE insect
    -&gt; (
    -&gt; id INT UNSIGNED NOTNULL AUTO_INCREMENT = 100,
    -&gt; PRIMARYKEY (id),
    -&gt; name VARCHAR(30) NOTNULL, # type of insect
    -&gt; dateDATENOTNULL, # date collected
    -&gt; origin VARCHAR(30) NOTNULL # where collected
);
</code></pre><p>或者你也可以在表创建成功后，通过以下语句来实现：</p>
<pre><code>mysql&gt; ALTERTABLE t AUTO_INCREMENT = 100;
</code></pre><hr>
<h2 id="mysql-">MySQL 处理重复数据</h2>
<p>有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。</p>
<p>本章节我们将为大家介绍如何防止数据表出现重复数据及如何删除数据表中的重复数据。</p>
<h3 id="-"><strong>防止表中出现重复数据</strong></h3>
<p>你可以在MySQL数据表中设置指定的字段为<strong> PRIMARY KEY（主键） </strong>或者<strong> UNIQUE（唯一） </strong>索引来保证数据的唯一性。</p>
<p>让我们尝试一个实例：下表中无索引及主键，所以该表允许出现多条重复记录。</p>
<pre><code>CREATETABLE person_tbl
(
    first_name CHAR(20),
    last_name CHAR(20),
    sex CHAR(10)
);
</code></pre><p>如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为NULL，可设置为NOT NULL。如下所示：</p>
<pre><code>CREATETABLE person_tbl
(
   first_name CHAR(20) NOTNULL,
   last_name CHAR(20) NOTNULL,
   sex CHAR(10),
   PRIMARYKEY (last_name, first_name)
);
</code></pre><p>如果我们设置了唯一索引，那么在插入重复数据时，SQL语句将无法执行成功,并抛出错。</p>
<p>INSERT IGNORE INTO与INSERT INTO的区别就是INSERT IGNORE会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p>
<p>以下实例使用了INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据：</p>
<pre><code>mysql&gt; INSERTIGNOREINTO person_tbl (last_name, first_name)
    -&gt; VALUES( &#39;Jay&#39;, &#39;Thomas&#39;);
Query OK, 1 row affected (0.00 sec)
mysql&gt; INSERTIGNOREINTO person_tbl (last_name, first_name)
    -&gt; VALUES( &#39;Jay&#39;, &#39;Thomas&#39;);
Query OK, 0 rows affected (0.00 sec)
</code></pre><p>INSERT IGNORE INTO当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而REPLACE INTO into如果存在primary 或 unique相同的记录，则先删除掉。再插入新记录。</p>
<p>另一种设置数据的唯一性方法是添加一个UNIQUE索引，如下所示：</p>
<pre><code>CREATETABLE person_tbl
(
   first_name CHAR(20) NOTNULL,
   last_name CHAR(20) NOTNULL,
   sex CHAR(10)
   UNIQUE (last_name, first_name)
);
</code></pre><h3 id="-"><strong>统计重复数据</strong></h3>
<p>以下我们将统计表中 first_name 和 last_name的重复记录数：</p>
<pre><code>mysql&gt; SELECTCOUNT(*) as repetitions, last_name, first_name
    -&gt; FROM person_tbl
    -&gt; GROUPBY last_name, first_name
    -&gt; HAVING repetitions &gt; 1;
</code></pre><p>以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作：</p>
<ul>
<li>确定哪一列包含的值可能会重复。</li><li>在列选择列表使用COUNT(*)列出的那些列。</li><li>在GROUP BY子句中列出的列。</li><li>HAVING子句设置重复数大于1。</li></ul>
<h3 id="-"><strong>过滤重复数据</strong></h3>
<p>如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。</p>
<pre><code>mysql&gt; SELECTDISTINCT last_name, first_name
    -&gt; FROM person_tbl
    -&gt; ORDERBY last_name;
</code></pre><p>你也可以使用 GROUP BY 来读取数据表中不重复的数据：</p>
<pre><code>mysql&gt; SELECT last_name, first_name
    -&gt; FROM person_tbl
    -&gt; GROUPBY (last_name, first_name);
</code></pre><h3 id="-"><strong>删除重复数据</strong></h3>
<p>如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：</p>
<pre><code>mysql&gt; CREATETABLE tmp SELECT last_name, first_name, sex
    -&gt;                  FROM person_tbl;
    -&gt;                  GROUP BY (last_name, first_name);
mysql&gt; DROPTABLE person_tbl;
mysql&gt; ALTERTABLE tmp RENAMETO person_tbl;
</code></pre><p>当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：</p>
<pre><code>mysql&gt; ALTERIGNORETABLE person_tbl
    -&gt; ADDPRIMARYKEY (last_name, first_name);
</code></pre><hr>
<h2 id="mysql-sql-">MySQL 及 SQL 注入</h2>
<p>如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。</p>
<p>本章节将为大家介绍如何防止SQL注入，并通过脚本来过滤SQL中注入的字符。</p>
<p>所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。</p>
<p>以下实例中，输入的用户名必须为字母、数字及下划线的组合，且用户名长度为 8 到 20 个字符之间：</p>
<pre><code>if (preg_match(&quot;/^\w{8,20}$/&quot;, $_GET[&#39;username&#39;], $matches))
{
   $result = mysql_query(&quot;SELECT * FROM users 
                          WHERE username=$matches[0]&quot;);
}
 else 
{
   echo&quot;username 输入异常&quot;;
}
</code></pre><p>让我们看下在没有过滤特殊字符时，出现的SQL情况：</p>
<pre><code>// 设定$name 中插入了我们不需要的SQL语句$name = &quot;Qadir&#39;; DELETE FROM users;&quot;;
mysql_query(&quot;SELECT * FROM users WHERE name=&#39;{$name}&#39;&quot;);
</code></pre><p>以上的注入语句中，我们没有对 $name 的变量进行过滤，$name 中插入了我们不需要的SQL语句，将删除 users 表中的所有数据。</p>
<p>在PHP中的 mysql_query() 是不允许执行多个SQL语句的，但是在 SQLite 和 PostgreSQL 是可以同时执行多条SQL语句的，所以我们对这些用户的数据需要进行严格的验证。</p>
<p>防止SQL注入，我们需要注意以下几个要点：</p>
<ul>
<li>1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li><li>2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li><li>3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li><li>5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li><li>6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li></ul>
<h3 id="-sql-"><strong>防止SQL注入</strong></h3>
<p>在脚本语言，如Perl和PHP你可以对用户输入的数据进行转义从而来防止SQL注入。</p>
<p>PHP的MySQL扩展提供了mysql_real_escape_string()函数来转义特殊的输入字符。</p>
<pre><code>if (get_magic_quotes_gpc()) 
{
  $name = stripslashes($name);
}
$name = mysql_real_escape_string($name);
mysql_query(&quot;SELECT * FROM users WHERE name=&#39;{$name}&#39;&quot;);
</code></pre><h3 id="-like-"><strong>Like语句中的注入</strong></h3>
<p>like查询时，如果用户输入的值有”<em>“和”%”，则会出现这种情况：用户本来只是想查询”abcd</em>“，查询结果中却有”abcd_”、”abcde”、”abcdf”等等；用户要查询”30%”（注：百分之三十）时也会出现问题。</p>
<p>在PHP脚本中我们可以使用addcslashes()函数来处理以上情况，如下实例：</p>
<pre><code>$sub = addcslashes(mysql_real_escape_string(&quot;%something_&quot;), &quot;%_&quot;);
// $sub == \%something\_
mysql_query(&quot;SELECT * FROM messages WHERE subject LIKE &#39;{$sub}%&#39;&quot;);
</code></pre><p>addcslashes() 函数在指定的字符前添加反斜杠。</p>
<p>语法格式:</p>
<pre><code>addcslashes(string,characters)
</code></pre><p>参数描述string必需。规定要检查的字符串。characters可选。规定受 addcslashes() 影响的字符或字符范围。</p>
<hr>
<h2 id="mysql-">MySQL 导出数据</h2>
<p>MySQL中你可以使用<strong>SELECT…INTO OUTFILE</strong>语句来简单的导出数据到文本文件上。</p>
<h3 id="-select-into-outfile-"><strong>使用 SELECT … INTO OUTFILE 语句导出数据</strong></h3>
<p>以下实例中我们将数据表 tutorials_tbl 数据导出到 /tmp/tutorials.txt 文件中:</p>
<pre><code>mysql&gt; SELECT * FROM tutorials_tbl 
    -&gt; INTOOUTFILE&#39;/tmp/tutorials.txt&#39;;
</code></pre><p>你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：</p>
<pre><code>mysql&gt; SELECT * FROM passwd INTOOUTFILE&#39;/tmp/tutorials.txt&#39;
    -&gt; FIELDSTERMINATEDBY&#39;,&#39;ENCLOSEDBY&#39;&quot;&#39;
    -&gt; LINESTERMINATEDBY&#39;\r\n&#39;;
</code></pre><p>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。</p>
<pre><code>SELECT a,b,a+b INTOOUTFILE&#39;/tmp/result.text&#39;FIELDSTERMINATEDBY&#39;,&#39;OPTIONALLYENCLOSEDBY&#39;&quot;&#39;LINESTERMINATEDBY&#39;\n&#39;FROM test_table;
</code></pre><h4 id="select-into-outfile-">SELECT … INTO OUTFILE 语句有以下属性:</h4>
<ul>
<li>LOAD DATA INFILE是SELECT … INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT … INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。</li><li>SELECT…INTO OUTFILE ‘file_name’形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。</li><li>输出不能是一个已存在的文件。防止文件数据被篡改。</li><li>你需要有一个登陆服务器的账号来检索文件。否则 SELECT … INTO OUTFILE 不会起任何作用。</li><li>在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除。</li></ul>
<h3 id="-"><strong>导出表作为原始数据</strong></h3>
<p>mysqldump是mysql用于转存储数据库的实用程序。它主要产生一个SQL脚本，其中包含从头重新创建数据库所必需的命令CREATE TABLE INSERT等。</p>
<p>使用mysqldump导出数据需要使用 —tab 选项来指定导出文件指定的目录，该目标必须是可写的。</p>
<p>以下实例将数据表 tutorials_tbl 导出到 /tmp 目录中：</p>
<pre><code>$ mysqldump -u root -p --no-create-info \--tab=/tmp TUTORIALS tutorials_tbl
password ******
</code></pre><h3 id="-sql-"><strong>导出SQL格式的数据</strong></h3>
<p>导出SQL格式的数据到指定文件，如下所示：</p>
<pre><code>$ mysqldump -u root -p TUTORIALS tutorials_tbl &gt; dump.txt
password ******
</code></pre><p>以上命令创建的文件内容如下：</p>
<pre><code>-- MySQL dump 8.23---- Host: localhost    Database: TUTORIALS----------------------------------------------------------- Server version       3.23.58---- Table structure for table `tutorials_tbl`--CREATETABLE tutorials_tbl (
  tutorial_id int(11) NOTNULL auto_increment,
  tutorial_title varchar(100) NOTNULLdefault&#39;&#39;,
  tutorial_author varchar(40) NOTNULLdefault&#39;&#39;,
  submission_date datedefaultNULL,
  PRIMARYKEY  (tutorial_id),
  UNIQUEKEY AUTHOR_INDEX (tutorial_author)
) TYPE=MyISAM;---- Dumping data for table `tutorials_tbl`--INSERTINTO tutorials_tbl 
       VALUES (1,&#39;Learn PHP&#39;,&#39;John Poul&#39;,&#39;2007-05-24&#39;);INSERTINTO tutorials_tbl 
       VALUES (2,&#39;Learn MySQL&#39;,&#39;Abdul S&#39;,&#39;2007-05-24&#39;);INSERTINTO tutorials_tbl 
       VALUES (3,&#39;JAVA Tutorial&#39;,&#39;Sanjay&#39;,&#39;2007-05-06&#39;);
</code></pre><p>如果你需要导出整个数据库的数据，可以使用以下命令：</p>
<pre><code>$ mysqldump -u root -p TUTORIALS &gt; database_dump.txt
password ******
</code></pre><p>如果需要备份所有数据库，可以使用以下命令：</p>
<pre><code>$ mysqldump -u root -p --all-databases &gt; database_dump.txt
password ******
</code></pre><p>—all-databases 选项在 MySQL 3.23.12 及以后版本加入。</p>
<p>该方法可用于实现数据库的备份策略。</p>
<h3 id="-"><strong>将数据表及数据库拷贝至其他主机</strong></h3>
<p>如果你需要将数据拷贝至其他的 MySQL 服务器上, 你可以在 mysqldump 命令中指定数据库名及数据表。</p>
<p>在源主机上执行以下命令，将数据备份至 dump.txt 文件中:</p>
<pre><code>$ mysqldump -u root -p database_name table_name &gt; dump.txt
password *****
</code></pre><p>如果完整备份数据库，则无需使用特定的表名称。</p>
<p>如果你需要将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建：</p>
<pre><code>$ mysql -u root -p database_name &lt; dump.txt
password *****
</code></pre><p>你也可以使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的：</p>
<pre><code>$ mysqldump -u root -p database_name \
       | mysql -h other-host.com database_name
</code></pre><p>以上命令中使用了管道来将导出的数据导入到指定的远程主机上。</p>
<hr>
<h2 id="mysql-">MySQL 导入数据</h2>
<p>MySQL中可以使用两种简单的方式来导入MySQL导出的数据。</p>
<h3 id="-load-data-"><strong>使用 LOAD DATA 导入数据</strong></h3>
<p>MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。</p>
<pre><code>mysql&gt; LOADDATALOCALINFILE&#39;dump.txt&#39;INTOTABLE mytbl;
</code></pre><p>如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</p>
<p>你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。</p>
<p>两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。</p>
<p>如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。</p>
<pre><code>mysql&gt; LOADDATALOCALINFILE&#39;dump.txt&#39;INTOTABLE mytbl
  -&gt; FIELDSTERMINATEDBY&#39;:&#39;
  -&gt; LINESTERMINATEDBY&#39;\r\n&#39;;
</code></pre><p>LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。</p>
<p>如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：</p>
<pre><code>mysql&gt; LOADDATALOCALINFILE&#39;dump.txt&#39; 
    -&gt; INTOTABLE mytbl (b, c, a);
</code></pre><h3 id="-mysqlimport-"><strong>使用 mysqlimport 导入数据</strong></h3>
<p>mysqlimport客户端提供了LOAD DATA INFILEQL语句的一个命令行接口。mysqlimport的大多数选项直接对应LOAD DATA INFILE子句。</p>
<p>从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：</p>
<pre><code>$ mysqlimport -u root -p --local database_name dump.txt
password *****
</code></pre><p>mysqlimport命令可以指定选项来设置指定格式,命令语句格式如下：</p>
<pre><code>$ mysqlimport -u root -p --local --fields-terminated-by=&quot;:&quot; \--lines-terminated-by=&quot;\r\n&quot;  database_name dump.txt
password *****
</code></pre><p>mysqlimport 语句中使用 —columns 选项来设置列的顺序：</p>
<pre><code>$ mysqlimport -u root -p --local --columns=b,c,a \
    database_name dump.txt
password *****
</code></pre><h3 id="-mysqlimport-"><strong>mysqlimport的常用选项介绍</strong></h3>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-d or —delete</td>
<td>新数据导入数据表中之前删除数据数据表中的所有信息</td>
</tr>
<tr>
<td>-f or —force</td>
<td>不管是否遇到错误，mysqlimport将强制继续插入数据</td>
</tr>
<tr>
<td>-i or —ignore</td>
<td>mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。</td>
</tr>
<tr>
<td>-l or -lock-tables</td>
<td>数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。</td>
</tr>
<tr>
<td>-r or -replace</td>
<td>这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。</td>
</tr>
<tr>
<td>--fields-enclosed- by= char</td>
<td>指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。</td>
</tr>
<tr>
<td>--fields-terminated- by=char</td>
<td>指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab）</td>
</tr>
<tr>
<td>--lines-terminated- by=str</td>
<td>此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="mysql-">MYSQL 函数</h1>
<h2 id="mysql-">MYSQL 函数大全</h2>
<p>这里是所有重要的 MySQL 函数的列表。每个函数都用合适的例子来说明如下。</p>
<ul>
<li><p>MySQL Group By 子句 - MySQL的GROUP BY语句以及SQL聚合函数，用于类似SUM提供某些数据库表的列来分组结果数据集</p>
</li><li><p>MySQL IN 子句 - 这是一个子句，它可以用来连同任何MySQL查询语句以指定条件</p>
</li><li><p>MySQL BETWEEN 子句 - 这是一个子句，它可以用来与任何MySQL查询来指定条件</p>
</li><li><p>MySQL UNION关键字 - 使用UNION操作多个结果集组合成一个结果集</p>
</li><li><p>MySQL COUNT()函数 - MySQL的COUNT聚合函数用于计算一个数据库表中的行数</p>
</li><li><p>MySQL MAX() 函数 - MySQL的MAX聚合函数允许我们选择某些列的最高(最大)值</p>
</li><li><p>MySQL MIN()函数 - MySQL的MIN聚合函数允许我们选择某些列的最低(最小)值</p>
</li><li><p>MySQL AVG()函数 - MySQL的AVG聚合函数是用来对某些表的列求它的平均值</p>
</li><li><p>MySQL SUM()函数 - MySQL的SUM聚合函数允许选择某列的总和</p>
</li><li><p>MySQL SQRT函数 - 这是用来生成给定数的平方根</p>
</li><li><p>MySQL RAND()函数 - 使用MySQL命令产生一个随机数</p>
</li><li><p>MySQL CONCAT()函数 - 这是用来连接MySQL命令中的任何字符串</p>
</li><li><p>MySQL DATE 和 Time 时间日期函数 - MySQL日期和时间相关的函数完整列表</p>
</li><li><p>MySQL数字函数 - 在MySQL中操作数字的MySQL函数完整列表</p>
</li><li><p>MySQL字符串函数 - 在MySQL中的字符串操作的MySQL函数的完整列表</p>
</li></ul>
<hr>
<h2 id="mysql-group-by-">MySQL Group By 实例讲解</h2>
<pre><code>group by语法可以根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。
SELECT子句中的列名必须为分组列或列函数。列函数对于GROUP BY子句定义的每个组各返回一个结果。
某个员工信息表结构和数据如下：
</code></pre><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>dept</th>
<th>salary</th>
<th>edlevel</th>
<th>hiredate</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张三</td>
<td>开发部</td>
<td>2000</td>
<td>3</td>
<td>2009-10-11</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>开发部</td>
<td>2500</td>
<td>3</td>
<td>2009-10-01</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>设计部</td>
<td>2600</td>
<td>5</td>
<td>2010-10-02</td>
</tr>
<tr>
<td>4</td>
<td>王六</td>
<td>设计部</td>
<td>2300</td>
<td>4</td>
<td>2010-10-03</td>
</tr>
<tr>
<td>5</td>
<td>马七</td>
<td>设计部</td>
<td>2100</td>
<td>4</td>
<td>2010-10-06</td>
</tr>
<tr>
<td>6</td>
<td>赵八</td>
<td>销售部</td>
<td>3000</td>
<td>5</td>
<td>2010-10-05</td>
</tr>
<tr>
<td>7</td>
<td>钱九</td>
<td>销售部</td>
<td>3100</td>
<td>7</td>
<td>2010-10-07</td>
</tr>
<tr>
<td>8</td>
<td>孙十</td>
<td>销售部</td>
<td>3500</td>
<td>7</td>
<td>2010-10-07</td>
</tr>
</tbody>
</table>
<p>例如，我想列出每个部门最高薪水的结果，sql语句如下：</p>
<pre><code>SELECT DEPT, MAX(SALARY) AS MAXIMUM
FROM STAFF
GROUPBY DEPT
</code></pre><p>查询结果如下：</p>
<table>
<thead>
<tr>
<th>DEPT</th>
<th>MAXIMUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发部</td>
<td>2500</td>
</tr>
<tr>
<td>设计部</td>
<td>2600</td>
</tr>
<tr>
<td>销售部</td>
<td>3500</td>
</tr>
</tbody>
</table>
<p>解释一下这个结果：</p>
<p>1、满足“SELECT子句中的列名必须为分组列或列函数”，因为SELECT有GROUP BY DEPT中包含的列DEPT。</p>
<p>2、“列函数对于GROUP BY子句定义的每个组各返回一个结果”，根据部门分组，对每个部门返回一个结果，就是每个部门的最高薪水。</p>
<p>注意：计算的是每个部门（由 GROUP BY 子句定义的组）而不是整个公司的 MAX(SALARY)。</p>
<p>例如，查询每个部门的总的薪水数</p>
<pre><code>SELECT DEPT, sum( SALARY ) AS total
FROM STAFF
GROUPBY DEPT
</code></pre><p>查询结果如下：</p>
<table>
<thead>
<tr>
<th>DEPT</th>
<th>total</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发部</td>
<td>4500</td>
</tr>
<tr>
<td>设计部</td>
<td>7000</td>
</tr>
<tr>
<td>销售部</td>
<td>9600</td>
</tr>
</tbody>
</table>
<p>将 WHERE 子句与 GROUP BY 子句一起使用</p>
<p>分组查询可以在形成组和计算列函数之前具有消除非限定行的标准 WHERE 子句。必须在GROUP BY 子句之前指定 WHERE 子句。</p>
<p>例如，查询公司2010年入职的各个部门每个级别里的最高薪水</p>
<pre><code>SELECT DEPT, EDLEVEL, MAX( SALARY ) AS MAXIMUM
FROM staff
WHERE HIREDATE &gt; &#39;2010-01-01&#39;GROUPBY DEPT, EDLEVEL
ORDERBY DEPT, EDLEVEL
</code></pre><p>查询结果如下：</p>
<table>
<thead>
<tr>
<th>DEPT</th>
<th>EDLEVEL</th>
<th>MAXIMUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计部</td>
<td>4</td>
<td>2300</td>
</tr>
<tr>
<td>设计部</td>
<td>5</td>
<td>2600</td>
</tr>
<tr>
<td>销售部</td>
<td>5</td>
<td>3000</td>
</tr>
<tr>
<td>销售部</td>
<td>7</td>
<td>3500</td>
</tr>
</tbody>
</table>
<p>注意：在SELECT语句中指定的每个列名也在GROUP BY子句中提到。未在这两个地方提到的列名将产生错误。</p>
<p>GROUP BY子句对DEPT和EDLEVEL的每个唯一组合各返回一行。</p>
<p>在GROUP BY子句之后使用HAVING子句</p>
<p>可应用限定条件进行分组，以便系统仅对满足条件的组返回结果。为此，在GROUP BY子句后面包含一个HAVING子句。HAVING子句可包含一个或多个用AND和OR连接的谓词。每个谓词将组特性（如AVG(SALARY)）与下列之一进行比较：</p>
<p>例如：寻找雇员数超过2个的部门的最高和最低薪水：</p>
<pre><code>SELECT DEPT, MAX( SALARY ) AS MAXIMUM, MIN( SALARY ) AS MINIMUM
FROM staff
GROUPBY DEPT
HAVINGCOUNT( * ) &gt;2ORDERBY DEPT
</code></pre><p>查询结果如下：</p>
<table>
<thead>
<tr>
<th>DEPT</th>
<th>MAXIMUM</th>
<th>MINIMUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计部</td>
<td>2600</td>
<td>2100</td>
</tr>
<tr>
<td>销售部</td>
<td>3500</td>
<td>3000</td>
</tr>
</tbody>
</table>
<p>例如：寻找雇员平均工资大于3000的部门的最高和最低薪水：</p>
<pre><code>SELECT DEPT, MAX( SALARY ) AS MAXIMUM, MIN( SALARY ) AS MINIMUM
FROM staff
GROUPBY DEPT
HAVINGAVG( SALARY ) &gt;3000ORDERBY DEPT
</code></pre><p>查询结果如下：</p>
<table>
<thead>
<tr>
<th>DEPT</th>
<th>MAXIMUM</th>
<th>MINIMUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>销售部</td>
<td>3500</td>
<td>3000</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="mysql-max-">MySQL Max()函数实例讲解</h2>
<p>所谓“列的最大值”可以这样理解：假如有一列，这一列表示商品的单价，我们想找出单价最贵的价格是多少。</p>
<p>在MySQL中，有一个统计函数：Max(列名)，可以用于统计某一列的最大值。</p>
<p><strong>语法：</strong></p>
<pre><code>selectmax(列名) from 表名
</code></pre><p>假如有如下的一个表：</p>
<pre><code>mysql&gt; select * from test1;
+------+---------+----------------------------------+------------+
| t_id | t_name  | t_password                       | t_birth    |
+------+---------+----------------------------------+------------+
|    1 | name1   | 12345678901234567890123456789012 | NULL       |
|    2 | name2   | 12345678901234567890123456789012 | 2013-01-01 |
|    3 | myname1 | 0123456789012345678911           | 1990-01-01 |
+------+---------+----------------------------------+------------+
3 rows in set (0.00 sec)
</code></pre><p>我们要找到t_id最大值是多少，这里的t_id的最大值基本上可以理解为有多少个用户。</p>
<pre><code>mysql&gt; selectmax(t_id) from test1;
+-----------+
| max(t_id) |
+-----------+
|         3 |
+-----------+
1 row in set (0.03 sec)
</code></pre><p>从这个结果可以看出，t_id最大值为3.</p>
<hr>
<h2 id="mysql-count-">mysql count函数实例</h2>
<p>count函数是用来统计表中或数组中记录的一个函数，下面我来介绍在mysql中count函数用法。</p>
<p>count(*) 它返回检索行的数目， 不论其是否包含 NULL值。</p>
<p>SELECT 从一个表中检索，而不检索其它的列，并且没有 WHERE子句时， COUNT(*)被优化到最快的返回速度。</p>
<p>例如：</p>
<pre><code>mysql&gt; SELECTCOUNT(*) FROM student;
</code></pre><p>COUNT(DISTINCT 字段)这个优化仅适用于 MyISAM表, 原因是这些表类型会储存一个函数返回记录的精确数量，而且非常容易访问。</p>
<p>对于事务型的存储引擎(InnoDB, BDB), 存储一个精确行数的问题比较多，原因是可能会发生多重事物处理,</p>
<p>而每个都可能会对行数产生影响。</p>
<p>返回不同的非NULL值数目。</p>
<p>若找不到匹配的项，则COUNT(DISTINCT)返回 0 。</p>
<p><strong>例</strong></p>
<p>创建用于测试的数据表，以进行count数据统计：</p>
<pre><code>CREATETABLE`user` (
  `id`int(5) unsigned NOTNULL AUTO_INCREMENT,
  `name`varchar(10) DEFAULTNULL,
  `password`varchar(10) DEFAULTNULL,
  PRIMARYKEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=4DEFAULTCHARSET=latin1

测试数据为：

1 name1 1234562 name2 1234563 name3 1234564 name4  NULL
</code></pre><p>请注意以下查询的返回结果</p>
<pre><code>select count(*) from`user`selectcount(name) from`user`selectcount(password) from`user`
</code></pre><p>输出结果：4,4,3</p>
<p><strong>原因分析：</strong></p>
<ol>
<li>count(*)是对行数目进行计数，所以结果为4。</li><li>count(column_name)是对列中不为空的行进行计数，所以count(name)=4，而count(password)=3。</li></ol>
<p>以上二点，在使用count函数时，要注意下。</p>
<p>使用GROUP BY对每个owner的所有记录分组，没有它，你会得到错误消息：</p>
<pre><code>mysql&gt; SELECT owner, COUNT(*) FROM pet;
ERROR 1140 (42000): Mixing of GROUP columns (MIN(),MAX(),COUNT(),...)
with no GROUP columns is illegal if there is no GROUP BY clause
</code></pre><p>COUNT( )和GROUP BY以各种方式分类你的数据。下列例子显示出进行动物普查操作的不同方式。</p>
<p>每种动物的数量：</p>
<pre><code>mysql&gt; SELECT species, COUNT(*) FROM pet GROUPBY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</code></pre><p>每种性别的动物数量：</p>
<pre><code>mysql&gt; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</code></pre><p>（在这个输 出中，NULL表示“未知性别”。）</p>
<p>按种类和性别组合的动物数量：</p>
<pre><code>mysql&gt; SELECT species, sex, COUNT(*) FROM pet GROUPBY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</code></pre><p>若使用COUNT( )，你不必检索整个表。例如, 前面的查询，当只对狗和猫进行时，应为：</p>
<pre><code>mysql&gt; SELECT species, sex, COUNT(*) FROM pet
    -&gt; WHERE species = &#39;dog&#39;OR species = &#39;cat&#39;
    -&gt; GROUPBY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</code></pre><p>或， 如果你仅需要知道已知性别的按性别的动物数目：</p>
<pre><code>mysql&gt; SELECT species, sex, COUNT(*) FROM pet
    -&gt; WHERE sex ISNOTNULL
    -&gt; GROUPBY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</code></pre><p><strong>顺便提下mysql的DISTINCT的关键字有很多你想不到的用处</strong></p>
<p>1.在count 不重复的记录的时候能用到</p>
<p>比如SELECT COUNT( DISTINCT id ) FROM tablename;</p>
<p>就是计算talbebname表中id不同的记录有多少条</p>
<p>2,在需要返回记录不同的id的具体值的时候可以用</p>
<p>比如SELECT DISTINCT id FROM tablename;</p>
<p>返回talbebname表中不同的id的具体的值</p>
<p>3.上面的情况2对于需要返回mysql表中2列以上的结果时会有歧义</p>
<p>比如SELECT DISTINCT id, type FROM tablename;</p>
<p>实际上返回的是 id与type同时不相同的结果,也就是DISTINCT同时作用了两个字段，必须得id与tyoe都相同的才被排除了,与我们期望的结果不一样</p>
<p>4.这时候可以考虑使用group_concat函数来进行排除,不过这个mysql函数是在mysql4.1以上才支持的</p>
<p>5.其实还有另外一种解决方式,就是使用</p>
<p>SELECT id, type, count(DISTINCT id) FROM tablename</p>
<p>虽然这样的返回结果多了一列无用的count数据(或许你就需要这个我说的无用数据)</p>
<p>返回的结果是 只有id不同的所有结果和上面的4类型可以互补使用,就是看你需要什么样的数据了</p>
<hr>
<h2 id="mysql-union-union-all-">MYSQL UNION和UNION ALL实例</h2>
<h3 id="-mysql-union-"><strong>MYSQL中的UNION</strong></h3>
<p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。</p>
<p>举例说明：</p>
<pre><code>select * from table1 unionselect * from table2
</code></pre><p>这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。  </p>
<p><strong>MySQL中的UNION ALL</strong></p>
<p>UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。</p>
<p>举例说明：</p>
<pre><code>select * from table1 unionallselect * from table2
</code></pre><p>注: 使用 UNION 时 前一个 select column的个数要等于后一个select column的个数</p>
<p>如:</p>
<pre><code>table1: (id,createDate,lastUpdateDate,desc,num,hashCode),
table2: (id,createDate,lastUpdateDate,desc)
</code></pre><p>如果现在使用: select <em> from table1 UNION ALL select </em> from table2 则是不会成功的, 数据库会报错: </p>
<p>Error The used SELECT statements have a different number of columns</p>
<p>这是提示查询的两张表的字段不统一，如果table1比table2的字段内容多，可以使用空字符串来代替</p>
<pre><code>select id,createDate,lastUpdateDate,desc,num,hashCode from table1 UNIONALLselect id,createDate,lastUpdateDate,desc,&#39;&#39;,&#39;&#39;from table2 
</code></pre><p>如果里面有不想要的，千万要记住前面查询内容要和后面查询内容的字段个数要一样，前面你查询4个，后面也要相应的放4个，这样就不会提示参数数量不同的错误了。</p>
<p>其实稍稍修改一下就可以了</p>
<p>对于 ‘select id,createDate,desc,hasCode from table1’ 可以任意选择4个field</p>
<p>从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。</p>
<p>如果遇到两张表数据不同来集合查询，可以使用union all这个函数进行操作</p>
<pre><code>SELECTCOUNT(c.a)  FROM (
(SELECT UID a,ID,SERIAL,ParkName,CardNO,ScoreRealPay,PayFlag,PayType,Createtime FROM cp_consumption_record WHERE UID=761AND PayFlag=1  ORDERBY Createtime DESC) UNIONALL (SELECT UID a,CpResID,CpParkID,ParkSERIAL,CarCode,Price,BusinessType,CardNO,CreateDate FROM cp_reservation WHERE UID=761AND BusinessType IN(1,2,3) ORDERBY CreateDate DESC)
) c
</code></pre><p>这是查询结果集共有多少条数据，</p>
<p>如果还有查询条件，直接在c后面添加就可以，比如按照时间进行查询</p>
<pre><code>SELECT c.UID,c.ScoreRealPay,c.PayFlag,c.PayType  FROM (
(SELECT UID AS UID,ID AS ID,SERIALASSERIAL ,ParkName AS ParkName,CardNO CardNO,ScoreRealPay ScoreRealPay,PayFlag PayFlag,PayType PayType,Createtime Createtime FROM cp_consumption_record WHERE UID=761AND PayFlag=1  ORDERBY Createtime DESC) UNIONALL (SELECT UID a,CpResID,CpParkID,ParkSERIAL,CarCode,Price,BusinessType,CardNO,CreateDate FROM cp_reservation WHERE UID=761AND BusinessType IN(1,2,3) ORDERBY CreateDate DESC)
) c ORDERBY Createtime DESC/ASC
</code></pre><p>这里强调一下，你要按照什么样的条件进行查询时，要分别在select子查询中添加上条件，最后在按照统一的时间倒序或者正序</p>
<p>注: </p>
<p>缺省的情况下,UNION 子句不返回重复的记录.如果想显示所有记录,可以加ALL选项 </p>
<p>UNION运算要求查询具有相同数目的字段.但是,字段数据类型不必相同. </p>
<hr>
<h2 id="mysql-in-">MySQL IN 用法</h2>
<h3 id="-mysql-in-"><strong>MySQL IN 语法</strong></h3>
<p>IN 运算符用于 WHERE 表达式中，以列表项的形式支持多个选择，语法如下：</p>
<pre><code>WHERE column IN (value1,value2,...)
WHERE column NOT IN (value1,value2,...)
</code></pre><p>当 IN 前面加上 NOT 运算符时，表示与 IN 相反的意思，即不在这些列表项内选择。</p>
<h3 id="-in-"><strong>IN 使用实例</strong></h3>
<p>选取 uid 为 2、3、5 的用户数据：</p>
<pre><code>SELECT * FROMuserWHERE uid IN (2,3,5)
</code></pre><p>返回查询结果如下：</p>
<table>
<thead>
<tr>
<th><strong>uid</strong></th>
<th><strong>username</strong></th>
<th><strong>password</strong></th>
<th><strong>email</strong></th>
<th><strong>regdate</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>小明</td>
<td>a193686a53e4de85ee3f2ff0576adf01</td>
<td>xiao\@163.com</td>
<td>1278063917</td>
</tr>
<tr>
<td>3</td>
<td>Jack</td>
<td>0193686a35e4de85ee3f2ff0567adf490</td>
<td>jack\@gmail.com</td>
<td>1278061380</td>
</tr>
<tr>
<td>5</td>
<td>5idev</td>
<td>a193686a53e4de85ee3f2ff0576adf01</td>
<td>5idev\@5idev.com</td>
<td>1291107029</td>
</tr>
</tbody>
</table>
<h3 id="-in-"><strong>IN 子查询</strong></h3>
<p>更多情况下，IN 列表项的值是不明确的，而可能是通过一个子查询得到的：</p>
<pre><code>SELECT * FROM article WHERE uid IN(SELECT uid FROMuserWHEREstatus=0)
</code></pre><p>在这个 SQL 例子里，我们实现了查出所有状态为 0 的用户（可能是被禁止）的所有文章。首先通过一个查询得到所有所有 status=0 的用户：</p>
<pre><code>SELECT uid FROMuserWHEREstatus=0
</code></pre><p>然后将查询结果作为 IN 的列表项以实现最终的查询结果，注意在子查询中返回的结果必须是一个字段列表项。</p>
<h3 id="-in-"><strong>IN 运算符补充说明</strong></h3>
<p>IN 列表项不仅支持数字，也支持字符甚至时间日期类型等，并且可以将这些不同类型的数据项混合排列而无须跟 column 的类型保持一致：</p>
<pre><code>SELECT * FROMuserWHERE uid IN(1,2,&#39;3&#39;,&#39;c&#39;)
</code></pre><p>一个 IN 只能对一个字段进行范围比对，如果要指定更多字段，可以使用 AND 或 OR 逻辑运算符：</p>
<pre><code>SELECT * FROMuserWHERE uid IN(1,2) OR username IN(&#39;admin&#39;,&#39;manong&#39;)
</code></pre><p>使用 AND 或 OR 逻辑运算符后，IN 还可以和其他如 LIKE、&gt;=、= 等运算符一起使用。</p>
<h3 id="-in-"><strong>关于 IN 运算符的效率问题</strong></h3>
<p>如果 IN 的列表项是确定的，那么可以用多个 OR 来代替：</p>
<pre><code>SELECT * FROMuserWHERE uid IN (2,3,5)

// 等效为：

SELECT * FROMuserWHERE (uid=2OR aid=3OR aid=5)
</code></pre><p>一般认为，如果是对索引字段进行操作，使用 OR 效率高于 IN，但对于列表项不确定的时候（如需要子查询得到结果），就必须使用 IN 运算符。另外，对于子查询表数据小于主查询的时候，也是适用 IN 运算符的。</p>
<hr>
<h2 id="mysql-between-and-">MySQL between and 实例讲解</h2>
<p>BETWEEN 运算符用于 WHERE 表达式中,选取介于两个值之间的数据范围</p>
<pre><code>SELECT * FROMTABLEWHERE id BETWEEN1AND10;
</code></pre><p>这句话就是查询出 table表 中id 在1和10之间的所有数据。</p>
<p>如果还有另外的条件就直接加在后边就可以了。</p>
<p>比如:</p>
<pre><code>SELECT * FROMTABLEWHERE id BETWEEN1AND10AND add_time=2012;
</code></pre><p>查询table表中id在1和10之间并且add_time等于2012的所有数据。</p>
<p>注意：</p>
<pre><code>SELECT * FROMTABLEWHERE id BETWEEN a AND b   
</code></pre><p>a必须是下限值，b必须是上限值</p>
<p>用通俗一点的话说就是a比较小的值，b就比较大的值。如果a b两个是字符串的时候，a的值必须是较早插入数据库的，b的值就是相对a来说较晚插入数据库的值。</p>
<p>如果两个值写反了，不会提示报错，但是返回的结果集是空的。一定要注意这个问题！</p>
<hr>
<p><strong>微信关注公众号“Assistants”</strong></p>
<p><strong>回复关键字“知识图谱”、“必读书籍”、“数据分析”送给需要的你一份知识礼包</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/377461/1596442246485-52a81fc9-3666-443b-b46f-87172540fad3.png?x-oss-process=image%2Fresize%2Cw_746" alt="公众号“Assistants”"></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
